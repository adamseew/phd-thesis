
%
%%%%%%%%%%%%%
%           %
% Results   %
%           %
%%%%%%%%%%%%%
%
% Brief abstract: wraps up the results from the previous chapters
%
% Completion (1-10): 10
% Missing: summary
% Proofreading: 24/10/21
% -----------
% Quality check: 27/10/2021 15:46 PASS
%
\chapter{Results}
\label{cp:res}

\begin{chapquote}{\cite{sudhakar2020balancing}}
  ``[Computing energy included motion planning] shows improved performance over the baseline and looks to be promising solution to the low-power motion planning problem.''
\end{chapquote}

\vspace*{1em}

\lettrine{I}{n this chapter}, we report some results both published in our early studies~\citep{seewald2019coarse,seewald2020mechanical} and to appear in a forthcoming study~\citep{seewald202Xenergy}, validating our overall approach of energy-aware coverage planning and scheduling for autonomous aerial robots. The chapter thus connects to the remainder of the work by describing our experimental setup and results. It involves \frefm{cp:model}{cp:dyn}{Chapters}, which contains our most notable contribution: the energy and battery models for both the computation and motion of an aerial robot and a coverage planning and scheduling technique that uses the models. \fref{cp:pb}{Chapter} is limitedly involved as well: we extensively use the agricultural use case we introduced in \fref{sec:flight-plan}{Section} to showcase our approach, along with other formalities we proposed in the chapter.

The remainder of this chapter is structured as follows. In \fref{sec:res-ene-comps}{Section}, we describe our experimental setup and results for the computations energy model obtained with the \powprof{} tool. We then detail case studies of the motion energy of an aerial robot flying a path similar to \fref{sec:flight-plan}{Section} independently and along with the computing hardware in \fref{sec:res-ene-mot}{Section}. In both \frefm{sec:res-ene-comps}{sec:res-ene-mot}{Sections}, we describe our experimental setup for a battery of the computing hardware, aerial robot, and computing hardware with the aerial robot, detailing for each the results. In \fref{sec:res-dyn}{Section}, we then describe the coverage planning and scheduling in \matlab and the popular Paparazzi flight controller~\citep{papa} and thus, validate our work experimentally.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computations Energy Modeling}
\label{sec:res-ene-comps}

In this section, we describe the results and the experimental setup to obtain computations energy models with the \powprof{} tool. We report how we derive both the measurement and predictive layers from \frefm{sec:measurement-layer}{sec:predictive-layer}{Sections} and the battery model from \fref{sec:battery-model}{Section} to integrate the two layers with the battery contribution for the computing hardware.

\subsection{The {\tt darknet-gpu} computation}\findex{computations!darknet-gpu@\texttt{darknet-gpu}}
\label{sec:res-darknet-gpu}

In \fref{fig:darknet-layer1}{Figure}, we illustrate a concrete example of four different measurement layers from our early contribution~\citep{seewald2019coarse}: the power evolution in the function of time for three measuring devices, CPU, GPU, and overall of the NVIDIA Jetson TX2 computing hardware\findex{NVIDIA Jetson!TX2}. 
\begin{figure}[t!]
  \begin{minipage}{.93\textwidth}
  \centering
  \fontfamily{phv}\selectfont
  \hspace*{20ex}
  \input{figures/darknet-layer1.tikz}
  \end{minipage}
  \caption[YOLO DNN library detection computation measurement layer models]{The {\tt darknet-gpu} computation measurement layer models, featuring the GPU implementation of the YOLO~\citep{redmon2016you} DNN library modified to introduce delays between detections. From top left in horizontal order to bottom right, the figure shows the schedules from approximately six up to thirty-two FPS. The figure appeared in our early study~\citep{seewald2019coarse}.}
  \label{fig:darknet-layer1}
\end{figure}
The model is relative to one computation with four different schedules where we observed notable differences in instantaneous and overall energies. The computation consists of an object detection algorithm that we term {\small\tt darknet-gpu}, a neural network-based pattern recognition utility. It is a standard computer vision computation, built upon the darknet~\citep{redmond2017yolo,redomnd2013darknet}\findex{darknet} GPU implementation of a deep neural network (\Gls{acr:dnn}) library YOLO~\citep{redmon2016you}\findex{YOLO}, which detects the objects on some pre-trained as well as trained networks (the latter to detect a personalized set of objects).

In an initial iteration of our work~\citep{teamplayd43}, we trained the network using images of different shapes and colors for a search and rescue aerial robotics use case where the robot detects vessels on the sea. We benchmarked the corresponding computation on a video stream of vessels in an offshore area, simulating an aerial robot flying the use case with a camera. We further modified the {\small\tt darknet-gpu} computation to simulate different scheduling options, such that the computation can be altered with a given parameter, which we call $c_{i,1}$ in accordance to \fref{def:stage}{Definition} $\forall\,i\in[l]$  (with the plan lasting assigned $l$ stages). The parameter indicates the delay between two invocations of the detection, simulating different frames per second (\Gls{acr:fps}) rates. 
\begin{figure}[t!]
  \centering
  \fontfamily{phv}\selectfont
  \input{figures/darknet-layer2.tikz}
  \caption[Per-minute energy consumption and SoC of the YOLO DNN library detection computation]{Per-minute energy consumption and SoC of the {\tt darknet-gpu} computation in terms of CPU, GPU, and overall energies. On the right is the resulting predictive layer that shows the energy (same scale as on the left) and battery SoC in the function of any possible configuration. The figure is from our early study~\citep{seewald2019coarse}.}
  \label{fig:darknet-layer2}
\end{figure}
We schedule the computation with the parameter $c_{i,1}$ to assess the predictive layer in \fref{fig:darknet-layer2}{Figure}. On the right of the figure, we further illustrate the battery state of charge (\Gls{acr:soc}) in the function of varying FPS for the overall power measuring device of the computing hardware (dashed line). Similarly, the predictive layer provides the evolution of the energy also in the function of varying FPS (continuous line).

We used a frequency of ten hertz and a running time of one minute to derive all the measurement layers. The energy measure in \fref{fig:darknet-layer2}{Figure} is then relative to the energy needed to run the computation for a minute and the correspondent remaining SoC. For the latter, we used an integration step of one hundredth, internal battery voltage $V$ of 14.8 volts, internal resistance $R_r$ of 1.2 milliohms, stabilized voltage $V_s$ of twelve volts, and battery capacity $Q_c$ of five amperes per hour in \frefeqM{eq:socevol}{eq:internal_curr} in \fref{sec:batmod-circuit}{Section}. The parameters that correspond to such configurations are {\small\tt frequency=10}, {\small\tt h=0.01}, and {\small\tt runtime=60000} in the specification in \fref{sec:conf-spec}{Section}, whereas the battery values are specified while invoking the constructor of the {\small\tt soc\_1resistor} class. Both \frefm{fig:darknet-layer1}{fig:darknet-layer2}{Figures} show the parameter $c_{i,1}$ within $\mathcal{S}_{i,1}$ constructed so that the resulting FPS is between 5.8 and thirty-two.

\subsection{The {\tt matrix-gpu} computation}\findex{computations!matrix-gpu@\texttt{matrix-gpu}}

We then derived a set of measurement and predictive layers of another computation, {\small\tt matrix-gpu}, also related to our early study~\citep{seewald2019coarse}. Here we use again the NVIDIA Jetson TX2 computing hardware and its overall power measuring device (the computing hardware supports measurements of the power for CPU and GPU separately, as well as overall; see \fref{sec:measurement-layer}{Section}). {\small\tt matrix-gpu} computes the matrix exponentiation on the GPU of various matrix sizes using parameter $c_{i,1}$, with different exponents using $c_{i,2}$ and delaying the intermediate steps of the exponentiation with different times using $c_{i,3}$ (we assume that the parameters are the same for all the $l$ stages). The exponentiation is meant to  simulate the heavy computational load of, e.g., an algorithm related to computer vision. Indeed these algorithms often rely on various operations with matrix representations of images where, for instance, color balancing (i.e., incandescent lighting compensation) occurs by multiplication with a scale factor~\citep{szeliski2011computer}.
\begin{figure}[t!]
  \centering
  \begin{subfigure}[t]{0.405\textwidth}
      \centering
      \fontfamily{phv}\selectfont
      \input{figures/matrix-gpu-exponent-power.tikz}
      \caption{Average power}
      \label{fig:matrix-exponent:power}
      \vskip\baselineskip
      \input{figures/matrix-gpu-exponent-energy.tikz}
      \caption{Overall energy}
      \label{fig:matrix-exponent:energy}
  \end{subfigure}
  \quad
  \begin{subfigure}[c]{0.475\textwidth}   
      \centering 
      \fontfamily{phv}\selectfont
      \vspace{14.8ex}
      \input{figures/matrix-gpu-exponent-battery.tikz}
      \caption{Remaining battery capacity}  
      \label{fig:matrix-exponent:battery}
  \end{subfigure}
  \caption[Predictive layers of the matrix exponentiation computation in the function of exponent and size]{Predictive layers with the power in \fref{fig:matrix-exponent:power}{Figure}, energy in \fref{fig:matrix-exponent:energy}{Figure}, and battery SoC in \fref{fig:matrix-exponent:battery}{Figure} of the {\small\tt matrix-gpu} component in the function of varying matrix size and exponent. The figure is from our early study~\citep{seewald2019coarse}.}
  \label{fig:matrix-exponent}
\end{figure}
We illustrate the predictive layers for the computation varying the parameter $c_{i,1}$ from 256 to 4096 and $c_{i,2}$ from twenty to sixty in \fref{fig:matrix-exponent}{Figure} (these values enclose the sets $\mathcal{S}_{i,1}$ and $\mathcal{S}_{i,2}$ respectively). Particularly, \fref{fig:matrix-exponent:power}{Figure} shows the average power, \fref{fig:matrix-exponent:energy}{Figure} the overall energy, and \fref{fig:matrix-exponent:battery}{Figure} the battery SoC as a function of matrix size and exponent. We report the average power consumption independently of the running time of the {\small\tt matrix-gpu}, whereas the overall energy and the battery state of charge measures are measured up until a given configuration of the two parameters $c_{i}=\{c_{i,1},c_{i,2}\}$ evaluated the exponentiation. The computation might pose no notable effect on the total power consumption for values of $c_{i}$ close to $\underline{c}_{i,1}$ and $\underline{c}_{i,2}$ for parameters $c_{i,1},c_{i,2}$. An effect indicating the computation terminated before reaching the maximal power level~\citep{seewald2019coarse}, also visible in \fref{fig:darknet-layer1}{Figure}. It is the reason why there is a notable difference in average power for two opposite configurations.

\begin{figure}[ht!]
  \centering
  \begin{subfigure}[t]{0.475\textwidth}
      \centering
      \fontfamily{phv}\selectfont
      \input{figures/matrix-gpu-sleep-power.tikz}
      \caption{Average power}
      \label{fig:matrix-sleep:power}
      \vskip\baselineskip
      \input{figures/matrix-gpu-sleep-energy.tikz}
      \caption{Overall energy}
      \label{fig:matrix-sleep:energy}
  \end{subfigure}
  \quad
  \begin{subfigure}[c]{0.475\textwidth}   
      \centering 
      \fontfamily{phv}\selectfont
      \vspace{14.8ex}
      \input{figures/matrix-gpu-sleep-battery.tikz}
      \caption{Remaining battery capacity}  
      \label{fig:matrix-sleep:battery}
  \end{subfigure}
  \caption[Predictive layers in the function of varying exponent and schedules]{Predictive layers with the power in \fref{fig:matrix-exponent:power}{Figure}, energy in \fref{fig:matrix-exponent:energy}{Figure}, and battery SoC in \fref{fig:matrix-exponent:battery}{Figure} of the {\small\tt matrix-gpu} component in the function of varying matrix size and delays between consecutive iterations, simulating different schedules. The figure is from our early study~\citep{seewald2019coarse}.}
  \label{fig:matrix-sleep}
\end{figure}
In \fref{fig:matrix-sleep}{Figure}, we illustrate the predictive layers by varying the parameters $c_{i,1}$ and $c_{i,3}$ relative to the delay--or ``sleep''--between iterations of the matrix exponentiation from none to ten seconds. \fref{fig:matrix-sleep:power}{Figure} shows the average power, \fref{fig:matrix-sleep:energy}{Figure} the overall energy, and \fref{fig:matrix-sleep:battery}{Figure} the battery SoC as a function of the matrix size and sleep. We observe that the latter directly affects the overall power consumption hence, the higher the delay, the lower the remaining battery SoC (conversely, the higher the overall energy). In both sets of \frefm{fig:matrix-exponent:energy}{fig:matrix-exponent:battery}{Figures} and \frefm{fig:matrix-sleep:energy}{fig:matrix-sleep:battery}{Figures}, we thus observe a relation between overall energy and battery SoC.

We used the same configuration parameters as with the {\small\tt darknet-gpu} computation but for the running time. In \frefm{fig:matrix-exponent}{fig:matrix-sleep}{Figures}, the runtime is unbounded: the average power, overall energy, and battery SoC are relative to the entire exponentiation. The battery parameters are likewise the same. To define the constraint sets $\mathcal{S}_{i,1}$, we used the configuration {\small\tt pow}, e.g., {\small\tt range=256,4096,pow(2)}, meaning $c_{i,1}$ utilizes exponential sampling in \frefeq{eq:meas-layer-exp-sampl}. 

\subsection{The {\tt darknet}/{\tt matrix} {\tt -cpu}, {\tt nvidia-} {\tt matrix}/{\tt quicks} computations}\findex{computations!darknet-cpu@\texttt{darknet-cpu}}\findex{computations!matrix-cpu@\texttt{matrix-cpu}}\findex{computations!nvidia-matrix@\texttt{nvidia-matrix}}\findex{computations!nvidia-quicks@\texttt{nvidia-quicks}}

We deployed the computations energy model on additional computations and computing hardware, including {\small\tt matrix-cpu} and {\small\tt darknet-cpu}, similar to {\small\tt matrix-gpu} and {\small\tt darknet-gpu} computations except that the operations run on the CPU rather than GPU. We used all the computing hardware described in \fref{sec:model-hete-elem}{Section} for {\small\tt matrix-cpu}, and NVIDIA Jetson TX2 for {\small\tt darknet-cpu}. On NVIDIA Jetson TX2, we further interfaced some already existing benchmarks with the \powprof{} tool. 
These were modified to run for several instances over a time interval and implement a quicksort ({\small\tt nvidia-quicks}) and a matrix multiplication ({\small\tt nvidia-matrix}), both with a given problem size (parameter $c_{i,4}$). We summarize the overall energy contribution of all the computations from this section in \fref{tab:benchmark-components}{Table}. 
\begin{table}[t]
  \footnotesize\fontfamily{phv}\selectfont
  \begin{tabularx}{\textwidth}{|l|*{3}{X|}X|l|}
    \hline
    \multirow{2}{*}{Computation} & ODROID & \multicolumn{3}{c|}{NVIDIA} & \multirow{2}{*}{\scriptsize Runtime} \\
    & XU3 & TK1 & TX2 & Nano &  \\
    \hline
    {\small\tt matrix-cpu}    & 528.4 J & 406.7 J & 241.3 J & 273.6 J & \xmark \\
    {\small\tt matrix-gpu}    & - & 8.1 J & 4.5 J & 3.9 J & \xmark \\
    {\small\tt darknet-cpu}   & (-) & (-) & 240 J & (-) & \cmark \\
    {\small\tt darknet-gpu}   & - & - & 525.5 J & (-) & \cmark \\
    {\small\tt nvidia-matrix} & - & (-) & 405.4 J & (-) & \xmark \\
    {\small\tt nvidia-quicks} & - & (-) & 199.5 J & (-) & \xmark \\
    \hline
  \end{tabularx}
  \caption[Overall energy per computation on different computing hardware]{Overall energy per computation on different computing hardware. \cmark{} indicates that the runtime is fixed, \xmark{} unbounded. Unsupported hardware is indicated by ``-'', whereas possible future support by ``(-)'' from our early study~\citep{seewald2019coarse}.}
  \label{tab:benchmark-components}
\end{table}
The table shows the performance while running on different computing hardware and heterogeneous elements. For instance, {\small\tt matrix-gpu} requires considerably less energy compared to {\small\tt matrix-cpu}; indeed, there is a large performance gap between GPUs and general-purpose multicore CPUs in terms of heavily parallelizable computations~\citep{kirk2016programming}: {\small\tt matrix-gpu} requires only 4.5 joules, whereas {\small\tt matrix-cpu} 241.3 joules for the same operation on the NVIDIA Jetson TX2 computing hardware~\citep{seewald2019coarse}; the battery SoC evolves accordingly, with the difference between {\small\tt matrix-gpu} and {\small\tt matrix-cpu} in terms of battery SoC being 16\%. In our early work~\citep{seewald2019coarse,seewald2019component}, we further observe the parallelization effect on the overall energy. We can conserve energy by running computations parallel on the CPU and GPU compared to a sequential schedule (e.g., scheduling computations sequentially on CPU and GPU in some order) even if we subtract the base power. This latter results in a 20\% larger overall energy consumption than a parallel schedule~\citep{seewald2019coarse}.

In \fref{tab:benchmark-components}{Table} we additionally compare {\small\tt darknet-gpu} to {\small\tt darknet-cpu}, which is similar to its GPU equivalent but runs merely on the CPU. Although {\small\tt darknet-cpu} requires less energy per minute compared to {\small\tt darknet-gpu}, it runs for considerably longer; the energy cost per frame is then higher on the CPU~\citep{seewald2019coarse}. We further show the energy effect of the {\small\tt nvidia-matrix} and {\small\tt nvidia-quicks} computations on the NVIDIA Jetson TX2 computing hardware. The {\small\tt nvidia-matrix} computation runs a significant portion on the CPU to check whenever the result of the GPU matrix multiplication matches the one on the CPU. Nonetheless, we observe that the problem size affects the overall energy consumption and battery SoC in both the {\small\tt nvidia-matrix} and {\small\tt nvidia-quicks} computations~\citep{seewald2019coarse}. One notable difference between the two latter computations is the nature of the problem they solve; {\small\tt nvidia-quicks} uses random data that are being sorted and has thus lower predictability in terms of overall energy~\citep{seewald2019coarse}.

\subsection{Validation}
\label{sec:res-validation-nikov}

To validate the computations energy model from \fref{sec:comp-ener-model}{Section} illustrated in this chapter via the output of the \powprof{} tool, we demonstrated that the model and the tool function on numerous heterogeneous computing hardware and various computations~\citep{seewald2019coarse}. In \fref{tab:benchmark-components}{Table}, we empirically evaluate the {\small\tt matrix-cpu} computation on the ODROID XU3, NVIDIA Jetson TK1, TX2, and Nano computing hardware\findex{ODROID XU3}\findex{NVIDIA Jetson!TK1}\findex{NVIDIA Jetson!TX2}\findex{NVIDIA Jetson!Nano}. The {\small\tt matrix-gpu} on the NVIDIA Jetson computing hardware, and the rest of the computations in this section on the NVIDIA Jetson TX2 computing hardware. A cross-platform comparison shows the energy efficiency of different computing hardware: the {\small\tt matrix-cpu} computation is most efficient on NVIDIA Jetson TX2 computing hardware, followed by Nano, TK1, and ODROID XU3. Some computations not explicitly evaluated here can be potentially extended in future instances of our approach (hyphen in parenthesis in \fref{tab:benchmark-components}{Table}) conversely to others that are not supported (hyphen in \fref{tab:benchmark-components}{Table}). 

We then evaluate the \powprof{} tool through comparison with an external measuring device, i.e., a multimeter connected to the power source of the NVIDIA Jetson TX2 hardware. We observe a close co-relation between external and internal power measures. The error is less than 3\% over one minute, with the external exceeding the internal measuring device, possibly due to the energy impact of the carrier board~\citep{seewald2019coarse}. Indeed the NVIDIA Jetson TX2 computing hardware we use is mounted on the Jetson Developer Kit board in \fref{fig:tx2}{Figure}. We further observe that the internal measurements of the overall power include the energy impact of the tool itself, and conclude that the tool's effect on the power is marginal~\citep{seewald2019coarse}. We later saw the same effect with other libraries, such as the Robot Operating System (\Gls{acr:ros}) middleware\findex{Robot Operating System}~\citep{zamanakos2020energy}.

We further validate our model against a more fine-grained model in the literature~\citep{nunez2013enabling,nikov2015evaluation}, using the ODROID XU3 computing hardware with the {\small\tt matrix-cpu} computation. We described this further validation step in our early work~\citep{seewald2019coarse}. The fine-grained model requires some apriori training, which we performed by evaluating the computation configuration with parameters $c_{i,1}=$ 512, and $c_{i,2}=$ 30 (meaning the thirtieth power of square matrix of size 512). The model returns an expected energy value, which we compared by subsequently running the computation, obtaining an error of 3.42\%~\citep{seewald2019coarse}. Similarly, we used the \powprof{} tool by varying $c_{i,2}$ with a step that excludes the configuration $c_{i,2}=$ 30. We then obtained an expected energy value for configuration 30, which we again evaluated against running the configuration subsequently, obtaining an error of 2.25\%~\citep{seewald2019coarse}, justifying ours against another model in the literature. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Studies in Motion Energy Modeling}
\label{sec:res-ene-mot}

In this section, we discuss case studies of motion energy models from \fref{sec:mot-ener-model}{Section} of an aerial robot flying the agricultural use case doing static coverage path planning (\Gls{acr:cpp})\findex{coverage path planning}. We use the computations energy and battery models from \frefm{sec:comp-ener-model}{sec:battery-model}{Sections} to integrate the static CPP with computing hardware and the effect of the battery. The coverage is decided offline, with no online replanning when unexpected events occur (e.g., sudden battery drops). We will then replan such coverage in \fref{sec:res-dyn}{Section} along with the scheduling of the computations. 

In detail, here we deploy two case studies of aerial robots flying the Zamboni-like motion: in \fref{sec:res-perio}{Section}, we derive an energy model using the expression in \frefeq{eq:fourier}, relying on the periodicity of the energy signal; we use NVIDIA Jetson TX2 as computing hardware integrated at a later stage~\citep{seewald2020mechanical}. In \fref{sec:res-diff}{Section}, we derive a differential energy model based on expressions in \frefeq{eq:state-perf} and \fref{lem:eqv}{Lemma}; we use NVIDIA Jetson Nano and ROS middleware also integrated at a later stage. The first case study uses a static model where we cannot predict, e.g., future energy consumption with varying schedules or flight time with varying coverage; whereas the second allows such operation. Indeed we will use a similar approach later in \fref{sec:res-dyn}{Section} for energy-aware coverage planning and scheduling.

\subsection{Periodic modeling case study}
\label{sec:res-perio}

The first case study is the aerial robot flying the agricultural use case and doing static CPP while exploiting the model in \frefeq{eq:fourier} for the energy signal, which we studied in our previous work~\citep{seewald2020mechanical}. 

\subsubsection*{Experimental setup}

The aerial robot is the Opterra fixed-wing that we first presented in \fref{cp:intro}{Chapter}. It uses the Apogee v1.00 microcontroller with the popular Paparazzi flight controller~\citep{papa} and has a 3.2 amperes per hour battery. The experimental setup then consists of the NVIDIA Jetson TX2 computing hardware evaluated separately of the aerial robot with two computations. The {\small\tt darknet-gpu} computation that detects objects with the YOLO~\citep{redmon2016you} DNN library (which we encountered in \fref{sec:res-darknet-gpu}{Section}), varying a parameter $c_{i,1}$ relative to the delay in two consecutive detections and thus the FPS rate. The {\small\tt blowfish}\findex{computations!blowfish@\texttt{blowfish}} computation then encrypts the data with a symmetric variable key algorithm named ``Blowfish''~\citep{schneier1993description}\findex{Blowfish algorithm}\findex{encryption}\findex{symmetric encryption}, varying a parameter $c_{i,2}$, the key-size. To model the motion energy, we analyzed the flight logs from the Paparazzi flight controller of the aerial robot flying the agricultural use case using a static Zamboni-like motion in \fref{sec:cov-motion}{Section} implemented in the flight controller. We derive the constants $a,b,\omega$ in \frefeq{eq:fourier} from similar flights on the same day with standard atmospheric conditions (i.e., typical wind and temperature). We rely on the energy evolution periodicity; the data in \fref{sec:mot-ener-model}{Section} (concretely in \frefm{fig:energy-1}{fig:spectrum-1}{Figures}) refer to this case study and show a periodic energy evolution. We then model the energy with three frequencies, including the base frequency.

We assume static dependency on motion energy, with only computation energy varying with different computations. Here again, the {\small\tt darknet-gpu} varies in the same range as in \fref{sec:res-darknet-gpu}{Section}, whereas {\small\tt blowfish} varies between thirty-two and 448 bits, enclosing the computations constraint $\mathcal{S}_{i,2}$. For the latter, we used the OpenSSL~\citep{viega2002network}\findex{OpenSSL} command-line\findex{command-line} tool for a heavy data file of approximately 150 megabytes in an iterated encryption manner. The two computations were in this use case analyzed separately. An approach we discussed in our previous work where per-component energy is modeled in a dataflow computational network, decreasing the modeling effort~\citep{seewald2019component}.

\subsubsection*{Motion energy evaluation}

The motion energy models are in \fref{fig:path-energy}{Figure} and some corresponding paths in \frefm{fig:takeoff-path}{fig:landing-path}{Figures}.
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize
  \begin{subfigure}[c]{0.475\textwidth}
    \centering
    \input{figures/path-plot-take-off.tikz}
    \caption{Take-off phase path}
    \label{fig:takeoff-path}
    \vspace{1.4ex}
  \end{subfigure}
  \begin{subfigure}[c]{0.475\textwidth}
    \centering
    \input{figures/path-plot-landing.tikz}
    \vspace*{3ex}
    \caption{Landing phase path}
    \label{fig:landing-path}
    \vspace{1.4ex}
  \end{subfigure}
  \quad
  \begin{subfigure}[t]{0.35\textwidth}
    \centering
    \input{figures/takeoff.tikz}
    \caption{Take-off energy}
    \label{fig:takeoff-energy}
  \end{subfigure}
  \begin{subfigure}[t]{0.31\textwidth}
    \centering
    \input{figures/cruise.tikz}
    \caption{Cruise energy}
    \label{fig:cruise-energy-fourier}
  \end{subfigure}
  \begin{subfigure}[t]{0.30\textwidth}
    \centering
    \input{figures/landing.tikz}
    \caption{Landing energy}
    \label{fig:landing-energy}
  \end{subfigure}
  \caption[Paths and modeled energy evolutions in time for different flight phases]{Paths and modeled energy evolutions in time for different flight phases as they appeared in our early study~\citep{seewald2020mechanical}.}
  \label{fig:path-energy}
\end{figure}
In this use case, we saw marked variability in energy signals for take-off\findex{take-off}, cruise\findex{cruise}, and landing\findex{landing} phases per flight\findex{flight phases}. To distinguish between the phases, we analyzed the motor torque, altitude, and throttle~\citep{seewald2020mechanical}. The Opterra fixed-wing aerial robot\findex{Opterra fixed-wing aerial robot} gains altitude during take-off before starting to fly the Zamboni-like motion for coverage. The modeled energy signal is in \fref{fig:takeoff-energy}{Figure}. It is evaluated from some test flights (the gray area in the figure), whereas \matlab aids the resulting regression (black line in the figure). Such a regressional analysis depicts little variability at the beginning of the take-off, likely justified by different controls necessary by various atmospheric conditions, and very little to no variability in the remaining. This latter part of the trajectory is where the flight controller guides the aerial robot on the Zamboni-like motion\findex{Zamboni-like motion}. \fref{fig:cruise-energy-fourier}{Figure} is the modeled energy signal for the cruise phase. There is little variability between the test flights; the flight controller takes charge of the guidance. Finally, there is considerable variability in the landing phase energy signal illustrated in \fref{fig:landing-energy}{Figure}. Initially, the aerial robot flies in small circles (see the path in \fref{fig:landing-path}{Figure}), lowering the altitude while descending to the ground under human control~\citep{seewald2020mechanical}. The phase depends on different conditions, including landing site geologic conformations\findex{geologic conformations}, sudden wind gusts\findex{wind gusts}, and others, presenting thus high energy variability. We measured an average of 28 and 60 seconds for take-off and landing, whereas the cruise depends on the size of the polygon to cover (containing the agricultural field).

\subsubsection{Computations energy evaluation}

The computation energy model in terms of battery SoC for {\small\tt darknet-gpu} and {\small\tt blowfish} varying parameters $c_{i,1},c_{i,2}$ is in \fref{fig:soc-plot}{Figure}. 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize
  \begin{subfigure}[t]{0.31\textwidth}
    \centering
    \input{figures/soc-configuration.tikz}
    \caption{Static schedule}
    \label{fig:soc-configuration}
  \end{subfigure}
  \begin{subfigure}[t]{0.26\textwidth}
    \centering
    \input{figures/soc-schedule.tikz}
    \caption{SoC-aware schedule}
    \label{fig:soc-schedule}
  \end{subfigure}
  \begin{subfigure}[t]{0.41\textwidth}
    \centering
    \input{figures/soc-plot.tikz}
    \caption{SoC in the function of parameters}
    \label{fig:soc-plot}
  \end{subfigure}
  \caption[The effect of different schedules on the battery SoC]{The effect of different schedules on the battery SoC. The figure appeared in our early study~\citep{seewald2020mechanical}.}
  \label{fig:soc-evolution}
\end{figure}
The figure shows the energy impact: the higher the key size and FPS rate, the larger the impact on the battery. In \frefm{fig:soc-configuration}{fig:soc-schedule}{Figures}, we show the remaining battery after flying with different schedules. Particularly, \fref{fig:soc-configuration}{Figure} illustrates various static schedules: \sref{lab:sched-a}{} indicates the impact on the battery of merely flying the regressions from \frefm{fig:takeoff-energy}{fig:landing-energy}{Figures}, i.e., the energy impact of the motion on the battery; \sref{lab:sched-b}{} a static schedule of flying the configuration 5.8 FPS, and 32 bits (relative to $c_{i,1},c_{i,2},\forall i\in[l]$ with a fixed number of stages $l$); \sref{lab:sched-c}{} also a static schedule with 10 FPS and 240 bits; and finally \sref{lab:sched-d}{} with 32 FPS and 448 bits.

\fref{fig:soc-schedule}{Figure} shows dynamic schedules. \sref{lab:sched-I}{} has a configuration of 5.8 FPS and 32 bits at take-off and landing, of 32 FPS and 448 bits for the duration of two minutes in the middle of the cruise, and of 5.8 FPS and 32 bits otherwise, resulting in 2.05\% remaining battery SoC at the end of the flight. \sref{lab:sched-II}{} has the same configuration as \fref{lab:sched-I}{} only for the two minutes in the middle of the cruise, and 5.8 FPS and 32 bits otherwise, resulting in 7.86\% remaining SoC~\citep{seewald2020mechanical}. In both cases, we show that the dynamic scheduling allows completing the flight while draining the battery optimally w.r.t. the current battery SoC.

\subsection{Differential modeling case study}
\label{sec:res-diff}

The second case study is the same aerial robot and agricultural use case from \fref{sec:res-perio}{Section}, but now exploiting the model in \frefeq{eq:state-perf} along with different computing hardware and computations.

\subsubsection*{Experimental setup}

The aerial robot is the Opterra fixed-wing for CPP in an agricultural use case equipped with the Paparazzi flight controller. The computing hardware is now the NVIDIA Jetson Nano\findex{NVIDIA Jetson!Nano}, implementing the computations with the ROS middleware. In this case study, we evaluated some initial experiments of the differential model in \frefeq{eq:state-perf} in \fref{sec:deriv}{Section}, opposed to the model in \frefeq{eq:fourier}. Here, we did not consider the energy-aware coverage planning and various power-saving schedules (empirically demonstrated in the next section) but instead evaluated the initial feasibility of the differential periodic model.

The computing hardware implements three computations. The first two are the {\small\tt ssd-mobilenet} computation SSD-MobileNet V2 convolutional neural network (\Gls{acr:cnn})\findex{convolutional neural network}\findex{SSD-MobileNet V2}\findex{computations!ssd-mobilenet@\texttt{ssd-mobilenet}}~\citep{sandler2018mobilenetv2} and the {\small\tt pednet} computation PedNet fully convolutional network (\Gls{acr:fcn})\findex{fully convolutional network}\findex{computations!pednet@\texttt{pednet}}\findex{PedNet}~\citep{ullah2018pednet}. The third computation is termed {\small\tt sender}. It sends the eventual detections on the ground using the technical standard for wireless communication IEEE 802.11\findex{IEEE 802.11}~\citep{crow1997ieee}. Alike the previous section, the computations and motion energy models are combined without needing to test the two together, simplifying the modeling effort. 

\subsubsection*{Motion energy evaluation}

The coverage path is to be seen in \fref{fig:cruise-path}{Figure}; the aerial robot flies the same static CPP with the Zamboni-like motion in \fref{sec:cov-motion}{Section}, implemented in the Paparazzi flight controller from the previous section. 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize
  \begin{subfigure}[c]{0.475\textwidth}
    \centering
    \input{figures/cruise-path.tikz}
    \caption{3D path}
    \label{fig:cruise-path}
  \end{subfigure}
  \begin{subfigure}[c]{0.475\textwidth}
    \centering
    \input{figures/cruise-xy.tikz}
    \vspace*{1.1ex}
    \caption{2D path with altitude zero}
    \label{fig:cruise-xy}
  \end{subfigure}
  \caption[Paths for the cruise phase]{Paths for the cruise phase in the second case study with the Opterra fixed-wing aerial robot flying the Zamboni-like motion.}
  \label{fig:cruise-prelim}
\end{figure}
\fref{fig:cruise-xy}{Figure} is then the path from above. There is a slight deviation mostly on the $x$-axis, attributable to the atmospheric conditions~\citep{seewald2020mechanical}. Initially, we counted the period approximately at one-fourth of the one we defined in \fref{sec:plan}{Section} (begin and end of go-to-waypoint in \fref{fig:cruise-prelim}{Figure}), supposing this would be optimal to model the periodicity of the energy signal. We later corrected this assumption to flying $\varphi_{i},\varphi_{i+1},\varphi_{i+2},\varphi_{i+3}\,\forall i\in[\lceil l/4\rceil]$ with $l$ a given number of stages (we see the results of the latter case in the next section). 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize
  \begin{subfigure}[c]{0.43\textwidth}
    \centering
    \input{figures/cruise-energy.tikz}
    \caption{Modeled motion energy}
    \label{fig:cruise-energy}
  \end{subfigure}
  \begin{subfigure}[c]{0.45\textwidth}
    \centering
    \input{figures/merge.tikz}
    \caption{Coupled motion and computations energy}
    \label{fig:cruise-merge}
  \end{subfigure}
  \caption[Modeled energy evolution with the differential model]{Modeled energy evolution with the differential model of the second case study, corresponding to the cruise path in \fref{fig:cruise-prelim}{Figure}.}
  \label{fig:cruise-energies}
\end{figure}
The overall energy assessment for what concerns the motion is then in \fref{fig:cruise-energy}{Figure}, and for the motion and computations energies in \fref{fig:cruise-merge}{Figure}. For the latter, our early model consisted of an expression similar to \frefeq{eq:state-perf}, but for the components $A_j$ of matrix $A$
\begin{equation}\label{eq:alter-aj}
  A_j:=\begin{bmatrix}0 & 1 \\ -j^2\omega^2 & 0\end{bmatrix},
\end{equation}
where $\omega$ is the same as in \frefeq{eq:fourier}. We note that the expression derived from using $A_j$ in \frefeq{eq:alter-aj} is equivalent to \frefeq{eq:aj} for periodic modeling purposes (the equivalence comes from the proof of \fref{lem:eqv}{Lemma}, where we evaluate the determinant of $A_j$ in \frefeq{eq:det-aj} and thus multiply the first row and second column with the second row and first column with the negative unit, i.e., $j^2\omega^2=j\omega j\omega$). In the model, we then used the coefficients of the Fourier series as an initial guess for the state $\mathbf{q}(t_0)$ at a given time instant $t_0$. We derived the coefficient via the analysis from \fref{sec:res-perio}{Section}. For modeling purposes, we limited the actual flying time of the cruise phase in \fref{fig:cruise-prelim}{Figure} to five minutes. The model output from the initial guess is then the gray area, whereas the energy data are the black-solid line. 

\subsubsection*{Computations energy evaluation}

For the computations {\small\tt ssd-mobilenet} and {\small\tt pednet}, the parameter $c_{i,1}$ alters the hazard detection rate from two to ten frames per second (enclosed in the constraint set $\mathcal{S}_{i,1}$). These numbers are evaluated empirically to match our detection criteria, as opposed to the computation {\small\tt darknet-gpu}, where we analyzed all the possible detection rates on the NVIDIA Jetson TX2 computing hardware. The computation {\small\tt sender} can be then altered with the parameter $c_{i,2}$ indicating the frequency at which the detections are sent to the ground (from two to ten hertz enclosing the constraint set $\mathcal{S}_{i,2}$). All the computations are wrapped in ROS nodes, meaning that $c_{i,1}$ and $c_{i,2}$ can be changed or analyzed by subscribing to appropriate ROS topics\findex{ROS!topic}. The predictive layers in terms of battery SoC are in \fref{fig:mobilenet}{Figure} for the {\small\tt ssd-mobilenet} computation, and in \fref{fig:pednet}{Figure} for the {\small\tt pednet} computation (both the layers vary then the frequency $c_{i,2}$ for the {\small\tt sender} computation). We use the colors here to underline the energy impact of some configurations, otherwise not visible in grayscale.

\begin{figure}[t!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \begin{subfigure}[b]{0.33\textwidth}
    \centering
    \input{figures/max-qos.tikz}
    \caption{Schedule over time}
    \label{fig:max-qos}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\textwidth}
    \centering
    \input{figures/computational-mobilenet.tikz}
    \caption{{\tt\small sender},{\tt\small ssd-mobilenet}}
    \label{fig:mobilenet}
  \end{subfigure}
  \begin{subfigure}[b]{0.32\textwidth}
    \centering
    \input{figures/computational-pednet.tikz}
    \caption{{\tt\small sender},{\tt\small pednet}}
    \label{fig:pednet}
  \end{subfigure}
  \caption[Computations energy models in term of SoC, schedules over time]{Computations energy models in term of SoC as well as the schedule over time for the second case study.}
  \label{fig:computational}
\end{figure}

We used the computations energy model further along with the motion energy model to evaluate the maximum allowed configuration as a function of time against the overall energy budget and the battery SoC in \fref{fig:max-qos}{Figure}. The figure shows the trajectory of the configuration of the detection rate for the PedNet FCN in order to complete the flight. We have further observed the cost of ROS bag\findex{ROS!bag} recording; it is approximately 0.2 watts.
The overall energy assessment for the flight is then in \fref{fig:cruise-merge}{Figure}, coupling the motion and computations energies--the black line in the figure. The output constraint $\mathcal{Y}(t)$ from \fref{def:const}{Definition} is how much energy is available from the battery in the function of time--the gray area in the figure. The schedule consists of $c_{i,1},c_{i,2}$: 
\begin{enumerate*}[label={(\alph*)},font={\textit}]
  \item two FPS and ten hertz for the first two minutes (eventual cached images from the previous cruise are sent to the ground, as the frequency is greater than the FPS rate),
  \item ten FPS and two hertz from the second minute to third,
  \item ten FPS and eight hertz from the third minute to fourth, 
  \item and two FPS and ten hertz from the fourth minute to fifth.
\end{enumerate*}


\subsection{Assessment}

We discussed two case studies of the aerial robot flying a static coverage without replanning. We propose computations models corresponding to the agricultural use case for detections and ground communication, reporting their energy efficiency in terms of power and battery SoC. The first case study exploits the model in \frefeq{eq:fourier} to approximate the energy of different flight phases, motivating the periodic analysis.  The second case study then proposes initial experiments of the differential periodic energy model in \frefeq{eq:state-perf} with some additional computations implemented in the ROS middleware we use in the remainder. We expand the model using variations of paths and computations with replanning in the next section.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coverage Planning and Scheduling}
\label{sec:res-dyn}

In this section, we report the results for energy-aware coverage planning and scheduling; and thus prove our approach experimentally. We extensively use the constructs from the previous chapters, including the energy models in \fref{cp:model}{Chapter}, the guidance, coverage, and replanning from \fref{cp:dyn}{Chapter}, and demonstrate both the solutions to \frefm{pb}{pb:cov-pb}{Problems} from \fref{cp:pb}{Chapter}. Indeed, in the previous sections, we justified the various energy models and discussed merely the solution to \fref{pb:cov-pb}{Problem} with the Zamboni-like motion. 

In \fref{sec:res-num-simu}{Section}, we provide results for numerical simulations derived with \matlab{}. In \fref{sec:res-papa}{Section}, we integrate such simulations with the popular Paparazzi flight controller~\citep{papa}, and finally, in \fref{sec:res-obsta}{Section}, we extend the previous results to the case of avoiding the computations over the no-interest zones (\Gls{acr:niz}s) and out of the polygon\findex{no-interest zones}.

\subsection{Numerical simulations}
\label{sec:res-num-simu}

The first results report is that of a realistic simulation implemented in \matlab{} relative to our forthcoming work~\citep{seewald202Xenergy}, where we implement the craft's flight dynamics. It involves the Opterra fixed-wing aerial robot in the precision agriculture use case we introduced in \fref{cp:intro}{Chapter}. It does both the CPP and scheduling and online in-flight replanning energy-wise. The agricultural field is delimited by vertices $v$ and forms $\mathcal{Q}^v$ (see \fref{sec:cell-deco}{Section} for the notation). There are no NIZs, i.e., $\mathcal{Q}^v=\mathcal{Q}$.

\subsubsection*{Experimental setup}

The aerial robot in this result is the simulated Opterra fixed-wing for CPP in an agricultural use case, independent of the specific flight controller. 
\begin{figure}[t!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/trajs_revised.tikz}
  \caption[Numerical simulations of the trajectory with static and dynamic plans]{Trajectory simulations with variations of wind speed and direction. In \sref{lab:trajs-I-static}{} and \sref{lab:trajs-II-static}{} plan is static. It is replanned online with the algorithm in \sref{lab:trajs-dyn-i}{} and \sref{lab:trajs-dyn-ii}{}. The algorithm adapts the path parameter relative to $r_2$ $c_{i,1}$ and computation parameter FPS rate $c_{i,2}$. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:trajs-revised}
\end{figure}
In the remainder, we discuss two sub-results, each with different atmospheric conditions, \sref{lab:trajs-I-static}{} and \sref{lab:trajs-II-static}{}, in \fref{fig:trajs-revised}{Figure}. Path-wise, we replan the coverage embedding a parameter $c_{i,1}$ (same for all the stages) relative to the radius of the fourth circle $\varphi_{i+3}$ in a set of four primitive paths $\varphi_{i},\dots,\varphi_{i+3}\,\forall i\in[\lfloor l/4 \rfloor]$ iterated over time up to reaching a final point $\mathbf{p}_{\Gamma_l}$ that we proposed in \fref{sec:path-wise}{Section}. The parameter influences the radius $r_2$ of the circle $\varphi_{i+3}$ in \frefeq{eq:radius-dynamic}; we discussed further the precise meaning of how such parameter affects the quality of the coverage in \fref{sec:mpc}{Section}. The result \sref{lab:trajs-I-static}{} is that of the aerial robot flying with a constant wind speed of 5 meters per second, the wind direction of 0 degrees, and an initial path parameter $c_{i,1}$ value of 0. Result \sref{lab:trajs-II-static}{} is flying under the same conditions but a wind direction of 90 degrees and the initial path parameter value of -1000. We simulate sudden battery drops in \sref{lab:trajs-I-static}{}, expecting the replanning to occur with both scheduling and coverage shortening (i.e., lesser quality of the coverage) and an ideal battery behavior in \sref{lab:trajs-II-static}{}, expecting scheduling and coverage largening (i.e., higher quality of the coverage).

Identically to the two case studies from the previous section, the simulation is extended with computing hardware: NVIDIA Jetson Nano, which runs ROS middleware. The computing hardware implements two computations via ROS nodes\findex{ROS!node}: the {\small\tt pednet} computation detects hazards using PedNet FCN~\citep{ullah2018pednet} and can be scheduled with parameter $c_{i,2}$ the detection rate in FPS. The {\small\tt sender} computation communicates to a ground station and can be scheduled with parameter $c_{i,3}$ the sending frequency in hertz\findex{hertz}. Both are similar to the case study in \fref{sec:res-diff}{Section}, and here we further demonstrate the in-flight replanning and scheduling. For the computations, we expect the scheduler to schedule the computations to respect the output constraint set in \fref{def:const}{Definition} (i.e., the maximum battery instantaneous power).

For battery modeling, the internal battery voltage $V$ is 14.8 volts, internal resistance $R_r$ of 1.2 milliohms, stabilized voltage $V_s$ of twelve volts, and battery capacity $Q_c$ of 3.2 amperes per hour in \frefeqM{eq:socevol}{eq:internal_curr} in \fref{sec:batmod-circuit}{Section}. Finally, the battery coefficient $k_b$ in \frefeq{eq:bat} is set to 1.83/1000 and determined experimentally. The model's parameter $r$ in \frefeq{eq:state-perf} is equal to three. We motivate such a choice with the spectral analysis in \fref{fig:spectrum-1}{Figure}, showing that three frequencies are adequate to model the energy signal.

\subsubsection*{Planning evaluation}

We show the effects of different conditions on the CPP in \fref{fig:trajs-revised}{Figure}. Both trajectories \sref{lab:trajs-I-static}{} and \sref{lab:trajs-II-static}{} are flying the same plan for the coverage with the Zamboni-like motion but with different initial parameters values, the highest configuration $\overline{c}_{i,1}$ and the lowest configuration $\underline{c}_{i,1}$, along slightly different atmospheric conditions. 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/ener_revised.tikz}
  \caption[Numerical simulations of the energy models with static and dynamic plans]{Energy models of the trajectories from~\fref{fig:trajs-revised}{Figure} for 200 seconds against the simulated data (\sref{lab:ener-static-I}{} and \sref{lab:ener-static-II}{}). Below are the energy evolutions with replanning (\sref{lab:ener-dyn-i}{} and \sref{lab:ener-dyn-ii}{}). Here, the algorithm replans the plan when the final time and battery time do not match and the computation as the battery is discharging. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:ener-revised}
\end{figure}
The energy models of these two trajectories are the top two sub-figures \sref{lab:ener-static-I}{} and \sref{lab:ener-static-II}{} in \fref{fig:ener-revised}{Figure}. The simulated energy data are in black the model evolution is in red. The model evolves for two hundred seconds with no information about the true energy: it is estimated earlier with the Kalman filter\findex{Kalman filter} on \frefm{algo:repla:sysevo}{algo:repla:endkalmy}{Lines} in \fref{algo:repla}{Algorithm}, whereas now it merely evolves without further estimation on \fref{algo:repla:sysevobatt}{Line}. The figure proves the model accuracy experimentally, i.e., the red line copies the periodic evolution of the energy signal.

The components of the energy model from \fref{sec:deriv}{Section} are illustrated in \fref{fig:evols-revised}{Figure}. 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/evols_revised.tikz}
  \caption[Energy and period estimations and evolution of the state]{Energy estimation for the first 6 seconds on the left side, the evolution of the state $\mathbf{q}$ on the right. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:evols-revised}
\end{figure}
Left sub-figures are the initial slices of the models and period estimation (see \fref{def:period}{Definition}). On the right of \fref{fig:evols-revised}{Figure}, we show the states $\alpha_0,...,\beta_3$ evolutions in time of \sref{lab:ener-static-I}{} in \fref{fig:ener-revised}{Figure}, concluding that approximately two periods are sufficient to obtain consistent state estimates. With non-periodic signals, we observed that the estimator on \frefm{algo:repla:sysevo}{algo:repla:endkalmy}{Lines} in \fref{algo:repla}{Algorithm} estimates primarily the first state $\alpha_0$ and it neglects the others. It hence approximates the non-periodicity with a linear model.

\subsubsection*{Replanning evaluation}

The practical implementation is based on observations of different variations of paths and computations. A variation of path alters the overall flying time, which we reflect in the factors $\nu_{i,1},\tau_{i,1}$ from \frefeq{eq:scale-traj}. We compare the remaining flight time with the time needed to completely deplete the battery from \frefeq{eq:bat} on \frefm{algo:repla:initbat}{algo:repla:endbat}{Lines} in \fref{algo:repla}{Algorithm} and reduce or increase the parameter to optimize the battery time. The path parameter $c_{i,1}$ is equal for all the stages. It changes the radius of the last circle in the current period and therefore shifts the other paths accordingly. The change is in \fref{fig:zambo-repla_pb}{Figure}, resulting in a shorter distance between the coverage lines in the Zamboni-like motion (and in an increment or reduction of the flying time). The path constraint set is set to $\underline{c}_{i,1}=$ -1000 and $\overline{c}_{i,1}=$ zero (enclosing $\mathcal{C}_{i,1}$), equal for all the stages.

A variation of computations directly affects the power. We thus select the highest computation which satisfies the constraints in \fref{def:const}{Definition} on \fref{algo:repla:mpc}{Line} in \fref{algo:repla}{Algorithm}, using model predictive control (\Gls{acr:mpc})\findex{model predictive control}. We observed a low effect on the power of the communication ROS node (see \fref{fig:pednet}{Figure}); we thus used a static frequency of ten hertz for the parameter $c_{i,3}$. Nevertheless, the detection node varies between approximately 5 and 10 watts for the lowest and highest FPS rate. We implemented the FPS rate parameter $c_{i,2}$ with factors  $\nu_{i,2},\tau_{i,2}$ mapping $c_{i,2}$ to the data from \powprof{} as we described in \frefeq{eq:scale-comp} in \fref{sec:merging}{Section}. The computation constraint set is set to $\underline{c}_{i,2}=$ two and $\overline{c}_{i,2}=$ ten (enclosing $\mathcal{S}_{i,1}$), equal for all the stages.

\subsubsection*{Coverage planning and scheduling}

We have tested the validity of our approach via a numerical simulation implemented in \matlab{}, showing the replanning in \fref{fig:trajs-revised}{Figure} in \sref{lab:trajs-dyn-i}{} and \sref{lab:trajs-dyn-ii}{} path-wise and in \fref{fig:ener-revised}{Figure} in \sref{lab:ener-dyn-i}{} and \sref{lab:ener-dyn-ii}{} energy-wise. For the first sub-result \sref{lab:trajs-I-static}{}, the plan starts at the highest configuration of parameters. We simulated two unexpected battery drops at approximately one minute and a half and four minutes and a half. The algorithm optimizes the path (downward facing arrows in \fref{fig:ener-revised}{Figure}) in the proximity of the drops to ensure that the flight is completed. Moreover, it maximizes the parameter $c_{i,2}$ when the battery is discharging (green line), respecting the output constraint in \fref{def:const}{Definition}. We simulated the opposite scenario for sub-result \sref{lab:trajs-II-static}{}. The plan starts at the lowest configuration of parameters while the battery behaves ideally. We note that the path parameter increases when the algorithm estimates enough data (two periods $T$). The algorithm further optimizes the computation parameter w.r.t. to the battery discharge rate. For both cases, we used discrete reductions $\delta$ of five hundred and two for $c_{i,1}$ and $c_{i,2}$ respectively, and the horizon $N$ equal to six seconds (per the values in the literature, see \fref{sec:algo}{Section}). We observed a slight increment in overall replanning time (order of seconds) by using a horizon of ten seconds--attributable to the MPC component on \fref{algo:repla:mpc}{Line} of \fref{algo:repla}{Algorithm}--but did not detect a notable increment in precision. 


\subsection{Paparazzi flight controller}
\label{sec:res-papa}

This section extends the previous, describing the experimental setup and the result for the implementation of our approach in the New Paparazzi Simulator (\Gls{acr:nps})\findex{new paparazzi simulator}, an advanced simulator with sensors models along with JSBSim~\citep{berndt2004jsbsim}\findex{JSBSim}, an open-source flight dynamics model (\Gls{acr:fdm})\findex{flight dynamics model}~\citep{papanps}. It is also relative to our forthcoming work~\citep{seewald202Xenergy}. It involves the simulated craft in CPP and hazards detection from the previous section under more diverse battery conditions, with a further complication of asynchronous communication between the planner-scheduler and the flight controller. Again, there are no NIZs $\mathcal{Q}^v=\mathcal{Q}$.

\begin{figure}[p!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/trajs_pprz2.tikz}
  \caption[Trajectories of flights under various conditions and initial configurations in NPS]{Trajectories of flights under various conditions and initial configurations implemented in NPS. The first cluster of flights \sref{lab:trajs-pprz-i}{--}\sref{lab:trajs-pprz-iv}{} starts with the highest configuration of parameters, the second cluster \sref{lab:trajs-pprz-v}{--}\sref{lab:trajs-pprz-viii}{} with the lowest. Different battery conditions apply to each flight resulting in different replannings. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:trajs-pprz}
\end{figure}

\subsubsection*{Experimental setup}

The polygon $v$ is described by the set of vertices
\begin{equation}
  v_1:=(5,139.5),\,v_2:=(384.4,162.4),\,v_3:=(384.4,32.4),\,v_4:=(5,9.5),
\end{equation}
and is regular. 
On the contrary to the previous result, the outcome depends on the specific flight controller, meaning we simulate the actual interactions between the Paparazzi flight controller~\citep{papa} and the computing hardware on-board the aerial robot in simulated flights using the NPS with JSBSim. 
\begin{figure}[h!]
  \centering
  \includegraphics[width=.7\textwidth]{pictures/paparazzi}
  \caption[NPS with the simulator flying the coverage planning and energy-aware replanning]{NPS interface with the simulator flying the coverage planning and energy-aware replanning, implementing the JSBSim flight dynamics model.}   
  \label{fig:pprz-screen}
\end{figure}
We implement planning-scheduling in Python open source programming language and the communication between NPS and planner-scheduler with a software bus termed Ivy~\citep{ivybus}. The resulting NPS graphical user interface for one of the flights is in \fref{fig:pprz-screen}{Figure}. The path and computations are analogous to these that we proposed in the previous result in \fref{sec:res-num-simu}{Section}. The battery model parameters, the constraint sets $\mathcal{C}_{i,1}$ and $\mathcal{S}_{i,2}$, and the factors $\nu_1,\nu_2,\tau_1,\tau_2$ all have the same values in these two results. We replan the coverage with varying parameter $c_{i,1}$ that alters the distance between the survey lines and schedule the computations with the parameter $c_{i,2}$ relative to the FPS rate of the {\small\tt pednet} computation. As in the previous result, we keep the parameter $c_{i,3}$, the communication frequency of the {\small\tt sender} computation, static, motivated by the early results showing low energy effect of different schedules (see \fref{fig:pednet}{Figure}). The two computations run on the NVIDIA Jetson Nano computing hardware using ROS middleware. We recall that the schedule for $c_{i,2}$ is varied via a ROS topic\findex{ROS!topic}, whereas the computations are ROS nodes\findex{ROS!node}, one implementing PedNet FCN\findex{PedNet}~\citep{ullah2018pednet}, the other simply communicating with the ground.

\subsubsection*{Planning evaluation}

We performed eight test flights in two clusters. The trajectories of these flights are in \fref{fig:trajs-pprz}{Figure}. 
\begin{figure}[h!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/ctls_pprz2.tikz}
  \caption[Evolution of the parameters configurations in NPS]{Evolution of the parameters configurations for two clusters of flights implemented in NPS. Each cluster has a similar overall flight time due to the initial conditions. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:ctls-pprz}
\end{figure}
A first cluster \sref{lab:trajs-pprz-i}{--}\sref{lab:trajs-pprz-iv}{} compromises flights starting with the highest configurations of parameter $c_{i,1}=\overline{c}_{i,1}$ and $c_{i,2}=\overline{c}_{i,2}$, requiring then replanning due to various simulated battery profiles. A second cluster \sref{lab:trajs-pprz-v}{--}\sref{lab:trajs-pprz-viii}{} starts on the contrary with the lowest configuration of $c_{i,1}=\underline{c}_{i,1}$ and $c_{i,2}=\underline{c}_{i,2}$. The evolution of the parameters is then in \fref{fig:ctls-pprz}{Figure}. For coverage planning, we further observe some unexpected flight patterns in \sref{lab:trajs-pprz-ii}, \sref{lab:trajs-pprz-v}{--}\sref{lab:trajs-pprz-vii}{}, which are, in part, caused by the delay between the flight controller and planner-scheduler. Indeed these often happen when the planner-scheduler evaluates the final battery time $t_b$ on \frefm{algo:repla:initbat}{algo:repla:endbat}{Lines} in \fref{algo:repla}{Algorithm}, being these lines computationally expensive. Nonetheless, we observe a minor incidence in a multi-thread implementation, with each computationally expensive block (i.e., MPC\findex{model predictive control} on \fref{algo:repla:mpc}{Line} and battery estimator on \frefm{algo:repla:initbat}{algo:repla:endbat}{Lines}) computing in a separate thread, compared to simple sequential execution.

Although the flights in the previous section are similar, in \fref{fig:trajs-revised}{Figure}, the reference frame $\mathcal{O}_W$ is different along with the flight time. The former is due to different initial conditions. Although we generated the same coverage, $\mathbf{p}(t_0)$ are different: practically, we shift the paths that form the plan. The latter is due to the different velocities of the craft. Indeed we solely rely on the values from FDM rather than our implementation of the dynamics.

\begin{figure}[p!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/ener_pprz.tikz}
  \caption[Energy models for the flights implemented in NPS]{Energy models for the flights implemented in NPS with different initial and simulated battery conditions. The green line indicates the output constraint. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:ener-pprz}
\end{figure}

\subsubsection*{Replanning evaluation}

All the flights start with a charged battery but have different battery evolutions and initial conditions. For the first cluster of flights, flight \sref{lab:ctls-pprz-i}{} starts with the highest configuration of $c_{i,1}$ and $c_{i,2}$, and the battery behaves linearly up to 90\%. At approx. 95 seconds we simulate a sudden battery drop of 4\%. The battery then again behaves linearly, and the final battery state is approx. 57\%. The parameter $c_{i,1}$ is thus replanned by \fref{algo:repla}{Algorithm} in the proximity of the drop and the computation parameter $c_{i,2}$ is scheduled to respect the output constraint in \fref{def:const}{Definition} visible in \fref{fig:ener-pprz}{Figure} (the green line indicates the constraint). Flight \sref{lab:ctls-pprz-ii}{} is similar, but the battery drop happens at approx. 122 seconds. The evolution of the parameter $c_{i,1}$ is indeed mostly the same, whereas the parameter $c_{i,2}$ is replanned with a higher schedule. Flight \sref{lab:ctls-pprz-iii}{} has eventual additional uncertainty due to the communication lag between the flight controller and the planner-scheduler. We can see that indeed \sref{lab:ctls-pprz-ii}{--}\sref{lab:ctls-pprz-iii}{} are very similar, conversely to flight \sref{lab:ctls-pprz-iv}, where the battery drop happens at approx. 163 seconds.

The second cluster of flights exhibits the same tendency for flights \sref{lab:ctls-pprz-v}{--}\sref{lab:ctls-pprz-vi}{} and, indeed, the energy in \fref{fig:ener-pprz}{Figure}, the configurations in \fref{fig:ctls-pprz}{Figure}, and the trajectories in \fref{fig:trajs-pprz}{Figure} are almost identical. There are no simulated sudden battery drops and enough battery SoC to respect the output constraint in \fref{def:const}{Definition}. Flights \sref{lab:ctls-pprz-vii}{--}\sref{lab:ctls-pprz-viii}{} are similar to the previous couple, except for a more steep simulated battery evolution, lower of approx. 4\%. There is then a simulated 2\% points battery difference at the end of the flight between \sref{lab:ctls-pprz-vii}{} and \sref{lab:ctls-pprz-viii}{}, requiring additional replanning.

\subsubsection*{Coverage planning and scheduling}

We have further validated our approach utilizing NPS with JSBSim as FDM. We simulated various battery evolutions and drops, corresponding to, e.g., imperfect batteries of fixed-wing aerial robots operating in real-world conditions. We have simulated the interaction between the flight controller and the planner-scheduler, interconnecting the two via Ivy bus, showing possible complications such as delays. We will discuss future possibilities of additional optimizations to reduce such delays in \fref{cp:conc}{Chapter}. In this result, we use a lower reduction $\delta$ for the path parameter of two hundred fifty, with no notable difference in path replanning. We thus conclude that $\delta$ of five hundred from \fref{sec:res-num-simu}{Section} is adequate for path replanning. Conversely to the previous result, we use a fixed horizon $N$ of ten seconds (see \fref{sec:algo}{Section}).

\subsection{Coverage with no-interest zones}
\label{sec:res-obsta}

In this final result, we complement our approach, interrupting the computations over a NIZ on the ground as we hypothesized in \fref{pb:cov-pb}{Problem} and \fref{sec:cov-path-plan}{Section}, and additionally out of the polygon $v$, thus computing only within the space $\mathcal{Q}^v$. The result is relative to our forthcoming work~\citep{seewald202Xenergy}. The NIZ resulting polygon $o_1$ mimics conveniently the shape and location in \frefm{fig:gride}{fig:zambo2}{Figures} in Sections \frefm{sec:cov-path-plan}{sec:mpc}{Sections}, whereas $v$ is the same as in \fref{sec:res-papa}{Section}. The polygon $o_1$, representing the NIZ\findex{no-interest zones}, has six vertices
\begin{equation}\begin{split}
  o_{1,1}&:=(110,85),\,\,\,\,\,\,o_{1,2}:=(125,106.5),\,o_{1,3}:=(155,114.5),\\
  o_{1,4}&:=(195,93.5),\,o_{1,5}:=(175,76.5),\,\,\,\,o_{1,6}:=(137,57.7),
\end{split}\end{equation}
and the resulting trajectory of the aerial robot flying the coverage while avoiding the computations over NIZ and out of the polygon is in \fref{fig:trajs-niz}{Figure}.
To simulate the energy effect of the configuration $c_{i,2}=\{0\}$, we evaluated the average power of the NVIDIA Jetson Nano\findex{NVIDIA Jetson!Nano} computing hardware with the \powprof{} tool, solely running ROS core\findex{ROS!core} with the remaining computations ({\small\tt pednet}, {\small\tt sender}) switched off. The rest of the experimental setup is shared with \fref{sec:res-papa}{Section}, and the resulting initial and battery conditions are these of flight \sref{lab:trajs-pprz-ii}{} in the first cluster in \fref{fig:trajs-pprz}{Figure}, i.e., the highest configuration of $c_{i,1}$ and $c_{i,2}$ with the simulated battery behaving ideally but for a drop at approx. 122 seconds.

\begin{figure}[p!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/trajs_niz.tikz}
  \caption[The trajectory effect of inhibiting computations over NIZ and out of the polygon]{Trajectories of two flights flying the same condition as \sref{lab:trajs-pprz-ii}{} in \fref{fig:trajs-pprz}{Figure} but inhibiting computations over NIZ in \sref{lab:trajs-niz-iia}{}, and over NIZ and out of the polygon $v$ in \sref{lab:trajs-niz-iib}{}. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:trajs-niz}
\end{figure}
\begin{figure}[p!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/ener_niz.tikz}
  \caption[Energy effect of inhibiting computations over NIZ and out of the polygon]{Energy evolution of a schedule that additionally inhibits the computations over NIZ in \sref{lab:ener-niz-iia}{}, and over NIZ and out of the polygon $v$ in \sref{lab:ener-niz-iib}{}. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:ener-niz}
\end{figure}
\begin{figure}[p!]
  \centering
  \fontfamily{phv}\selectfont
  \footnotesize    
  \input{figures/ctls_niz.tikz}
  \caption[Configuration effect of inhibiting computations over NIZ and out of the polygon]{Configurations trajectories of a schedule that additionally inhibits the computations over NIZ in \sref{lab:ctls-niz-iia}{}, and over NIZ and out of the polygon $v$ in \sref{lab:ctls-niz-iib}{}. The figure is to appear in our forthcoming study~\citep{seewald202Xenergy}.}
  \label{fig:ctls-niz}
\end{figure}

The trajectory is indeed similar to \sref{lab:trajs-pprz-ii}{}. Flight \sref{lab:trajs-niz-iia}{} in \fref{fig:trajs-niz}{Figure} is that of the coverage while avoiding computations over $\mathcal{Q}^{o_1}$, whereas flight \sref{lab:trajs-niz-iib}{} avoids the computations everywhere but over $\mathcal{Q}^v$ (i.e., additionally to \sref{lab:trajs-niz-iia}{}, it avoids the computations outside of the polygon $v$). There is an observable difference in the configuration trajectories for the parameter $c_{i,2}$, visible in \fref{fig:ctls-niz}{Figure}. Indeed \sref{lab:ctls-niz-iia}{} in \fref{fig:ctls-niz}{Figure} is similar to \sref{lab:ctls-pprz-ii}{} in \fref{fig:ctls-pprz}{Figure}, but for the instants when the aerial robot flies over the NIZ $o_1$ and the computation parameter is inhibited $c_{i,2}=\{0\}$. The corresponding energy consumption is then in \sref{lab:ener-niz-iia}{} in \fref{fig:ener-niz}{Figure}.

Finally, there is a notable difference between the two sub-results \sref{lab:ctls-niz-iia}{} and \sref{lab:ctls-niz-iib}{} in \frefm{fig:ctls-niz}{fig:ener-niz}{Figures}, contrary to \fref{fig:trajs-niz}{Figure}, showing the energy (and configuration trajectory) effect of avoiding computations everywhere except over $\mathcal{Q}^v$. One can further note the impact of the NIZ polygon $o_1$ shape on the energy and configuration trajectories. Depending on the position in space, it takes longer or shorter to fly over the NIZ due to the different lengths of a line segment parallel to the edge ${}^{v_4}|_{v_1}$ intersecting the NIZ $o_1$ (see \fref{fig:bcd3}{Figure}).


%%%%%%%%%%%%%%%%%
\section{Summary}

This chapter described the experimental setup and results for computations and motion energy and battery models, two case studies of the aerial robot flying a static coverage, and in-flight coverage planning and scheduling. The computations energy models were derived via the \powprof{} modeling tool, reporting the overall energy, average power, and battery SoC per each computations configuration within a bounded search space. The chapter detailed computations energy models for several computations ranging from simple matrix exponentiation to object detection. It then provided two case studies of aerial robots flying physical experiments with a static coverage, showing the periodic energy evolution and motivating the differential periodic energy model from the previous chapters. The guidance, coverage planning, and online replanning were then proposed via numerical simulations with various realistic conditions, showing the energy effect of online replanning from the lowest and the highest initial configurations of the coverage and detections. These results are then further extended to the popular Paparazzi flight controller and various battery conditions and to the case of coverage with NIZs. Here, the aerial robot inhibits the computation when flying over a NIZ of a given size and out of the polygon.

