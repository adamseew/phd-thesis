Energy-Aware Coverage
Planning and Scheduling for
Autonomous Aerial Robots
Adam Seewald

University of Southern Denmark

Energy-Aware Coverage
Planning and Scheduling for
Autonomous Aerial Robots
Adam Seewald

A dissertation submitted in partial satisfaction of the
requirements for the degree Doctor of Philosophy
in Engineering Science

2021

https://adamseewald.cc/short/phdthesis

The typesetting is done using LATEX. Figures are generated with PGF/TikZ. Fonts are EB Garamond,
Helvetica, and Iwona for body, headers, and equations respectively.
Copyright © 2021 by Adam Seewald. Some rights reserved.
This work is subject to CC BY-NC-SA license, which means that you can copy, redistribute, remix, transform, and build upon the content for any non commercial purpose, as long as you give appropriate credit,
provide a link to the license, and indicate if changes were made. If you remix, transform, or build upon
the material, you must distribute your contributions under the same license as the original. License details:
https://creativecommons.org/licenses/by-nc-sa/4.0/

First edition, 2021
Published by University of Southern Denmark, in Odense, Denmark

“[I]t was not possible to run it more than a minute or two at a time. In these short tests
the motor developed about nine horse power. We were then satisﬁed that, with proper
lubrication and better adjustments, a little more power could be expected.”
— O. Wright, 1913

Abstract
This work aims to derive an energy-optimal path and a power-saving schedule for an aerial robot
simultaneously, inflight, and under strict energy constraints. Although energy conservations techniques for mobile robots’ motion planning and the scheduling for heterogeneous computing
hardware carried by these robots have been studied, the close interaction between the two remains mostly unexplored. It is regarded in the available literature that there are classes of mobile
robots where it could be advantageous to trade-off reduced resources for a still acceptable level
of performance.
Within mobile robots, aerial robots are particularly affected by various energy considerations.
Generally, it would be required to land and recharge the battery in case of adverse energy-related
events. Therefore, this work emphasizes aerial robots. It derives planning-scheduling energy
awareness using optimal control techniques, regression analysis, and differential periodic energy
modeling. The future computations energy prediction further derives an automatic profiling
and modeling utility that generates overall energy, average power, and battery state of charge
models in the function of a software configuration, allowing the integration in a data-flow computational network. The work is demonstrated on the problem of planning coverage in an autonomous precision agriculture use case, where a fixed-wing aerial robot flies over an agricultural
field, detects hazards, and communicates the detections with other ground-based actors. The
guidance on the coverage path relies on the theory of vector fields, and the overall approach is
an algorithm that incorporates the battery, motion, and computations energy modeling along
with gradient descent and optimal control.
Planning-scheduling exhibits improved performance mitigating the effect of uncertainty in
battery-powered aerial robots against the baseline of flying full coverage, requiring landing in the
eventuality of sudden battery defect. Although specific, the approach can be generalized. The
computations energy and battery models applied to different domains, whereas the differential
periodic energy model, the guidance, and the overall planning-scheduling approach to a broad
class of potential autonomous mobile robotics use cases.

v

Resumé
Arbejdet i denne afhandling sigter mod at udlede kombinationen af en energioptimal rute og en
strømbesparende eksekveringsplan for en aerorobot (drone), hvis flyvning skal foretages indenfor
et fast energibudget. Der findes allerede teknikker til bevægelsesplanlægning for mobile robotter
samt teknikker til planlægningen af beregninger udført på computerhardware båret af sådanne
robotter, men interaktionen mellem disse to aspekter er stort set uudforsket. Det ses dog ud fra
den tilgængelige litteratur, at der findes bestemte typer af mobile robotter, for hvilke det ville være
fordelagtigt at kunne foretage en afvejning mellem ressourceforbruget ved henholdsvis bevægelse
og beregning, i relation til kvaliteten af det arbejde som robotten udfører.
Aerorobotter er i særligt grad påvirket af behovet for energibesparelse. Det kan være nødvendigt at lande og genoplade batteriet i tilfælde af et uforudset højt strømforbrug. Denne afhandling fokuserer på aerorobotter. Der udledes planlægningsteknikker til energifølsom styring af
aerorobottens bevægelser og beregninger vha. optimal kontrol, regressionsanalyse og differentiel
periodisk energimodellering. Forudsigelse af beregningernes fremtidige energiforbrug foretages
via et automatisk profilerings- og modelleringsværktøj, som modellerer det overordnede energiforbrug, gennemsnitseffekt samt batteriafladningen som funktion af robottens softwarenkonfiguration. Arbejdet demonstreres ved planlægningen af en rute, som dækker et geografisk område,
og er tiltænkt anvendelse indenfor præcisionslandbrug. En fastvinget aerorobot flyver over en
landbrugsmark, gør opmærksom på farer, og kommunikerer disse til andre jordbaserede aktører.
Aerorobottens dækning af området beskrives via vektorfelter, og den overordnede tilgang til
problemets løsning udgøres af en algoritme, der inkorporerer batteri-, bevægelses- og beregningsenergimodellering sammen med gradientnedstigning og optimal kontrol.
Den kombinerede tilgang til planlægning af rute og beregninger viser forbedret ydeevne, der
hjælper til at afbøde effekten af usikkerhed i missioner udført med batteridrevne aerorobotter.
Dette ses i forhold til den traditionelle løsning med en aerorobot, der ikke kan omplanlægge,
og derfor foretager fuld dækning af området, hvilket kan resultere i en nødlanding i tilfælde af
uforudsete hændelser såsom et delvist defekt batteri. Selvom tilgangen er specifik til aerorobotter kan den generaliseres. Energimodellerne for beregninger og batteriforbrug kan anvendes på
forskellige domæner. Den differentielle periodiske energimodel og den overordnede tilgang til
planlægning kan benyttes på tværs af mange forskellige anvendelsesområder indenfor autonome
mobile robotter.
vii

Acknowledgements
I am obliged to my advisor Prof. Ulrik Pagh Schultz for his encouragement, patience, and helpful
discussions. He was always ready with a very thorough list of insightful suggestions and improvements. My gratitude goes also to my co-advisors, Dr. Héctor García de Marina, who proposed
the direction of this work, and Dr. Henrik Skov Midtiby, who shaped the outcomes.
Parts of this work are a result of collaborative efforts. I am indebted to Julius Roeder, Dr.
Benjamin Rouxel, and Dr. Clemens Grelck from the Parallel Computing Systems group at the
University of Amsterdam and to my colleagues, past and present, from the Unmanned Aerial
Systems group at the University of Southern Denmark. I am additionally grateful to TeamPlay
project consortium members for stimulating debates on low power computing during various
occasions.
Finally, I wish to thank my mother and maternal grandparents who were of great support and
indulgence.

ix

Publications
Journal article:
1. Seewald, A., Schultz, U. P., Ebeid, E., and Midtiby, H. S. (2021a). “Coarse-grained computationoriented energy modeling for heterogeneous parallel embedded systems”. In: International
Journal of Parallel Programming 49.2. https : / / adamseewald . cc / short / coarse2019,
pp. 136–157 (cit. on pp. 11, 12, 37, 38, 55, 58, 59, 61, 64, 92, 101–108, 128, 129).

Conference papers in proceedings:
2. Seewald, A., Schultz, U. P., Roeder, J., Rouxel, B., and Grelck, C. (2019). “Component-based
computation-energy modeling for embedded systems”. In: SIGPLAN International Conference
on Systems, Programming, Languages, and Applications: Software for Humanity (SPLASH).
https://adamseewald.cc/short/component2019. ACM, pp. 5–6 (cit. on pp. 11, 12, 59,
106, 109, 129).
3. Seewald, A., García de Marina, H., Midtiby, H. S., and Schultz, U. P. (2020). “Mechanical
and computational energy estimation of a fixed-wing drone”. In: 4th International Conference
on Robotic Computing (IRC). https://adamseewald.cc/short/mechanical2020. IEEE,
pp. 135–142 (cit. on pp. 11, 13, 66, 92, 101, 108–112, 129).
4. Zamanakos, G., Seewald, A., Midtiby, H. S., and Schultz, U. P. (2020). “Energy-aware design of
vision-based autonomous tracking and landing of a UAV”. In: 4th International Conference on
Robotic Computing (IRC). https://adamseewald.cc/short/energy2020. IEEE, pp. 294–
297 (cit. on pp. 9, 11, 12, 59, 92, 107, 129).

Workshop papers (peer-reviewed):
5. Seewald, A., Ebeid, E., and Schultz, U. P. (2019). “Dynamic energy modelling for SoC boards:
Initial experiments”. In: High-Level Programming for Heterogeneous and Hierarchical Parallel
Systems (HLPGPU). https://adamseewald.cc/short/dynamic2019, p. 4 (cit. on pp. 35,
60).
6. Seewald, A. (2020). “Beyond traditional energy planning: The weight of computations in planetary exploration”. In: IROS Workshop on Planetary Exploration Robots: Challenges and Opportunities (PlanRobo). https : / / doi . org / 10 . 3929 / ethz - b - 000450120. ETH Zürich,
Department of Mechanical and Process Engineering, p. 3 (cit. on pp. 11, 13, 129, 130).

xi

xii

Open-source software:
7. Seewald, A., Schultz, U. P., Ebeid, E., and Midtiby, H. S. (Oct. 2021b). powprofiler computations energy modeling tool. https://doi.org/10.5281/zenodo.5562457. Version 1.0.2
(cit. on pp. 11, 12, 59, 128, 129).

In preparation at the time of submission:
8. Seewald, A., García de Marina, H., and Schultz, U. P. (n.d.). Energy-aware dynamic planning algorithm for autonomous UAVs. https://adamseewald.cc/short/energy2021. In
preparation (cit. on pp. 11, 13, 101, 115–120, 122–125, 129).

Contents

1

Introduction
1.1
1.2
1.3

1.4
1.5
1.6
1.7

2

From UAVs to Modern Aerial Robots

. . . . . . . .
. . . . . . . . .
Motivation . . . . . . . . . . . . . . . . . . . . .
1.3.1
Planning-scheduling energy awareness . .
1.3.2
Objective . . . . . . . . . . . . . . . . .
1.3.3
Methodology . . . . . . . . . . . . . . .
Outline of the Approach . . . . . . . . . . . . . .
Applications . . . . . . . . . . . . . . . . . . . .
Contribution . . . . . . . . . . . . . . . . . . . .
Reading Guide . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
2.6.3
Coverage plan with paths and computations sub-plans .
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

Common Classes of Aerial Robots

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

Problem Formulation
2.1
2.2
2.3
2.4
2.5

2.6

2.7

3

1
3
5
8
8
9
10
10
11
12
13
15

Definitions of computations and motion

. . .
Definition of path functions . . . . . . . . .
Definitions of stages and triggering points . .
Definition of plan . . . . . . . . . . . . . .
Problem Statement . . . . . . . . . . . . .
2.5.1
Planning problem . . . . . . . . . .
2.5.2
Coverage problem . . . . . . . . .
Precision agriculture use case . . . . . . . .
2.6.1
Paths sub-plan . . . . . . . . . . .
2.6.2
Computations sub-plan . . . . . . .

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

16
17
18
20
22
23
23
24
24
27
29
30

State of the Art

31

3.1

Computations Energy Modeling

32

3.1.1

33

. . . . . . . . . . . . . . . . . . . . . . . . .
Heterogeneous elements modeling . . . . . . . . . . . . . . . . . . .
xiii

xiv

Contents

3.1.2

GPU features modeling

3.1.3

CPU features modeling

3.2

Battery Modeling

3.3

Planning

3.4

3.3.1

. . . . . . .
. . . . . . . . . . .
Motion planning . . . .

3.3.2

Coverage path planning

3.3.3

Optimal coverage

3.6

4

.
.
.
.
.
.
.

.
.
.
.
.
.
.

Aerial coverage path planning

.
3.4.2
Optimal aerial coverage . . . .
Planning Computations with Motion . .
Summary . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

Energy Models
4.1

Energy Model of the Computations

. . . . . . .
.
4.1.2
Measurement layer . . . . . . . . . . .
4.1.3
Predictive layer . . . . . . . . . . . . .
4.1.4
The powprofiler tool . . . . . . . . .
4.1.5
Configuration specification . . . . . . .
Battery Model . . . . . . . . . . . . . . . . . .
4.2.1
Equivalent electrical circuit . . . . . . .
4.2.2
Battery model in the powprofiler tool .
Energy Model of the Motion . . . . . . . . . . .
4.1.1

4.2

4.3

4.4

5

.
.
.
.
.
.
.

Planning for Autonomous Aerial Robots
3.4.1

3.5

. . .

.
.
.
.
.
.
.

Model for the heterogeneous elements

4.3.1

Derivation of the differential periodic model

4.3.2

Nominal control of the energy signal

.
.
.
.
.
.
.
.
.
.

. . . .
4.3.3
Control scale transformation . . . . . . . .
Summary . . . . . . . . . . . . . . . . . . . . .

5.2

5.3

Guidance on the coverage

37
38
39
40
41
42
44
44
45
47
50
53

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

Coverage Planning and Scheduling
5.1

35

. . . . . . . . . . . . .
5.1.1
Vector fields for guidance . . . . . . . . .
5.1.2
Derivation of a path following vector field . .
Coverage Path Planning . . . . . . . . . . . . . .
5.2.1
Cellular decomposition of the space . . . .
5.2.2
Coverage motion generation . . . . . . .

54
54
57
58
59
61
62
62
65
65
67
72
73
75
77

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
Energy-Aware Coverage Replanning and Scheduling
.
5.3.1
Output model predictive control . . . . . .
.
5.3.2
Re-evaluation of the output constraint . . .
.
5.3.3
Derivation of an optimal control problem . .
.
5.3.4
Coverage replanning and scheduling: Discretization .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

78
78
81
84
85
88
90
91
93
94
96

Contents

xv

5.3.5
5.4

6

. . . . . . . . . . . . . 97
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

Results
6.1

6.2

6.3

6.4

101

Computations Energy Modeling

. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . .
6.1.2
The matrix-gpu computation . . . . . . . . . . . . . . . . . . . .
6.1.3
The darknet/matrix -cpu, nvidia- matrix/quicks computations .
6.1.4
Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Case Studies in Motion Energy Modeling . . . . . . . . . . . . . . . . . . .
6.2.1
Periodic modeling case study . . . . . . . . . . . . . . . . . . . .
6.2.2
Differential modeling case study . . . . . . . . . . . . . . . . . . .
6.2.3
Assessment . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Coverage Planning and Scheduling . . . . . . . . . . . . . . . . . . . . .
6.3.1
Numerical simulations . . . . . . . . . . . . . . . . . . . . . . . .
6.3.2
Paparazzi flight controller . . . . . . . . . . . . . . . . . . . . . .
6.3.3
Coverage with no-interest zones . . . . . . . . . . . . . . . . . . .
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.1.1

7

Coverage replanning and scheduling: Algorithm

Summary

The darknet-gpu computation

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

Summary and Future Directions
7.1

Summary

7.2

Outcomes

7.3
7.4

. . . . . .
. . . . .
Future Directions . .
Conclusion . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

102
102
104
106
107
108
108
111
114
114
115
119
124
126
127

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

127
129
129
131

References

133

Index

155

Figures

Opterra fixed-wing aerial robot for the precision agriculture use case

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
Boustrophedon-like motion to cover a regular polygon with four sides .
Zamboni-like motion to cover a regular polygon with four sides . . . .
Alteration of a path parameter with the Zamboni-like motion . . . . .

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

Hewitt-Sperry Automatic Airplane, the first unmanned flying machine
NASA’s Ingenuity Mars helicopter

. . . . . . . . . . . . . . . . .
Skye, an omnidirectional spherical blimp . . . . . . . . . . . . .
Different aerial robots in relation to the power, flight time, and M&CE
The coverage problem in a precision agriculture use case

. . . . .

Concept of a line as a path function

.
.
.
.
.

. .
Concept of a circle as a path function .
Definition of a plan . . . . . . . . . .
Detail of a stage in the FSM . . . . . .
Definition of a plan with a loop . . . .

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

.
.
.
.
.

Turn optimal coverage with different sweep directions for each sub-region
NVIDIA Jetson Nano heterogeneous computing hardware

. . .
. . . .
ODROID XU3 heterogeneous computing hardware . . . . . .
NVIDIA Jetson TK1 heterogeneous computing hardware . . . .

xvii

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

4
5
6
7
9
17
18
21
22
22
25
26
28

. . . . . . . . .

43

.
.
.
.
.
.
.
.

55

.
.
.
.
Equivalent electrical circuit for battery modeling with an internal resistance
.
Evolution of the current for a given linear load . . . . . . . . . . . . . .
.
Thevenin-based equivalent electrical circuit for battery modeling . . . . .
.
Power evolution data of an aerial robot in coverage planning . . . . . . .
.
Power evolution frequency spectrum of an aerial robot in coverage planning .
Concept of path and computations parameters scale transformations . . . . .
Change in the admissible region . . . . . . . . . . . . . . . . . . . . . .

NVIDIA Jetson TX2 heterogeneous computing hardware

2

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

56
56
60
63
64
65
66
66
73
74

xviii

Direction of the gradient on a circle path function

. . . . . . .
.
Direction of the vector field inside the path function . . . . . .
Direction of the vector field outside and on the path function . .
Path-following vector field of a circle path function . . . . . . .
Grid decomposition . . . . . . . . . . . . . . . . . . . . . .
Initial step of the boustrophedon decomposition . . . . . . . .
Intermediate step of the boustrophedon decomposition . . . .
Trapezoidal decomposition . . . . . . . . . . . . . . . . . .
Result of the boustrophedon decomposition . . . . . . . . . .
Boustrophedon-like motion covering a cell . . . . . . . . . . .
Zamboni-like motion covering a cell . . . . . . . . . . . . . .
Zamboni-like motion with the lowest parameter configuration . .
Gradient descent algorithm illustrated on a circle path function

Figures

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

YOLO DNN library detection computation measurement layer models

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.

80
81
82
83
83
85
85
86
86
87
88
89
93

. . . . . . . . . . . 102
. 103

Per-minute energy consumption and SoC of the YOLO DNN library detection computation

Predictive layers of the matrix exponentiation computation in the function of exponent and size 104
Predictive layers in the function of varying exponent and schedules

. . .
Paths and modeled energy evolutions in time for different flight phases .
The effect of different schedules on the battery SoC . . . . . . . . . .
Paths for the cruise phase . . . . . . . . . . . . . . . . . . . . . .
Modeled energy evolution with the differential model . . . . . . . . . .
Computations energy models in term of SoC, schedules over time . . .
Numerical simulations of the trajectory with static and dynamic plans . .

.
.
.
.
.
.
.

.
.
.
.
.
.
.
Numerical simulations of the energy models with static and dynamic plans .
Energy and period estimations and evolution of the state . . . . . . . . . .

.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
Trajectories of flights under various conditions and initial configurations in NPS .

.
.
.
.
.
.
.
.
.
.

NPS with the simulator flying the coverage planning and energy-aware replanning
Evolution of the parameters configurations in NPS

. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
The trajectory effect of inhibiting computations over NIZ and out of the polygon .
Energy effect of inhibiting computations over NIZ and out of the polygon . . . .
Configuration effect of inhibiting computations over NIZ and out of the polygon .

Energy models for the flights implemented in NPS

.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

105
110
111
112
113
114
116
117
118
120
121
122
123
125
125
125

Notation

∃
∈
∈
/
∀
:=
≈
f( · )
f :C→D
C∩D
C∪D
ẋ
∇
Z
Z≥0
Z>0
R
R≥0
Zm , Rm
Zm×n , Rm×n

∅
C\D
C⊇D
C⊃D
C⊆D
C⊂D

[x]
[x]>0

there exists.
is an element of the set.
is not an element of the set.
for all.
is defined.
approximately equal.
is function f.
f maps set C to set D.
intersection of set C with set D.
union of set C with set D.
continuous time derivative of x.
del operator.
set of integers.
set of positive integers.
set of strictly positive integers.
set of reals.
set of positive reals.
integer- or real-valued vector of m elements.
integer- or real-valued matrix of m rows, n columns, and
mn elements.
empty set.
elements of set C not in set D.
set C is a superset of set D.
set C is a strict superset of set D.
set C is a subset of set D.
set C is a strict subset of set D.
set of positive integers up to x ∈ Z≥0 .
set of strictly positive integers up to x ∈ Z>0 .
xix

xx

Notation

x
X
x0 , X 0
x−1 , X −1
x
xi
xi,j
x i,j
x i,j
|x|
diag(x)
x∗
x̂
bxc
dxe
v1

|v2
max
arg

vector.
matrix.
transpose of a vector x or of a matrix X .
inverse of a vector x or of a matrix X .
euclidean norm of vector x ∈ Rn .
ith set of parameters.
jth parameter of the ith set of parameters.
lower bound of the parameter xi,j .
upper bound of the parameter xi,j .
cardinality of a set x.
square matrix of |x| rows containing values of x on the
diagonal, zeros elsewhere.
optimal with respect to a given cost.
estimate of x.
the floor function or integer division of x ∈ R, if x is a
set, the closest item in the set s.t. x − bxc is positive.
the ceiling function of x ∈ R, if x is a set, the closest item
in the set s.t. x − dxe is negative.
edge connecting vertices v1 and v2 .
maximum.
solution of an optimization.

Abbreviations

BVP
CNN
CPP
CSV
DFS
DNN
DVS
ECM
FCN
FDM
FPS
FSM
GNSS
GPGPU
GPS
IMU
ILP
MAV
MPC
MSE
M&CE
NFZ
NIZ
NLP
NPS
OCP
PMC
QoS

boundary-value problem.
convolutional neural network.
coverage path planning.
comma-separated values.
dynamic frequency scaling.
deep neural network.
dynamic voltage scaling.
equivalent circuit model.
fully convolutional network.
flight dynamics model.
frames per second.
finite state machine.
global navigation satellite system.
general-purpose GPU.
global positioning system.
inertial measurement unit.
integer linear programming.
micro aerial vehicle.
model predictive control.
mean square error.
difference of motion and computations energy.
no-flight zone.
no-interest zone.
non linear program.
new paparazzi simulator.
optimal control problem.
performance monitoring counter.
quality of service.

xxi

xxii

Abbreviations

RL
ROS
RPV
RSTA
SLAM
SoC
UAS
UAV
UGV
VTOL

reinforcement learning.
robot operating system.
remotely piloted vehicle.
reconnaissance, surveillance, and target acquisition.
simultaneous localization and mapping.
state of charge.
unmanned aerial system.
unmanned aerial vehicle.
unmanned ground vehicle.
vertical take-off and landing.

Chapter 1

Introduction
“Fixed-wing [aerial robots] [...] tend to be more stable in the air in the face of both
piloting and technical errors as they have natural gliding capabilities even without
power, and they are able to travel longer distances on less power.”
— X. Wang et al., 2017

o b i l e robots have the ability to move (Corke, 2017) and eventually sense and interact

M with the surrounding environment. They combine and interpret data from multiple components (Mei, Y.-H. Lu, Y. C. Hu, et al., 2006), using various algorithms for perception and planning.
For instance, with a motion planning algorithm, a mobile robot converts a human-level plan with
sensing into machine-level motion primitives (LaValle, 2006). There are numerous planning algorithms applied to a variety of robots. Some, including motion planning and obstacle avoidance,
are mature enough to be transferred onto real-world use cases (Siciliano and Khatib, 2016a). These
algorithms often run on energy-demanding heterogeneous computing hardware onboard the
mobile robots. They share computational capabilities with other algorithms, enabling various
autonomous features. In this context, energy consumption is a crucial aspect (Jaiem et al., 2016).
Most mobile robots have strict battery limitations, affecting the computing hardware and influencing the autonomous features, in turn, expected to increase in the foreseeable future (Fisher
et al., 2013).
While there are planning approaches that are well covered, others have received little attention
from the research community. Planning-scheduling energy awareness is one of such underrepresented approaches in the robotics research literature (Brateman et al., 2006; Lahijanian et al., 2018;
Ondrúška et al., 2015; Sudhakar et al., 2020). Here, by planning-scheduling energy awareness,
we mean the derivation of an energy-aware path with a power-saving scheduling policy for the
computing hardware. Past studies cover extensively one of these topics, but their interactions are
largely unexplored (Brateman et al., 2006). Some generate an energy-optimized path, but the computations energy–the energy required by the power demanding tasks running on the computing
1

2

Chapter 1. Introduction

Figure 1.1. Opterra fixed-wing aerial robot for the precision agriculture use case (photo credit: Amit
Ferencz Appel).

hardware–might equal the motion in some instances of low-energy mobile robots (Sudhakar
et al., 2020). Due to the recent advancements in the computational capabilities of heterogeneous
computing hardware, such as the introduction of powerful portable GPUs (Rizvi et al., 2017),
the use of computations is then further on the rise (Abramov et al., 2012; Jaramillo-Avila et al.,
2019; Satria et al., 2016). Others provide a power-saving scheduling policy, yet, moving a mobile
robot requires considerable energy expenditure over mere computations (Mei, Y.-H. Lu, Y. C. Hu,
et al., 2004, 2005).
We trade both planning-scheduling altogether and under strict energy constraints. Within
motion planning itself, by focusing on a specific category. In autonomous scenarios, it is often
required to explore every location in space (E. M. Arkin, Bender, et al., 2001, 2005; Cao et al.,
1988; H. Choset, E. Acar, et al., 2000). A problem solved by coverage planning (H. Choset, 2001;
Galceran and Carreras, 2013), and so, we show the interactions between planning-scheduling on
a coverage planning algorithm, covering a space scheduling high-level task for, e.g., perception, in
an elemental region. As a mobile robotics platform, we evaluate the approach with aerial mobile
robots in simulations and empirical trials. Although sharing with the broader class of mobile
robots stringent battery limitations, they have additional impediments. A conventional setup
would require landing to replace or recharge the battery. Aerial robots are an ideal instance of
energy-constrained systems, beneﬁtting the simultaneous planning-scheduling energy awareness. We
will see that we can back such a statement with observations of actual flights failure reductions
later with this work in Chapter 6.
There are numerous autonomous use cases involving aerial robots, such as precision agriculture, search and rescue, payload delivery, transportation, and many others. Here, we focus on
a precision agriculture use case of an autonomous aerial robot flying over an agricultural field

1.1. From UAVs to Modern Aerial Robots

3

with little human input. Precision agriculture is indeed often put into practice (Hajjaj and Sahari,
2014) with ground mobile robots used for harvesting (Aljanobi et al., 2010; De-An et al., 2011;
F. Dong et al., 2011; Edan et al., 2000; Z. Li et al., 2008; Qingchun et al., 2012), and aerial robots
for preventing damage and ensuring better crop quality (Daponte et al., 2019; Puri et al., 2017).
We investigate different physical aerial robotics platforms in this work but derive most results
with the Opterra fixed-wing (Hobby, n.d.) adapted for precision agriculture. The aerial robot is
in Figure 1.1.
The scope of this chapter is to introduce and motivate the planning-scheduling energy awareness for aerial robots. To this end, Section 1.1 investigates the evolution of aerial robots, and Section 1.2 classifies the modern aerial robotics literature w.r.t. this work. Section 1.3 provides further
motivation, objective, and methodology, and Section 1.4 outlines the approach. Sections 1.5–1.6
contain discussions of possible application and overall contribution. Finally, Section 1.7 structures the remaining chapters.

1.1

From UAVs to Modern Aerial Robots

Modern aerial robots are a valuable tool in robotic research and aerospace and have different
names in the literature, including unmanned aerial vehicles (UAVs)i , unmanned aerial systems
(UASs)ii , flying robots, or drones. Usually, UAVs and UASs indicate that these systems are semiautonomous or operated from the ground, whereas aerial or flying robots have advanced levels
of autonomy (Siciliano and Khatib, 2016b). Nevertheless, all these systems have basic autonomous
features such as position holding implemented with, e.g., the global navigation satellite system
(GNSS), altitude holding with a barometer, and leveling with the inertial measurement unit
(IMU).
Unmanned (or uninhabited) flight has more than a century of developments (Siciliano and
Khatib, 2016b). The origin of the field, which deals with the design and development of aerial
robots, dates back to the first guided missiles. Hewitt-Sperry Automatic Airplane in Figure 1.2,
also denominated “flying bomb” and deployed in 1917 during World War I (WWI) (Keane and
Carr, 2013; Valavanis and Vachtsevanos, 2015), is often referred to as the first unmanned flying
machine. Developed 14 years after the first heavier-than-air flight in history–demonstrated on December 17, 1903, with the Wright Flyer I by Wilbur and Orville Wright (or the Wright brothers)–it
used a gyroscope, invented shortly before by Elmer Sperry (Keane and Carr, 2013), like modern
aerial robots. The device was mechanically connected to the control surfaces, successfully implementing a control feedback loop (Siciliano and Khatib, 2016b).
In their early days, these first flying machines were referred to as remotely piloted vehicles
(RPVs) (Anderson, 2005). Many instances from WWI served military purposes. In the 1950s,
the United States used an RPV, the Ryan Firebee, for reconnaissance in Vietnam, and Israel
was the first to use an RPV in a combat situation (Anderson, 2005). Other instances include
the V-1 flying bomb from 1944 (deployed by the unified armed forces of nazi Germany) and
i
ii

The term unmanned is sometimes replaced by uninhabited.
UAS often denotes the entire infrastructure of unmanned flight in the aerospace jargon.

4

Chapter 1. Introduction

Figure 1.2. The Hewitt-Sperry Automatic Airplane, denominated “flying bomb” and developed during
WWI, represents the first instance of a UAV (photo credit: United States Naval Institute).

the Lockheed D-21 from 1962 (deployed by the United States Air Force). The introduction of
the global positioning system (GPS) at the end of 1970 increased recent developments with
applications such as surveillance. Integration with cameras and other sensors grounded further
applications (Siciliano and Khatib, 2016b), introducing modern aerial robots.
Recent developments include many civilian applications (González-Jorge et al., 2017). Aerial
robots are used increasingly in remote sensing (Colomina and Molina, 2014; Milas et al., 2018; Noor
et al., 2018; Tang and Shao, 2015), surveillance (Acevedo et al., 2014; Basilico and Carpin, 2015;
Bürkle, 2009; Paucar et al., 2018; Ramasamy and Ghose, 2017), meteorology (Renzaglia et al.,
2016; Schuyler et al., 2019), search and rescue (Cui et al., 2015; Hayat et al., 2017; Karaca et al.,
2018; Pensieri et al., 2020; Seguin et al., 2018), precision agriculture (Daponte et al., 2019; Lottes
et al., 2017; Popović et al., 2017; Puri et al., 2017; Sa et al., 2018), transportation, and payload
delivery (Kellermann et al., 2020). The former four categories fall into reconnaissance, surveillance,
and target acquisition (RSTA) and do not require advanced autonomy; precision agriculture,
transportation, and payload delivery utilize a certain extent of computational intelligence (Siciliano and Khatib, 2016b). They handle unexplored terrain with little interaction, contrary to
the past human-operated UAVs (Siciliano and Khatib, 2016b). Instances autonomously adapt and
possibly interact in a wide variety of environmental conditions.
In summary, aerial robots have a recent past. Some initial experiments came shortly after the
first heavier-than-air manned and powered flight. These often served military purposes, whereas
modern aerial robots fly in a broad range of civilian applications. Aerial robots are to grow significantly in numerous areas in and out of robotics research ranging from agriculture to planetary
exploration. For the latter, Figure 1.3 shows NASA’s Ingenuity Mars Helicopter. A small coaxial
aerial robot in the first powered, controlled flight on another planet on April 19, 2021. Aerial

1.2. Common Classes of Aerial Robots

5

Figure 1.3. NASA’s Ingenuity Mars Helicopter. A rotary-wing coaxial aerial robot, achieving the first
powered, controlled flight on another planet on April 19, 2021 (photo credit: NASA Jet Propulsion Laboratory).

robots for planetary exploration are to be deployed in future explorations endeavors, for instance,
to study Saturn’s moon Titan (Voosen, 2019).

1.2

Common Classes of Aerial Robots

There are different types of aerial robots in the robotics literature. We briefly investigate the
most studied classes w.r.t. the planning-scheduling energy awareness in this work. The two most
generic classes are heavier- and lighter-than-air aerial robots. Heavier-than-air compromise fixedand rotary-wings (Siciliano and Khatib, 2016b), and some recent contributions in bio-inspired
robotics investigate flapping-wings aerial robots (Floreano and Wood, 2015).
Rotary-wing aerial robots are highly maneuverable and suited for stationary vertical flight
or hovering (Siciliano and Khatib, 2016b) where rotors provide the lift and maneuvering. They
compromise multirotors (equipped with multiple rotors such as quadrotors or quadcopters,
hexacopters, and octocopters), conventional helicopters (with one main and one tail rotor), and
coaxes (with counter-rotating coaxial rotors) (Corke, 2017). Examples of quadrotors are DJI
Mavic Mini in (h) and DJI Phantom 4 in (j) in Figure 1.5. DJI Agras T16 in (g) and DJI Matrice
600 in (f) are hexacopters.
Fixed-wing aerial robots share the same motion principle with an aircraft where wings provide the lift, control surfaces maneuvering, and propellers the forward thrust (Corke, 2017). An
example constitutes the Opterra adapted for precision agriculture in Figure 1.1, Cumulus in
(b), Ebee in (d), and Penguin BE in (c) (Haugen and Imsland, 2016) in Figure 1.5. Examples of

6

Chapter 1. Introduction

Figure 1.4. Skye, an omnidirectional spherical blimp developed by ETH Zürich for entertainment
purposes. It has a camera system and combines the energy-efficient flight of a blimp with the characteristics of a quadrotor (photo credit: ETH Zürich).

flapping-wings are DelFly II in (k) (Clercq et al., 2009; Groen et al., 2010; Percin et al., 2012) and
Nano-Hummingbird in (l).
Instances of lighter-than-air aerial robotss are blimps (or non-rigid airships). They usually rely
on gas, e.g., helium enclosed in a protected envelope (Burri et al., 2013), to generate the lifting
force (Fui Liew et al., 2017). An omnidirectional spherical blimp is in Figure 1.4. Blimps are similar
to balloons but provide some maneuverability against controlling merely the altitude (Colombatti
et al., 2011).
Other classifications are, e.g., micro aerial vehicles (MAVs), vertical take-off and landing
(VTOLs) aerial robots, and others. The former are aerial robots with all dimensions lower than 15
centimeters. The latter fly in a fixed-wing configuration except for taking-off and landing, where
they use thrust from rotors rather than lift from wings.
Among the classes in this section, rotary-wings are the most maneuverable, lighter-than-air
aerial robots the least. Nonetheless, these have the highest flight time followed by fixed-wing
aerial robots. Mixed configurations, such as VTOLs, fall into the intersection of rotary- and fixedwings for what concerns maneuverability and flight time (Siciliano and Khatib, 2016b). The energy
requirements are critical for all aerial robots, but the difference of motion and computations
energy (M&CE) varies greatly. It is highest in rotary-wings, lowest in lighter-than-air aerial robots
in Figure 1.5, and relatively comparable for fixed-wings. Planning-scheduling would thus rely on
both for this latter group energy-wise while relying almost exclusively on planning for rotarywing aerial robots. In the former, M&CE is close to zero. In the latter, it is usually high except
for energy-optimized designs such as some rotary-wing MAVs. Hypothetically, in lighter-than-

1.2. Common Classes of Aerial Robots

7

Flight time (min)
powersaving

lighter-than-air

schedule
M&CE  0

fixed-wings

Skye (a)

150

M&CE = 0

M&CE  0
Cumulus (b)

100

energyoptimal
path

Penguin BE (c)

Opterra (e)
Ebee (d)

DJI Matrice 600 (f)
DJI Mavic Mini (h)
50

DelFly II (k)

rotary-wings

DJI Agras T16 (g)

flapping-wings
DJI Phantom 4 (j)

100

101

102

103

Power (W)

Nano-Hummingbird (l)

Figure 1.5. Different aerial robots in relation to the power, flight time, and M&CE with a hypothetical
fixed costs for computations energy. The power is expressed using a logarithmic scale. Heavier-thanair aerial robots (b)–(l) include flapping-wings (k), (l) with a negative M&CE (computations energy
is predominant), and rotary-wings with a positive M&CE (f), (g) (motion energy is predominant).
Smaller rotary-wings have an M&CE closer to zero (h), (j). In general, rotary-wings have a short
flight time. Fixed-wings (b)–(e) have longer flight time and M&CE close to zero (computations and
motion energies are comparable). Lighter-than-air aerial robots (a) have a hypothetically long flight
time and lower than zero M&CE (photos credit: (b) to Sky-Watch, (f) to Rise Above, (g) to Aeromotus, (h) to
Digital Photography Review, (j) to ePHOTOzine, and (l) to DARPA).

8

Chapter 1. Introduction

air aerial robots, M&CE might be negative. The planning-scheduling would rely heavily on
scheduling.
The classification with M&CE serves the scope of our work. There are similar efforts to group
aerial robots by size and propulsion technology (Cabreira, Brisolara, et al., 2019; Hoffer et al., 2014),
but other classifications are possible, e.g., categorization by altitude (Watts et al., 2012).

1.3

Motivation

Use cases involving aerial robots ranging from remote sensing to payload delivery have strict
battery constraints. It is a common problem of most mobile robots (Mei, Y.-H. Lu, C. Lee, et al.,
2006), yet, aerial robots are particularly affected. Indeed, the availability of the power source
might influence their autonomy. An instance is an aerial robot autonomously inspecting a given
space by, e.g., detecting ground patterns and notifying other ground-based actors in a precision
agriculture use case. For such and many others, aerial robots often rely on computing hardware
along with a microcontroller (Andrew et al., 2019; Dharmadhikari et al., 2020; Holper et al., 2017;
Papachristos et al., 2015). Computing hardware provides autonomous capabilities and planning,
whereas a microcontroller runs motion primitives by directly interfacing with actuators (such as
servos for the control surfaces) and motors (Mei, Y.-H. Lu, Y. C. Hu, et al., 2005).
1.3.1

Planning-scheduling energy awareness

It is uncommon to find a ready-to-use solution for simultaneous planning the path and scheduling the computations of these systems in an energy-aware fashion (Brateman et al., 2006; Sudhakar et al., 2020). It might be potentially advantageous to schedule the computations on the
computing hardware and simultaneously to plan the path rather than solving these two separately (Lahijanian et al., 2018; Ondrúška et al., 2015) by, e.g., optimizations in terms of the battery
state of charge (SoC).
For certain classes of aerial robots with M&CE close (or lower than) zero, the autonomy can
directly influence the battery state. For these classes, it is desirable to reschedule the computations
energy-wise in-flight during a motion energy-demanding phase. For instance, a fixed-wing aerial
robot might be flying headwind (with the wind vector parallel and opposite to the direction of
motion) and utilizing more energy than planned. It would be of advantage to reschedule the tasks
accordingly and compensate for the increment in motion energy. During the same flight, the
wind direction might suddenly change. The fixed-wing craft, now flying downwind, requires less
motion energy. It could then potentially increase the level of computations by rescheduling the
tasks. Later in the flight, the battery might be subject to sudden drops due to, e.g., temperature
changes, requiring replanning again by, for instance, shortening the path. Planning-scheduling
altogether in all these cases is, perhaps, the most desirable course of action.
In Figure 1.5, we show the M&CE against the flight time of different aerial robots. We observe that fixed-wings are the aerial robots that would advantage the most from simultaneous
planning-scheduling. They have an M&CE close to zero and a long flight time. Although some

1.3. Motivation

9

rotary-wings have M&CE also close to zero, their flight time is generally short. Flapping-wings
and lighter-than-air aerial robots have a negative M&CE, requiring less energy for the motion.
Furthermore, practical implementations of these latter categories might be carrying only a microcontroller (Groen et al., 2010).
1.3.2

Objective

In the remainder of this work, we refer to computational tasks that can be scheduled in an
energy-aware fashion as computations, opposed to others with no significant effect on energy
consumption. We assume the aerial robot runs the computations on the heterogeneous computing hardware. As an example, we refer to an aerial robot in a precision agriculture use case,
doing coverage planning while detecting ground hazards. These include livestock, humans, and
vehicles (Zamanakos et al., 2020), potentially obstructing operations of a ground-based mobile
robot for, e.g., harvesting. In abstract terms, the field is a polygon in Figure 1.6. The aerial robot
detects patterns using a convolutional neural network (CNN), flying over the polygon. It further communicates the position of the detections to other, ground-based actors. Detecting the
patterns usually involves heterogeneous computing elements (GPU and/or multi-core CPU)
and consumes a significant amount of energy contrary to, e.g., communication.

z
OW

y
x

Figure 1.6. The coverage problem in the precision agriculture use case. The aerial robot covers an
agricultural field that forms a polygon (blue/transparent area in the frame), executing tasks as part of
its autonomous operations (photo credit: Amit Ferencz Appel).

We are interested in the energy optimization of the path and schedule in-flight and under uncertainty (such as from atmospheric interferences). Such planning-scheduling finds optimal tradeoffs between the path, computations, and energy requirements. Current generic solutions for,
e.g., aerial robots coverage planning, do not investigate the two aspects simultaneously, nor are
they energy-aware. They are often semi-autonomous. The path and computations are static and
usually defined using planning software (Daponte et al., 2019) from existing algorithms (H. Choset,
2001; Galceran and Carreras, 2013), with instances including popular flight controllers (Paparazzi,

10

Chapter 1. Introduction

n.d.[b]; PX4, n.d.). This state of practice has prompted us to investigate the possible interaction

between planning-scheduling applied to coverage path planning (CPP) for autonomous aerial
robots. In the remainder, we will gradually build an approach that plans and schedules altogether
while the aerial robot flies and its batteries drain under various conditions.

1.3.3

Methodology

Initial iterations of our work relied on case study research, a widely used qualitative research
method (Darke et al., 1998). Here, we qualitatively investigated collected data and observed phenomena of the aerial robot flying early instances of the agricultural use case to derive methodologies and implications at subsequent stages. We focused on an in-depth analysis of the planningscheduling interactions, analyzing its energy implications and the available literature.
The grounding of further research directions involved research questions formulation: (a) how
to model the computations energy to predict the impact of any possible schedule on the computing hardware’s power? (b) How to model the motion energy to predict the impact of any
possible variation of motion on the aerial robot’s energy? (c) How to merge these two points
with a cohesive model? (d) How to derive an optimal configuration of the schedule and motion?
We addressed these questions using the active research method cycle (Susman and Evered,
1978): beginning from each question, we derived a research action, deployed the action with a
rigorous methodology, evaluated the results, and under unsatisfactory outcomes, adjusted the
methodology. Multiple iterations of the cycle led to the energy-aware coverage planning and
scheduling for autonomous robots in this work. We addressed the research question (a) in Sections 4.1–4.2, (b) in Sections 4.2–4.3, (c) in Section 4.3, and (d) in Chapter 5.

1.4

Outline of the Approach

For planning-scheduling together, we need some information on the intended use for both the
path and computations. Path-wise, these include data on the coverage area, such as a description of an equivalent polygon. Chapter 2 details ways of defining the problem with its building
constructs (plan, stages, parameters, paths, constraints, triggering points). From the polygon, a
coverage algorithm in Section 5.2 generates a plan composed of multiple stages, later eventually
replanned by a replanning algorithm in case of, e.g., sudden battery drops in Section 5.3. At each
stage, the aerial robot flies a path and executes some computations. The concept of different
stages serves the purposes of modeling complex paths, e.g., multiple circles and lines form the
overall coverage. The robot switches between the paths in the proximity of specific triggering
points. The plan further contains some additional parameters to alter the path and computations
along with an energy budget. The alterations are bounded. There are path constraint sets that
bound the path alterations and computations constraint sets, one per each computation, that
bound computations alterations. The approach guides the aerial robot with a vector field-based
gradient descent algorithm in Section 5.1.

1.5. Applications

11

Computation-wise, we need an approach to specify the computations and quantify their energy contribution. Chapter 4 covers these aspects, as well as the motion and battery energy models.
The approach relies on powprofiler (Seewald, Schultz, Ebeid, et al., 2021b), a tool that we introduce in Section 4.1, part of our early studies (Seewald, Schultz, Ebeid, et al., 2021a; Seewald,
Schultz, Roeder, et al., 2019). The tool models the power, energy, and battery SoC of the computations, and is embedded in the future energy estimations of the aerial robot. To this end, we
empirically derive and formally prove a periodic differential energy model that accounts for the
uncertainty. Based on Fourier analysis, the model exploits empirical observations to include path
and computations alterations. Periodicity is due to the periodic patterns in the coverage plan.
Indeed, in the coverage, as well as some other autonomous scenarios, the mobile robot often
iterates over a set of tasks and paths (Seewald, García de Marina, Midtiby, et al., 2020; Seewald,
García de Marina, and Schultz, n.d.). Given that the plan is periodic, we expect the energy consumption to evolve (approximately) periodically. Chapter 6 will back the statement with both
experimental and realistic simulated findings.
Once we have a plan and all the components to model the energy and battery, in Chapter 5, we
can (re)plan-schedule the coverage online in-flight, aided by modern optimal control techniques,
i.e., state estimation and model predictive control (MPC) (Rawlings et al., 2017; Simon, 2006).
The control is data-driven: energy sensor data estimates some coefficients of the model to predict
the future energy consumption with uncertainty while obeying the energy budget–the battery
capacity and other battery parameters. Our goal is to complete the plan with the highest possible
parameters configuration.

1.5

Applications

In the remainder of this work, we focus on the precision agriculture use case where we plan the
coverage and schedule hazards detection. Nonetheless, the approach works with other potential
use cases. Earlier collaborations between consortium members of the TeamPlay project (TeamPlay
Consortium, 2019b), funding this work has led to a search and rescue use case, where an aerial robot
detects vessels in an offshore area, eventually planning-scheduling of the search pattern and the
detection rates. We briefly detailed the scenario in our earlier study (Seewald, Schultz, Ebeid, et al.,
2021a), which has been since extended with a deadline guarantee scheduling policy (Rouxel et al.,
2020). We have then attempted other use cases, e.g., mapping in the planetary exploration context,
where we hypothesized the possibility of scheduling navigation (Seewald, 2020). Indeed an earlier
study proposes a similar technique, scheduling perception (Ondrúška et al., 2015), perhaps further
motivating our analysis. Simulated use cases are also possible. In an early study (Zamanakos et al.,
2020) of a use case in agricultural safety, we followed a simulated agricultural vehicle by varying
the tracking algorithm.
There are multiple possibilities to apply our approach to a broad range of real-world and
simulated use cases, arising in many different fields in and outside of basic robotics research.
Generally, the planning-scheduling energy awareness in this work applies to modern aerial robots
with a certain degree of autonomy, whereby the robot performs at least a predefined set of tasks

12

Chapter 1. Introduction

over a given space. Indeed most of the guidance in Chapter 5 works well for aerial robots, yet, one
can adapt our work to other mobile robots with energy constraints. We discuss applications out
of the aerial robotics domain further in Chapter 7. We expect the approach to be most relevant to
energy-efficient mobile robots, with the best outcomes for M&CE close to zero (the motion and
computations energy contributions are similar). Such conclusion is shared with other studies
researching planning-scheduling energy awareness (Brateman et al., 2006; Lahijanian et al., 2018;
Mei, Y.-H. Lu, Y. C. Hu, et al., 2005; Ondrúška et al., 2015; Sudhakar et al., 2020), which we discuss
further in Chapter 3.

1.6

Contribution

There are some approaches to merging planning-scheduling in different robotics use cases in
the literature (Brateman et al., 2006; Lahijanian et al., 2018; Mei, Y.-H. Lu, Y. C. Hu, et al., 2005;
Mei, Y.-H. Lu, Y. C. Hu, et al., 2006; Ondrúška et al., 2015; Sadrpour et al., 2013a,c; Sudhakar et al.,
2020; W. Zhang and J. Hu, 2007), yet

the research area remains mostly unexplored (Brateman
Our work contributes with the past relevant literature to
this existing research gap, proposing coverage planning and scheduling for autonomous aerial
robots under stringent energy constraints. Specifically, we derive an energy model for the heterogeneous computing hardware, alongside modeling the energy contribution of the motion. We
use the model in an optimal control technique similarly to past literature (Brateman et al., 2006;
Lahijanian et al., 2018; Ondrúška et al., 2015; W. Zhang and J. Hu, 2007), but fill the gap further
with accurate energy modeling of computations and propose an actual implementation of an
MPC-based algorithm. We provide a power-saving scheduling policy as opposed to simply varying the frequency of the computing hardware (Brateman et al., 2006; W. Zhang and J. Hu, 2007),
and notably, our approach runs online and is dynamic, planning-scheduling in flight rather than
deriving static plans-schedules (Lahijanian et al., 2018). It provides additional modeling rigor and
incorporates battery-aware optimization as opposed to merely considering the overall energy
expenditure (Sudhakar et al., 2020). We vary both the path and the schedule the aerial robot
flies and runs, contrary to others that vary just one of the aspects while analyzing the energy
implications of the remaining (Ondrúška et al., 2015).
Aside from past relevant studies, literature on topics related to computations energy modeling,
battery modeling, motion planning, and aerial planning, our contribution builds from some of
our past and forthcoming studies. Our computational energy modeling relies on the methodology in our early study (Seewald, Schultz, Ebeid, et al., 2021a), which presented the powprofiler
tool (Seewald, Schultz, Ebeid, et al., 2021b) for future energy predictions of heterogeneous computing hardware. We proposed an extension of powprofiler with a component-based energy
modeling approach to abstract per-component energy in a dataflow computational network in
another study (Seewald, Schultz, Roeder, et al., 2019) that we later integrated into a Robot Operating System (ROS) (Quigley et al., 2009) set-up in the following work (Zamanakos et al., 2020).
Here we scheduled the simulated tracking of agricultural vehicles. The motion energy model we
propose in Chapter 4 relies on empirical observations of the Opterra fixed-wing aerial robot flying
et al., 2006; Sudhakar et al., 2020).

1.7. Reading Guide

13

the agricultural scenario we introduced earlier in our work (Seewald, García de Marina, Midtiby,
et al., 2020). We hypothesized the approach on different robots in our brief early study (Seewald,
2020). Finally, we plan to detail the planning-scheduling energy-awareness for CPP in precision
agriculture in our forthcoming study (Seewald, García de Marina, and Schultz, n.d.), relying on
all the concepts in this work.

1.7

Reading Guide

In this chapter, we introduced energy-aware coverage planning and scheduling for autonomous
aerial robots, the field of aerial robotics, motivated our work, and provided its objective and
methodology. We then outlined the approach, proposed the applications, and discussed the
contribution.
The remaining chapters have the following structure. Formal definitions of the problem and
the basic constructs are subjects of Chapter 2. These include the plan, stages, parameters, paths,
constraints, and triggering points. The chapter then contains a plan example extended in the
remainder of the work. Chapter 3 discusses the relevant literature for computations energy and
battery modeling, motion and aerial planning, and planning of computations with motion, relating each study to our approach. Planning-scheduling energy awareness requires accurate future
energy predictions, and so, Chapter 4 derives computations and motion energies and battery
models. It details the powprofiler tool for computations energy modeling and the differential
periodic energy and battery models. Chapter 5 proposes a set of algorithms for guidance, CPP,
and energy-aware coverage replanning and scheduling. The guidance directs the aerial robot
physically on the coverage, CPP provides a plan, covering each point in space, and energy-aware
replanning replans the plan energy-wise in-flight. Chapter 6 describes the experimental setup and
results. Finally, Chapter 7 summarizes the work and concludes with the outcomes and future
perspectives.

Chapter 2

Problem Formulation
“While we will often speak of the [coverage] problem as ‘milling’ with a ‘cutter’, many
of its important applications arise in various contexts outside of machining.”
— E. M. Arkin, Bender, et al., 2001

h e s co pe of this chapter is to provide building blocks and formal definitions
paving the foundation of the remaining chapters. Here, we derive the planning and coverage problems we solve with this work. The coverage problem is the problem of finding a path,
covering all the points in a given space (H. Choset, 2001; Galceran and Carreras, 2013), for instance, the agricultural field in Section 1.3. The coverage path with computations forms the plan.
The planning problem is the problem of replanning the plan. In the context of this work, it is
replanned energy-wise in the eventuality of energy constraints dissatisfaction and whenever the
uncertainty affects the flight unexpectedly. Both the problems are formulated in Section 2.5. The
formulations rely on plan-specific constructs in Sections 2.1–2.4, with the concepts of computations, motion, and computations and motion energies. Further formalities include the difference
between computations and motion energies (M&CE) encountered in Section 1.2. We illustrate
the problem with an example of the precision agriculture use case in Section 2.6.
The chapter connects to the remainder of this work as follows. Here we formalize the plan,
the planning and coverage problems, and some other basic constructs. Chapter 3 discusses past
approaches to solve the problems. Chapter 4 exploits the plan characteristics to derive computations and motion energy and battery models. Chapter 5 provides a solution to the planning
problem with modern optimal control techniques and the coverage problem using a coverage
path planning (CPP) algorithm. It further provides ways to guide the aerial robot with an algorithm based on vector fields, using the plan’s building blocks. Chapter 6 shows the problems in
realistic and simulated experiments.

T

15

16

2.1

Chapter 2. Problem Formulation

Definitions of computations and motion

This section contains definitions of computations and motion, their respective energies, and
M&CE.
Computations are energy-demanding computational
tasks. The aerial robot runs the computations on heterogeneous computing hardware that interfaces to microcontrollers.
Motion is the act of the aerial robot moving in the surrounding environment. For this purpose, it runs primitives on microcontrollers that interface to actuators, motors, and other components.
Definition 2.1.1: Computations/motion.

Autonomous capabilities are often achieved by interconnecting heterogeneous computing
hardware and microcontrollers. For the computations, we assume that the heterogeneous computing hardware runs a parametrized schedule. For instance, for the detections in the precision
agriculture use case in Section 1.3, a parameter is the frames per second (FPS) rate. Similarly, for
the motion, we assume that the robot travels parametrized paths. In the use case, a parameter
changes the coverage quality.
Given a path parametrized by ρ values
:= {ci,1 , ci,2 , . . . , ci,ρ }, the motion energy is the energy spent by the aerial robot while
moving on the path.
Given a schedule parametrized by σ values ciσ := {ci,ρ+1 , ci,ρ+2 , . . . , ci,ρ+σ }, the computations energy is the energy spent by heterogeneous computing hardware executing the schedule.
The overall energy is the sum of motion energy and computations energy.
Definition 2.1.2: Computations/motion and overall energy.
ρ
ci

Physically, motion energy is the energy spent by all the systems powering the aerial robot,
excluding the heterogeneous computing hardware. It uses measures in watts for instantaneous
or average, joules for overall energies. Section 2.3 details the meaning of parametrized paths and
computations.
Definition 2.1.3: Difference of motion and computations energy (M&CE).

Given measures of average
motion and computations energies, M&CE is the measure of their difference.
M&CE is measured in watts and quantifies which of the two energy components is predominant. For M&CE greater than zero, the motion energy dominates over the computations. The
planning-scheduling energy awareness accentuates on an energy-efficient path (e.g., rotary-wing
aerial robots (f) and (g) in Figure 1.5). On the contrary, for M&CE lower than zero, the computations energy dominates. The planning-scheduling energy awareness focus on a power-saving
schedule (e.g., lighter-than-air aerial robot (a)). For M&CE close to zero, both energy components
are important energy-wise. The planning-scheduling energy awareness trades both an energyefficient path and a power-saving schedule to a similar extent (e.g., fixed-wing aerial robots (b)–(e)).

2.2. Definition of path functions

17

z

φ(p) = d

y
d

yp

(xp , yp , h)
2y − x = h

xp

φ(x, y) := 2y − x

x

Figure 2.1. The path function is a mathematical function φ(p(t)) = h that represents a line at an
altitude h. A generic point p in 2D space intersects the plane formed by φ at a value d of the z-axis.

2.2

Definition of path functions

A succession of multiple mathematical functions φ1 , φ2 , . . . termed path functions forms the
coverage path that the aerial robot follows. They are expressed in 2D space at an altitude h ∈ R
for an inertial navigation frame OW . Here, we assume the aerial robot flies over a given elemental
region for the coverage without altering the altitudei .
φi : R2 → R, ∀i ∈ {1, 2, . . . } are path functions, forming the
path. They are a function of a generic time-dependent point p(t) := (xp(t) , yp(t) ) of the aerial
robot flying in the 2D space at an altitude h and are continuous and twice differentiable.
Definition 2.2.1: Path functions.

We use this notation to guide the aerial robot with the theory of vector fields. For instance,
one can define a line as a path function with
φ(x, y) := ax + by + c,

(2.1)

where a, b, c ∈ R are given constants. The generic point p(t) intersects φ(x, y) at a specific
value d of the z-axis (p(t), d). Figure 2.1 illustrates the concept for c zero, a, b minus one and
two, and h zero for simplicity. The point intersects the plane formed by the path function
φ(x, y) := 2y − x,

(2.2)

at d = φ(p). The path that the aerial robot follows is then φ(x, y) = h. φ(p) − h is the distance
on the z-axis.
i

We discuss later in terms of future directions a generalization of the path functions in 3D space for, e.g., urban
monitoring use cases.

18

Chapter 2. Problem Formulation

φ(x, y) := (x − 3)2 + (y − 3)2 − 2

z

y
φ(p) = d2
d2

yp

(xp , yp , h)

(x − 3)2 + (y − 3)2 − 2 = h

xp
x
Figure 2.2. The path function now represents a circle at an altitude h. p intersects the cone formed
by φ at a value d2 of the z-axis.

Likewise with the line, one can define a circle as a path function with
φ(x, y) := (x − xc )2 + (y − yc )2 − r 2 ,

(2.3)

where xc , yc are given coordinates of the center and r ∈ R>0 the radius. Figure 2.2 illustrates
√
the circle path function for xc , yc both three, r two, and h zero for simplicity.
In this work, we use lines and circles as path functions. We connect these functions using some
specific points–the triggering points–to form the coverage path. However, one can define any
mathematical function, with the only requirement being continuity and twice differentiability.
The first derivative is a requirement for the vector field, the second derivative of the control
action. Chapter 5 details the concept further.

2.3

Definitions of stages and triggering points

The plan has several stages i = {1, 2, . . . }, and we assume that at each stage, the aerial robot
runs a schedule and travels a path function φi using a parameters set ci . Parameters are variable
values to replan the path and computations, influencing the computations/motion energy in
Definition 2.1.2. The path parameters are real-, the computations parameters integer-valued (R, Z).

2.3. Definitions of stages and triggering points

19

The notation ci,j denotes the jth parameter of the ith parameters set
ci = {ci,1 , ci,2 , . . . , ci,j , . . . }.

(2.4)

Parameters are bounded. c i,j is the lower, c i,j the upper bound of the parameter ci,j
c i,j ≤ ci,j ≤ c i,j ,

(2.5)

expressing physical bounds of the computing hardware and the aerial robot (e.g., it is not possible
to compute more than the capabilities of the computing hardware, turn narrower than the
minimum turning radius of the aerial robot, and so on).
There are ρ path-specific parameters and σ computations-specific parameters for every
ρ
stage. It means that the path at stage i can be replanned with ρ path parameters ci :=
{ci,1 , ci,2 , . . . , ci,ρ }, and the computations scheduled with σ computations parameters ciσ :=
{ci,ρ+1 , ci,ρ+2 , . . . , ci,ρ+σ }.
Returning to Section 2.1, “path parametrized by ρ values” indicates that φi is enhanced with
ρ
ci . The function φi : R2 × Rρ → R is thus a (continuous twice differentiable) function
of a point and the path parameters. We use the parameters to alter the path and change the
energy consumption. Similarly, “computations parametrized by σ values” indicates that ciσ is the
computations schedule. These parameters also serve for energy alteration (e.g., decreasing the
granularity of a given computation lowers the power). We discuss the alteration of the energy
with path and computations parameters further in Sections 4.3.2–4.3.3.
The stage is a set that contains the path and path and computations parameters.
Definition 2.3.1: Stage.

For a generic point p(t), the ith stage Γi at time instant t of a plan Γ is
ρ

Γi := {φi (p(t), ci ), ciσ | ∀j ∈ [ρ]>0 , ci,j

∈ Ci,j ,

∀k ∈ [σ ]>0 , ci,ρ+k ∈ Si,k },
where Ci,j := [c i,j , c i,j ] ⊆ R is the jth path parameter constraint set, and Si,k
[c i,ρ+k , c i,ρ+k ] ⊆ Z≥0 the kth computation parameter constraint set.

:=

The next section clarifies why the stage contains the generic point p(t).
It is possible to merge the computations and path constraint sets in a single constraint set. ith
stage constraint set is then

Ui (ci,j ) :=

(
Ci,j
Si,j−ρ

for ci,j with j ≤ ρ
for ci,j with ρ < j ≤ σ

,

(2.6)

the stage can be simplified
ρ

Γi := {φi (p(t), ci ), ciσ | ∀j ∈ [ρ + σ ]>0 , ci,j ∈ Ui (ci,j )}.
Specific points termed triggering points pΓi allow the transition between stages.

(2.7)

20

Chapter 2. Problem Formulation

The triggering point is the point pΓi that allows the
transition between stages. The ﬁnal point is the last triggering point pΓl relative to the last stage
Γl .
Definition 2.3.2: Triggering and final points.

As soon as the aerial robot reaches the proximity of these points, it switches to the next stage
p(t) − pΓi < εi ,

(2.8)

where εi ∈ R is a given stage-dependent constant value expressing the radius of an imaginary
circle over the point pΓi .

2.4

Definition of plan

The energy model in Section 4.3 exploits the concept of the aerial robot flying a set of paths and
computations autonomously. Such an autonomous flight plan often presumes a certain degree
of periodicity, which one can observe in the precision agriculture use case in Section 1.3. An
exhaustive way to cover the agricultural field in Figure 1.6, i.e., to visit all the points in the space,
is to define a basic pattern. The aerial robot flies over the field once and iterates the basic pattern
until it covers the desired area. In literature, the basic pattern is often termed “motion” and the
most common is, e.g., boustrophedon motion (Cabreira, Brisolara, et al., 2019; H. Choset, 2001;
H. M. Choset et al., 2005; Galceran and Carreras, 2013). One can then define the plan just as a
set of stages, triggering points, a final point, and a shift that specifies how the constructs (except
the final point) shifts in space every period. The concept of primitive paths in the following
simplifies the planning to this latter case.
Given n ∈ Z>0 , the paths φ1 , . . . φn are called primitive paths
if all the remaining paths in the plan are built from these paths with a shift d := (xd , yd ).
Definition 2.4.1: Primitive paths.

Let us assume the number of stages in the plan is known and is l ∈ Z>0 . If the plan is built
from the primitive paths, it means that n in Definition 2.4.1 respects
n < l, l/n ∈ Z,

(2.9)

where n is a multiplier of l.
One can then write the remaining paths from the n primitive paths as φn+1 ,
φn+2 , . . . , φn+n , . . . , φl , or more generally φ(i−1)n+1 , φ(i−1)n+2 , . . . , φ(i−1)n+n , ∀i ∈ [l/n −
1]>0 . Or similarly
ρ

ρ

φ(i−1)n+j (p + (i − 1)d, c1 ) − φin+j (p + id, c1 ) = ej ,
ρ

(2.10)

for a given shift d, initial point p, and initial value of path parameters c1 . Equation (2.10) holds
∀i ∈ [l/n − 1]>0 , j ∈ [n]>0 . ej ∈ R is the jth constant difference.
Generally, if the plan is built from the primitive paths, it is not required to know a priori
the number of stages l. The paths can be iterated up until the final point pΓl . Alternatively to

2.4. Definition of plan

21

the primitive paths, one can define the plan as a mere linear succession of stages along with
the triggering and final points. In the latter case, the energy can be periodic, aperiodic, or semiperiodic. Aperiodicity affects the modeling, and thus future energy predictions.
Formally, the plan is a finite state machine that exploits the constructs of path functions in
Definition 2.2.1 and stages and triggering points in Definitions 2.3.1–2.3.2.
For a generic point p(t), the plan is a finite state machine (FSM) Γ, where
S
S
the state-transition function s : i Γi × R2 → i Γi maps a stage and a point to the next stage

Definition 2.4.2: Plan.

s(Γi , p(t)) :=

(
Γi+j
Γi

∃j ∈ Z, if p(t) − pΓi < εi

.

otherwise

The value εi in Definition 2.4.2 is the same εi in Equation (2.8).
A concept that we use in the remainder of this work, and particularly in energy modeling in
Chapter 4, is the period–the time required to fly the primitive paths φ1 , φ2 , . . . , φn (or generally
φ(i−1)n+1 , φ(i−1)n+2 , . . . , φ(i−1)n+n ).
For a given stage Γi and j ∈ Z>0 , the period T ∈ R>0 is the flight time
measured in seconds between φ(i−1)n+j and φin+j .

Definition 2.4.3: Period.

We assume the initial period T is one and measure the period required to fly the paths physically or in simulation. The periods might be different for different js due to atmospheric interferences or replanning. For the path functions, the coverage algorithm defines the plan using
primitive paths φ1 , φ2 , . . . , φn , but can alternatively define all the stages explicitly and find n
searching the value which satisfies the Equation (2.10). If there is no such value (e.g., when the plan
is composed of only one stage or the plan is aperiodic), the period can be determined empirically
from energy data.
We illustrate the plan, stage, triggering, and final points definitions in Figures 2.3–2.5.
p(t1 )
start

pΓ1
Γ1

p(t3 )

p(t2 )
···

pΓi−1

Γi

pΓi

···

pΓl

Γf

Γ
Figure 2.3. Definition of a plan Γ as an FSM. Each state is a stage Γi , the transition happens in
the proximity of specific points called triggering points pΓi . The accepting stage Γf indicates the
termination of the plan.
Figure 2.3 illustrates a plan with a linear succession of stages. The triggering point pΓi−1 allows
the transition to the stage Γi . The robot remains in the stage with any generic point p(t2 ), where
t1 < t2 < t3 are three different time instants. It eventually enters the stage Γi+1 with the

22

Chapter 2. Problem Formulation

p(t2 )
ρ

···

ρ

pΓi−1 (c1 , . . . , ci−1 )

ρ

ρ

pΓi (c1 , . . . , ci )

Γi

···

Figure 2.4. Detail of the stage Γi in the FSM. The triggering points used to transition between states
are expressed in the function of the last and/or previous path parameters.

triggering point pΓi and so on, until it reaches the final point. Γf is the accepting stage (it indicates
that the robot has completed the plan). Figure 2.4 illustrates that it is possible to express the
basic constructs–such as path functions and triggering points–in the function of the ith path
ρ
parameters ci , or any previous path parameters, propagating the information therein if necessary.
We further expand on this notion in the example in Section 2.6, where we propagate a path
parameter to all the following triggering points and path functions.
pΓn
p(t1 )
start

p(t2 )
pΓ1

Γ1

pΓ2
Γ2

p(t4 )

p(t3 )
···

pΓn−1

Γn

pΓl

Γf

pΓl
pΓl

Γ
Figure 2.5. Definition of a plan Γ with periodic patterns. Stages Γ1 , Γ2 , . . . , Γn containing primitive
paths φ1 , φ2 , . . . , φn are iterated with a shift d.
Figure 2.5 illustrates a plan composed of n stages Γ1 , Γ2 , . . . , Γn

(containing primitive paths
φ1 , φ2 , . . . , φn ) that are reiterated with the shift d. t3 < t4 is another time instant. We will see
in Chapter 5 that the algorithm that solves the coverage problem outputs primitive paths, and
the corresponding plan to be replanned is equivalent to Figure 2.5.

2.5

Problem Statement

The overall strategy for energy-aware coverage planning and scheduling for autonomous aerial
robots is split into two sub-problems: the planning and coverage problems.

2.5. Problem Statement

2.5.1

23

Planning problem

The planning problem is the problem of finding the optimal configurations of the parameters
using some criteria. Within planning-scheduling energy awareness in the robotics research literature, it is often solved with optimal control techniques (Brateman et al., 2006; Lahijanian et al.,
2018; Ondrúška et al., 2015; W. Zhang and J. Hu, 2007). Here, we focus on energy criteria, such as
the battery constraints. Solving the planning problem by finding the optimal configurations with
different criteria, such as shortest time, highest security, path tracking with the shortest detour, or
others, is equally possible. In the context of the TeamPlay project that funded a considerable part
of this work, we aim to find, for instance, the tradeoffs between time, energy, and security criteria
for a variety of use cases. Chapter 7 discusses the eventuality of solving the planning problem
with different costs.
Problem 2.5.1: Planning problem.

Consider an initial plan Γ in Definition 2.4.2. It is either composed of l stages or n stages and a shift d. The planning problem is the problem of finding the
optimal configuration of path and computations parameters ci ∀i ∈ [l]>0 or ∀i ∈ {1, 2, . . . }
under energy constraints and uncertainty at each time step t.
In the definition, there is a fixed or variable number of stages, in the sense that all the stages
are reiterated using the primitive paths in Definition 2.4.1 up until the aerial robot reaches the last
triggering point pl . Given the optimal configuration, we are further interested in the guidance
to the path and the scheduling of the computations.
2.5.2

Coverage problem

The coverage problem is the problem of finding a route that covers all the points in a given space,
avoiding the obstacles. In the literature, it is under a branch of motion planning termed CPP (H.
Choset, 2001; H. Choset and Pignon, 1998; Galceran and Carreras, 2013). Some approaches ensure
the completeness of the coverage and include algorithms optimized for mobile robots. Here, we
focus on these algorithms, including specific constraints such as turning radius and the variability
of the coverage. Furthermore, in the aerial robotics context, obstacles can be seen as areas that
the aerial robot should not consider (Cabreira, Brisolara, et al., 2019). Since there are no obstacles
in our use case to avoid physically–e.g., airports, tall buildings, etc.–we use the term no-interest
zones (NIZs). It depicts areas on the ground where the aerial robot can potentially fly but should
not perform any computation, e.g., adjacent agricultural lots or supporting infrastructure laying
on the ground. We assume that sets of vertices describe the space and NIZs. In this context,
the coverage problem is the problem of covering the space while, e.g., overflying NIZs without
computing. Chapter 7 discusses a generalization of NIZs to physical obstacles.
Problem 2.5.2: Coverage problem. Consider a finite set of vertices of a polygon to be covered
v := {v1 , v2 , . . . } and of NIZs o := {o1 := {o1,1 , o1,2 , . . . }, o2 := {o2,1 , o2,2 , . . . }, . . . }
where each vertex vi := (xvi , yvi ), ∀i ∈ |v|, oj,k := (xoj,k , yoj,k ), ∀j ∈ |o|, k ∈ |oj | is a point
w.r.t. OW . Let r ∈ R≥0 , the minimum turning radius, and p(t0 ), the starting point at the time
instant t0 , be given. The coverage problem is the problem of finding a plan Γ that covers v while

24

Chapter 2. Problem Formulation

avoiding computations over oii , starting from p(t0 ) with a turning radius greater or equal to
r ∈ R≥0 .
Chapter 5 proposes two algorithms for the problems in this section. A first algorithm generates
the coverage path, and another algorithm replans the plan in time. The replanning is energyaware. The algorithm outputs the best trajectory of the path and computations alterations for
an aerial robot with varying battery and atmospheric conditions.

2.6

Precision agriculture use case

In this section, we discuss an example of a plan for the Opterra fixed-wing aerial robot in the
precision agriculture use case. Here, we provide one possible solution to Problem 2.5.2, which we
will generalize in Chapter 5. Path-wise, the aerial robot covers a polygon with variable quality of
coverage. Computation-wise, it detects ground hazards and communicates eventual detection
with other ground-based actors. To simplify the notation, we split the plan into two sub-plans,
one containing the paths and the other the computations. We discuss the first sub-plan in Section 2.6.1 and the second in Section 2.6.2.
2.6.1

Paths sub-plan

The paths sub-plan defines the paths that form the plan. For simplicity, we assume the polygon
has four sides with four vertices v := {v1 , . . . , v4 } (it is a rectangle) and has no NIZs o := ∅.
An intuitive static plan Γ can be composed of lines connected by circles. The distance between
the lines can then be a measure of the quality of the coverage. Such an intuitive static plan is
illustrated in Figure 2.6.
We can use the intuitive plan to solve the coverage problem with a rotary-wing aerial robot
with a small turning radius. A similar pattern, termed the boustrophedon motion, is abundant
in the aerial robotics literature relative to CPP (Araújo et al., 2013; Artemenko et al., 2016; Cabreira,
Franco, et al., 2018; Di Franco and Buttazzo, 2015) and in the broader mobile robotics literature (H.
Choset, 2001; H. M. Choset et al., 2005; LaValle, 2006) where the circles are instead straight lines
parallel to the segments connecting the corresponding vertices. However, this pattern is unsuitable for a fixed-wing aerial robot such as the Opterra. Fixed-wing aerial robots have reduced
maneuverability compared to rotary-wings (Dille and Singh, 2013; Mannadiar and Rekleitis, 2010;
Xu et al., 2011, 2014) and are generally unable to fly quick turns (X. Wang et al., 2017).
We illustrate an updated version of the intuitive plan for fixed-wing aerial robots in Figure 2.7.
This latter coverage variation is similar to Zamboni motion in the literature (Araújo et al., 2013).
We term the plans in Figure 2.6 and Figure 2.7 boustrophedon-like and Zamboni-like motions
because they are similar to the robotics literature but optimized to our use case and potentially
a broad class of aerial robots with turning constraints. Indeed such constraints are commonly
treated in the aerial robotics literature (Artemenko et al., 2016; Y. Li et al., 2011; Xu et al., 2011,
ii

There might be a further strict requirement to consider obstacles as no-flight zones (NFZs) rather than NIZs,
which we discuss in the context of possible future directions.

2.6. Precision agriculture use case

y
yΓ3

yΓ1

φ1 φ3

25

φ4

φ2
xΓ1 xΓ2 xΓ4

x

Figure 2.6. An intuitive plan to cover a regular polygon with four sides composed of circles φ2 , φ4 and
lines φ1 , φ3 . To switch between the paths, the aerial robot reaches the proximity of triggering points
pΓ1 := (xΓ1 , yΓ1 ), pΓ2 , pΓ3 , pΓ4 . The dashed blue line indicates the triggering points, and the black line
is the planned flight. The rest of the polygon is covered by iterating the primitive paths and triggering
points with a shift.

2014), and similar patterns are already in other studies (Huang, 2001; Xu et al., 2014). We discuss

further the boustrophedon, Zamboni, and other motions for the coverage in Chapter 3.
The Zamboni-like motion in Figure 2.7 is composed of four primitive paths
φ1 (p(t)) := x − 10,

(2.11a)

φ2 (p(t)) := (x − 85) + (y − 10) − 5625,

(2.11b)

φ3 (p(t)) := x − 160,

(2.11c)

φ4 (p(t)) := (x − 90)2 + (y − 140)2 − 4900,

(2.11d)

2

2

where x, ys are the x- and y-coordinates of a generic point p(t). The triggering points (the points
in which proximity occurs the change of stages) are then the points
pΓ1 := (10, 10), pΓ2 := (160, 10), pΓ3 := (160, 140), pΓ4 := (20, 140).

(2.12)

The coverage problem can be solved using the paths in Equation (2.11), the triggering points
in Equation (2.12), the remaining paths φ5 , φ6 , . . . , φl , and triggering points pΓ5 , pΓ6 , . . . , pΓl
defined similarly to Equations (2.11–2.12). A generic solution for the coverage problem defined
as an iterated pattern contains the primitive paths
φi (p(t)) := x − xΓ1 − bi/4cxd ,

(2.13a)

φi+2 (p(t)) := x − xΓ2 − bi/4cxd ,

(2.13b)

∀i ∈ {1, 5, 9, . . . }. xd is a shift on the x-axis, bi/4c is the integer division. The expressions
in Equation (2.13) correspond to the generalizations of the lines in Equation (2.11a) and Equation (2.11c). The generalizations of the circles in Equation (2.11b) and Equation (2.11d) are
φi+1 (p(t)) := (x − xΓ1 − r1 − bi/4cxd )2 + (y − yΓ1 − bi/4cyd )2 − r12 ,

(2.14a)

φi+3 (p(t)) := (x − xΓ2 + r2 − bi/4cxd )2 + (y − yΓ3 − bi/4cyd )2 − r22 ,

(2.14b)

26

Chapter 2. Problem Formulation

y φ
1

φ3
φ4

yΓ3

yΓ1
xΓ1 xΓ4

x Γ2

x

φ2
Figure 2.7. Fixed-wing aerial robot plan to cover a regular polygon with four sides. The plan covers
the polygon with the same principle in Figure 2.6 but respecting turning constraints. The polygon is
covered by iterating the primitive paths (gray lines) and triggering points (dashed blue line). The black
line is the planned flight. The height and length of the polygon are yΓ3 − yΓ1 and lxd /4.

where index i is defined the same way as in Equation (2.13), along with the shift (additionally, yd
is a shift on the y-axis) and integer division. r1 > r2 > r are given radiuses of the circles φ2 and
φ4 in Figure 2.7, and r is the turning radius in Definition 2.5.2.
The triggering points can be expressed similarly with the expressions
pΓi := (xΓ1 + bi/4cxd , yΓ1 + bi/4cyd ),

(2.15a)

pΓi+1 := (xΓ1 + 2r1 + bi/4cxd , yΓ1 + bi/4cyd ),

(2.15b)

pΓi+2 := (xΓ1 + 2r1 + bi/4cxd , yΓ3 + bi/4cyd ),

(2.15c)

pΓi+3 := (xΓ1 + 2r1 − 2r2 + bi/4cxd , yΓ3 + bi/4cyd ).

(2.15d)

We note from Figure 2.7 and Equations (2.13–2.15) that yΓ3 − yΓ1 is the height of the polygon
to be covered, 2(r1 − r2 ) the distance between the covering lines (which is equal to the shift xd ),
and lxd /4 is the length of the polygon if the number of stages l is known.
The plan in Equations (2.13–2.15) is static: no path parameter allows altering the plan. We can
transform such a plan with the addition of a path parameter c4,1 relative to the radius of the
second circle φ4 in Figure 2.7
q
r2 (c4,1 ) := r 2 + c4,1 ,
(2.16)

2.6. Precision agriculture use case

27

where r < r < r1 is a given positive constant initial radius and c4,1 ∈ (r 2 − r 2 , 0]. We assume
that the highest value is thus c 4,1 = 0, the lowest is strictly higher than the difference between
the turning and constant initial radiuses squared c 4,1 > r 2 − r 2 (to respect the turning radius).
We note from the expression in Equation (2.16) that Equation (2.15d) and Equation (2.14b)
depend on the parameter c4,1 (they contain r2 , which depends on c4,1 ). They can be thereby
dynamically replanned, resulting in an alteration of the quality of the coverage. They indeed
change the distance between the survey lines. We can bound the alteration with
ci,1 ∈ [c 4,1 , c 4,1 ] =: C4,1 ⊆ (r 2 − r 2 , 0], ∀i,

(2.17)

where we assume for ease of notation that we can change the parameter in advance at any stage
(thus we use ∀i in the equation). We will see in Chapter 6 that c 4,1 is usually chosen from empirical
observations to alter the flight time in case of, e.g., sudden battery drop, while still respecting the
turning radius.
The concept is illustrated in Figure 2.8. The black line is the un-altered path until the triggering
point pΓ3 , where the path splits depending on the value of the path parameter c4,1 . The alteration
of the plan shortens or extends the flying time and thus influences the energy consumption. Since
the last path φ4 is a function of the parameter c4,1 , the correct expression for Equation (2.14b) is
φi+3 (p(t), c4,1 ) := (x − xΓ2 + r2 (c4,1 ) − bi/4cxd )2 +
(y − yΓ3 − bi/4cyd )2 − r2 (c4,1 )2 .

(2.18)

The last triggering point pΓ4 in Equation (2.15d) is likewise a function of the parameter c4,1
pΓi+3 (c4,1 ) := (xΓ1 + 2r1 − 2r2 (c4,1 ) + bi/4cxd , yΓ3 + bi/4cyd ),

(2.19)

as it depends on the radius r2 of the circle φ4 . The same applies to all the following functions
φ5 , φ6 , φ7 since these are all a function of the triggering point pΓ4 . The path φ8 is then a function
of the parameter c4,1 and c8,1 propagating the parameters for all the following paths φ9 , φ10 , φ11
and so on. We discuss further the coverage with the Zamboni-like motion in Section 5.2.
2.6.2

Computations sub-plan

In the computations sub-plan, we define the computations that form the plan. In the precision
agriculture use case, we are interested in monitoring the field in Figure 1.6, detecting ground
hazards, and communicating with other ground-based actors. We use a convolutional neural
network (CNN) implemented in a ROS node to detect the ground hazards. The CNN detection
uses image frames from a downward-facing camera mounted on the aerial robot. We assume
that there is one centralized workstation on the ground to communicate with the ground-based
actors and that the communication between the aerial robot and the centralized workstation
occurs on another ROS node, which uses the technical standard for wireless communication
IEEE 802.11 (Crow et al., 1997). It sends the detected images either unencrypted or using publickey infrastructure for encryption. We refer to these two computations as CNN and encryption

28

y

φ5 (c 4,1 )

y

φ4 (c 4,1 )

φ5 (c 4,1 )
φ4 (c 4,1 )

r2 (c 4,1 )

r2 (c 4,1 )

x

x

φ6 (c 4,1 )

(b) replanned path

Figure 2.8. Alteration of a path parameter of the fixed-wing aerial robot’s plan in Figure 2.7. The black line is the un-altered path up to the triggering point
pΓ3 , where the path can be altered with the parameter c4,1 relative to the radius r2 of φ4 . The alteration changes the distance between the survey lines
hence extending or shortening the flying time. The longest distance is then 2(r1 − r2 (c 4,1 )), the shortest 2(r1 − r2 (c 4,1 )). The same principle applies to path
parameter c8,1 for the next two survey lines, to c12,1 , and so on.

Chapter 2. Problem Formulation

(a) original path

φ6 (c 4,1 )

2.6. Precision agriculture use case

29

ROS nodes here and discuss the implementation in Chapter 6. The schedule for the CNN ROS
node is parametrized by the FPS rate at which the frames are sent from the camera and for the
encryption ROS node by a binary value that indicates whenever the encryption is enabled.
There are thus two computations parameters. A computation parameter is the FPS rate, and
another computation parameter is the encryption binary value. The CNN ROS node’s computation parameter is ci,2 , and the encryption ROS node’s computation parameter is ci,3 .
The upper and lower bounds of ci,3 are
ci,3 ∈ Si,3 := {0, 1}, ∀i,

(2.20)

the parameter value thus indicates if the encryption is active (one) or data are sent unencrypted
(zero).
For the upper and lower bound of ci,2 , we first note from the path plan in Section 2.6.1 that
during the turns the aerial robot is not surveying the polygon. We thus place different constraints
for different paths. For the circles in Equation (2.23b) and Equation (2.23d), the computations
parameters constraint sets are
ci+1,2 , ci+3,2 ∈ Si+1,2 = Si+3,2 := {0}, ∀i ∈ {1, 5, 9, . . . },

(2.21)

and thus the CNN ROS node is not searching for any hazard when it flies out of the polygon.
On the contrary, for the lines in Equation (2.23a) and Equation (2.23c)
ci,2 , ci+2,2 ∈ Si,2 = Si+2,2 := [2, 10], ∀i ∈ {1, 5, 9, . . . },

(2.22)

the CNN ROS node is detecting hazards on the ground with an FPS rate between two and ten.
Energy-wise we expect the highest configuration of computations parameters to correspond to
the highest instantaneous energy consumption. We use powprofiler, the profiling and modeling
tool that we briefly outlined in Section 1.4 and introduce in Section 4.1, to measure and model
the future energy consumption of different computations’ configurations.
2.6.3

Coverage plan with paths and computations sub-plans

The plan for the precision agriculture use case is composed of stages, containing the primitive
paths in Equations (2.13–2.14) and the parameter-dependent version in Equation (2.18). It further
contains the path parameter ci,1 , ∀i ∈ {4, 8, . . . } and the computations parameters ci,2 and
ci,3 , ∀i ∈ {1, 2, . . . }. In particular, the stages corresponding to the primitive paths are
Γi := {φi (p(t), c4,1 , c8,1 , . . . , ci−1,1 ), ci,2 , ci,3 },

(2.23a)

Γi+1 := {φi+1 (p(t), c4,1 , c8,1 , . . . , ci−1,1 ), ci+1,2 , ci+1,3 },

(2.23b)

Γi+2 := {φi+2 (p(t), c4,1 , c8,1 , . . . , ci−1,1 ), ci+2,2 , ci+2,3 },

(2.23c)

Γi+3 := {φi+3 (p(t), c4,1 , c8,1 , . . . , ci−1,1 , ci+3,1 ), ci+3,2 , ci+3,3 },

(2.23d)

∀i ∈ {1, 5, 9, . . . }. The path constraint set for the path parameter ci,1 is then in Equation (2.17),
the computation constraint set for the computation parameter ci,2 in Equation (2.22), and for

30

Chapter 2. Problem Formulation

the computation parameter ci,3 in Equation (2.20). The triggering points
pΓi (c4,1 , . . . , ci−1,1 ) := (xΓi−4 (c4,1 , . . . , ci−1,1 ) + bi/4cxd , yΓ1 + bi/4cyd ),

(2.24a)

pΓi+1 (c4,1 , . . . , ci−1,1 ) := (xΓi−4 (c4,1 , . . . , ci−1,1 ) + 2r1 + bi/4cxd , yΓ1 + bi/4cyd ), (2.24b)
pΓi+2 (c4,1 , . . . , ci−1,1 ) := (xΓi−4 (c4,1 , . . . , ci−1,1 ) + 2r1 + bi/4cxd , yΓ3 + bi/4cyd ), (2.24c)
pΓi+3 (c4,1 , . . . , ci+3,1 ) := (xΓi−4 (c4,1 , . . . , ci−1,1 ) + 2r1 − 2r2 (ci+3,1 ) + bi/4cxd ,
yΓ3 + bi/4cyd ).

(2.24d)

∀i ∈ {5, 9, . . . }. The initial points xΓ1 , yΓ1 and yΓ3 are given along the shift d = (xd , yd ), the
radius of the first circle r1 , and the last triggering point pl . The function r2 , which returns the
radius of the second circle and it is a function of the path parameter ci,1 , is in Equation (2.16). It
contains r, which is likewise given (we can estimate r from the desired distance of the covering
lines r = r1 − xd /2).
∗
The solutions to the planning problem are thus the three trajectories ci∗ (t) = {ci,1
(t),
∗
∗
ci,2 (t), ci,3 (t)}, ∀i ∈ {1, 2, . . . } that are energy-aware. Since each quadruple of stages in Equation (2.23) and triggering points in Equation (2.24) depends only on the last path parameter (of
the quadruple), we further assume that c1,1 = c1,2 = c1,3 = c1,4 and more generally
ci,1 = ci+1,1 = ci+2,1 = ci+3,1 , ∀i ∈ {1, 5, 9, . . . }.

(2.25)

Chapter 5 generalizes the plan in this section with coverage of an arbitrary polygon and derives
the optimal configuration ci∗ . Chapter 6 revisits the assumption in Equation (2.25) and the two
sub-plans in an experimental implementation of the agricultural use case.

2.7

Summary

In this chapter, we defined the planning and coverage problems. The solution to the coverage
problem is a cover tour; to the planning problem, the optimal configurations of the path and
computations parameters. Both are interconnected and require some basic concepts, including
plan and path functions. The plan is composed of stages, triggering, and final points and parameters for the replanning itself. At each stage, the robot flies a path function and computes a
schedule. Some parameters parametrize the path, and some parameters parametrize the computations. Bounds limit these parameters due to physical impediments of the computing hardware
and the aerial robot. Alternatively to defining all the stages manually, it is possible defining an
autonomous use case with some periodicity, using primitive paths and a shift. We illustrated
the concept with the precision agriculture use case. Here, we provided two sub-plans. The first
contains the paths constructed with the Zamboni-like motion for fixed-wing aerial robots with
strict turning radius constraints. The second contains the computations with the hazards detection and communication with other ground-based actors. There is one parameter to alter the
quality of the coverage with the radius in the Zamboni-like motion and two parameters to alter
the computations of the ground hazards detection and communication.

Chapter 3

State of the Art
“Even though [dynamic voltage scaling] and energy conservation for mobile robots have
been studied, the close interaction between computation and motion remains unexplored.”
— Brateman et al., 2006

n t h i s c hapter, we discuss the state-of-the-art in energy modeling and optimization of
computing hardware and mobile robots and in planning for mobile robots. There is a considerable body of knowledge in energy modeling for computing hardware, including batterypowered. When such hardware is onboard a mobile robot, studies on energy efficiency often focus
on the energy for the motion on, e.g., a planned path, and neglect the computing hardware (Ondrúška et al., 2015). Moreover, planning algorithms in robotics literature center around robot
motion planning and deal with problems such as swarms, dynamics, and uncertainty (LaValle,
2006). By illustrating several contributions applied to a variety of robots, we primarily focus
on the approaches that, similarly to ours, plan the path and schedule the computations. We
especially emphasize studies applied to mobile robots with energy constraints.
We split the chapter into multiple sections and replicate our workflow throughout the topic.
Initially, we analyzed some contributions that quantify the energy consumption of computing
hardware carried by mobile robots. Modeling the energy of these devices has laid the foundations
for our planning-scheduling energy awareness. In Section 3.1, we report our findings spanning
broadly to generic computations energy modeling. We discuss the available approaches for battery modeling and the battery modeling and optimization of the computing hardware in Section 3.2. We then discuss studies on motion planning for mobile robots generically and planning
for aerial robots in Sections 3.3–3.4. For both, we detail approaches in coverage path planning
(CPP) and the derivation of optimal coverage. Although simultaneous planning-scheduling
remains mostly unexplored (Brateman et al., 2006; Ondrúška et al., 2015; Sudhakar et al., 2020),

I

31

32

Chapter 3. State of the Art

some studies have proposed various techniques and further motivated our work. We report these
in detail in Section 3.5.
This chapter connects to the remainder of this work as follows. Here we discuss the other
literature that allowed us to derive an energy-aware coverage planning and scheduling approach
for autonomous aerial robots. Based on these findings, we propose computations and motion
energy and battery models in Chapter 4. Planning in the context of mobile robots, for aerial
robots, of the coverage and the computations and motion are the basis for the derivation of the
optimal configuration in Chapter 5. We use such configuration to replan an initial plan; to solve
the planning problem in Chapter 2. In Chapters 6–7, we report the findings and conclude the
work relating to the state-of-the-art in this chapter.

3.1

Computations Energy Modeling

There are several different energy modeling and optimization approaches for computations, usually under the topic of energy efficiency for computing hardware. Generally, energy efficiency is
critical for battery-constrained devices (V. Rao et al., 2005) and a limiting factor in improving further computing performance (Horowitz, 2014). Modern computing hardware–carried by aerial
robots that we analyze in this work–is often composed of heterogeneous elements: one or more
CPUs and a GPU as we outlined in Section 1.3. We split some of the available approaches in the
literature into different classes, depending on their modeling and optimization approach. Due to
the unpredictable nature of the heterogeneous elements, many contributions to energy modeling
observe hardware characteristics and perform physical energy consumption measurements to derive an energy model. We analyze some of these contributions first. They treat the heterogeneous
elements altogether and are of particular interest to our approach where we use heterogeneous
mobile computing hardware. We then analyze the techniques that focus on the energy of GPUs.
Finally, we analyze techniques that treat CPUs. Some of the latter are based on dynamic voltage
scaling (DVS) and dynamic frequency scaling (DFS) that scales down the supply voltage and
the frequency when there is no high computations demand (X. Chen and Touba, 2009; Flautner
et al., 2001). Most of the studies we analyze include an energy model that is either an analytical
expression (in the function of some architectural parameters of the computing hardware) or
based on regression. The studies then provide an energy optimizing technique derived from the
model: a selection of hardware parameters or a configuration of computations parameters. We
illustrate an overview of the studies we consider in Table 3.1, where we distinguish approaches
by the heterogeneous elements, the model, and the technique. We further state if a given study
use DVS and/or DFS, summarize the accuracy, and detail the experimental computing hardware
when available (mobile and non).
There are some reviews available for computations energy modeling literature: O’Neal and
Brisk (O’Neal and Brisk, 2018) summarize techniques with different computing elements and
focus on predictive modeling, emphasizing heterogeneous models based on machine learning.
O’Brien et al. (O’Brien et al., 2017) and Czarnul et al. (Czarnul et al., 2019) review energy modeling

3.1. Computations Energy Modeling

33

focusing on high-performance computing (HPC); Czarnul et al. report existing tools for energy
prediction in HPC systems and O’Brien et al. the accuracy of different models in the literature.

3.1.1

Heterogeneous elements modeling

Modern computing hardware energy modeling and optimization techniques often deal with
the heterogeneous computing elements altogether using statistical tools. Such tools are inexpensive to deploy and relatively accurate in predicting the future energy consumption of computations (Bailey et al., 2014). Although there are further optimizations available by looking
at the elements (CPUs, GPUs) separately, these are often application and hardware-dependent.
Instead, we focus on a generic computations energy model that can be used independently of
the hardware and computations under analysis.
Marowka derives a model (Marowka, 2017) for heterogeneous elements. The model uses power
metrics: the scaled speedup, performance per watt, and performance per joule. The approach
increases energy efficiency by choosing the configuration of the heterogeneous components–for
instance, by enabling computations only on CPU cores–and hence, investigates the impact of
different architectural choices on energy efficiency. In particular, the model is used to analyze the
energy of three processing schemes: symmetric, asymmetric, and simultaneous. The former uses
merely a multicore CPU. Asymmetric processing scheme both CPU and GPU. The software
benchmark on this scheme consists of running a program on one of the computing elements
at a time. The latter processing scheme is similar to the previous, but the software benchmark
runs simultaneously on CPU and GPU. Our work extends the model and builds a computations
model of the simultaneous processing scheme.
Bailey et al. derive a more sophisticated statistical model (Bailey et al., 2014) relying on multivariate linear regression for heterogeneous elements. The model eases the selection of the application’s configuration that maximizes performance under given power constraints. It is trained
offline with a small set of benchmarks and works across multiple devices. The overall flow of
the proposed approach is composed of two stages. The first stage is the offline training stage
that utilizes a small training set of benchmarks split into clusters. The model is built then with a
regression per each cluster. After this stage, follows the online predicting stage. The latter uses
the model to predict the power and performance of a large set of applications, opposed to the
relatively small number of benchmarks in the offline stage. Our work similarly models a subset
of samples and infers properties of the entire search space. Opposed to Bailey et al., our work
further focuses on mobile computing hardware.
Goraczko et al. develop a resource model (Goraczko et al., 2008) for heterogeneous mobile
devices and consider both the time and power of a given run-time mode. Goraczko et al. use
the term mode rather than configuration (in Marowka and Bailey et al.) and a CPU with a
microcontroller as a heterogeneous platform instead of a CPU with a GPU. Energy-wise, the
resource model uses DVS as some other models in Section 3.1.3 but accounts for heterogeneous
elements. The approach models multiple processors with a state machine. It is involved in a
software partitioning problem to derive the optimal mode via integer linear programming (ILP).

GPU
CPU

Technique
Selection
Configuration

Accuracy
91%a

Goraczko et al.

Analytical

Configurationb

-

(3) (3)

Ma et al.

-

Configuration

-

3

3

Calore et al.
Yang et al.
Hong and Kim
Wu et al.
Collange et al.
Luo and Suda
Leng et al.
Lee and Brooks
Takouna et al.
Reddy et al.
Nikov et al.
Nunez-Yanez and Lore
Walker et al.

Analytical
Analytical
Analytical
Regression (ML)
Analytical
Analytical
Regression
Regression
Analytical
Regression
Regression
Regression

Selection
Pruning
Selection
Selection
Selection
Selection
Selection
Selection
Selection
Selection
Selection
Selection

91.06%c
90%d
88.87%d
88.35%d
95.7%e
93%f
94%g, d
92–95%h
95%
96.2–97.2%

7
7
7
7
7
7
3
7
7
3
3
7
3

[3]
7
7
[3]
7
7
3
7
3
3
3
7
3

7
7

7
7

Platform
Intel Core-i7-960 (CPU), NVIDIA GTX 280 (GPU)
AMD A10-5800K (CPU), Radeon HD7660D (GPU)
ARM7 OKI ML675003 (CPU), TI MSP430F1611
(microcontroller)
AMD Phenom II X2 (CPU), NVIDIA GeForce 8800
(GPU)
ARM Cortex-A15 (CPU), NVIDIA GK20A (GPU)
NVIDIA GTX280 (GPU)
AMD Radeon HD 7970 (GPU)
NVIDIA G80, G92, GT200 (GPU)
NVIDIA Tesla C2050 (GPU)
NVIDIA GTX 480, Quadro FX5600 (GPU)
Intel Xeon E5540 (CPU)
ARM Cortex-A15 (CPU)
ARM Cortex-A15, Cortex-A7 (CPU)
ARM Cortex-A9 (CPU)
ARM Cortex-A15, Cortex-A7 (CPU)

Mobile

7
7
3
7
3
7
7
7
7
7
7
7
7
3
3
3
3

a

accuracy under-limit against oracle with perfect knowledge
optimization problem solved with ILP
c
average accuracy for both power and time models against measuring hardware
d
accuracy against built-in power monitors (if the accuracy is reported for multiple hardware or benchmarks, it is average)
e
accuracy against median error, leveraging only the most relevant samples
f
accuracy of 95% of the predictions
g
accuracy on 60 workloads
h
accuracy against related work

Chapter 3. State of the Art

Table 3.1. Comparison of different computations energy models: the model is either an analytical expression or a regression. The energy optimization
technique is the selection of some architectural parameters or computations configurations. Scaling is split into DVS and DFS: (3) scaling is used only in
the model, not in the optimization technique. [3] values are changed statically (or manually where appropriate such as in Marowka).
b

34

Heterogeneous

Model
Analytical
Regression

DVS DFS

Marowka
Bailey et al.

3.1. Computations Energy Modeling

35

The optimization occurs over an energy cost and with given deadline constraints. The intuition
of formally defining the problem of deriving the optimal mode is similar in our work. We expand
further by merging the path with the planning-scheduling energy awareness.
Ma et al. propose a holistic approach (Ma et al., 2012) for heterogeneous elements that achieves
energy efficiency by splitting and distributing the workload among the heterogeneous elements.
Ma et al. then use frequency scaling for the CPU and GPU and DVS for the CPU. GPU-side, the
frequency is determined with a lightweight machine learning algorithm. Energy in this approach
is analyzed by empirical means, using two power meters. The testbed under analysis–NVIDIA
GeForce GPUs and AMD Phenom II CPUs–has no built-in power monitors. Ma et al. do not
consider mobile computing heterogeneous hardware nor derive a model for the energy. Nevertheless, the approach is of interest for energy implications of heterogeneous elements.
Our initial approach (Seewald, Ebeid, et al., 2019) relied on external meters rather than internal
power monitors. Calore et al. developed a similar technique (Calore et al., 2015) to measure the
energy efficiency of HPC systems. Both our initial and Calore et al.approaches are tested on
the NVIDIA Jetson TK1 computing hardware without built-in power monitors, as opposed to
other computing hardware we analyze.
Recently, approaches are emerging to model the energy consumption of machine learning algorithms. Yang et al. developed a computations-specific modeling approach (Yang, Y.-H. Chen, Emer,
et al., 2017) in this context, while García-Martín et al. surveyed several studies (García-Martín et al.,
2019), motivated by the lack of appropriate tools to build and measure power models in existing
machine learning suites. García-Martín et al. describe the state of the art of energy estimation for
convolutional neural networks (CNNs) and data mining, whereas Yang et al. evaluate an energy
model of deep neural networks (DNNs) based on a network’s bitwidth, sparsity, and architecture. The methodology applies exclusively to DNNs but has been extended to CNNs (Yang, Y.-H.
Chen, and Sze, 2017) in an optimization loop to reduce the computations energy consumption.
Mittal then proposes a survey (Mittal, 2019) to optimize and evaluate neural networks on some
of the embedded platforms that we use in this work (NVIDIA Jetson TK1 and TX2).
Kim et al. reviewed (Y. G. Kim et al., 2018) the operating system-level energy management
techniques for heterogeneous elements. Although the review does not deal with energy models, it lists energy management techniques such as power-saving scheduling and details aspects
including Quality of Service (QoS) we use to define computations execution boundaries.

3.1.2

GPU features modeling

GPUs are used in several applications despite increasing energy demands (Mittal and Vetter, 2014)
due to their high computational resources (Kasichayanula et al., 2012). It is hence unsurprising
that for computations energy modeling, GPUs have their own modeling approaches. Here we
discuss some studies of interest to our work. Mittal and Vetter and Bridges et al. propose extensive
reviews of the available methodologies (Bridges et al., 2016; Mittal and Vetter, 2014). None is,
however, focused on mobile computing hardware.

36

Chapter 3. State of the Art

Hong and Kim derive an energy model (S. Hong and H. Kim, 2010) for GPU features. The
contribution consists of an integrated power and performance prediction model to derive the
optimal number of active cores for a given application to achieve energy savings (S. Hong and
H. Kim, 2010). The model is GPU specific: it consists of an analytical expression that estimates the
GPU power and time in function of some parameters. Opposite to our work, it does not model
the energy of the entire platform, nor is deployed on mobile computing hardware. Nevertheless,
it achieves high accuracy in terms of GPU power and time prediction.
Wu et al. derive another model (G. Wu et al., 2015) with a similar focus on GPU features.
The approach uses machine learning techniques for performance and estimates the power from
real GPU hardware. In particular, Wu et al. train a neural network with different performance
counters for various GPU configurations. They use a collection of applications, deriving the
optimal values of the counters. The approach works across multiple hardware; data gathered
from one hardware estimate the power and performance of other GPU hardware. However,
Wu et al. focus purely on GPU modeling. Moreover, machine learning is an energy-expensive
computation itself (García-Martín et al., 2019; Yang, Y.-H. Chen, Emer, et al., 2017), deterring
similar approaches in our work, where we aim to preserve the energy to the greatest extent.
Collange et al. propose an empirical approach (Collange et al., 2009) for energy evaluations of
GPUs during various computations in the CUDA environment. The approach measures and
analyzes how computations impact instantaneous energy consumption. It observes a significant
energy impact of memory accesses and generally analyzes the energy cost of parallel GPU computations. The work by Collange et al. thus aims to derive the optimal memory configuration of
a given benchmark. However, it does not use the measured data to calibrate a model for energy
estimation nor focus on mobile computing devices.
Contrary to Collange et al.’s approach of pure empirical measurements, Luo and Suda (C. Luo
and Suda, 2011) propose an analytical model for energy and performance estimation of GPUs.
The model contains execution time and energy consumption prediction sub-models, where the
latter follows from the former. The final analytical model for the energy estimation multiplies
the execution time and the estimated power derived using an analytical expression. The work
further observes the energy implications of a given benchmark but does not propose an energy
optimization technique. The accuracy analysis shows a strong correlation between observations
and the analytical model. We also derive an analytical expression further motivated with empirical observations of energy data and employ linear regression. We then focus on heterogeneous
elements and mobile computing hardware.
Leng et al. propose a model (Leng et al., 2013) based on a performance-per-watt metric for
GPUs. Developed for general-purpose GPU (GPGPU) powered devices specifically, it is composed of multiple stages. An initial model is validated with some empirical measurements and
eventually refined. The contribution suggests an integrated power and performance modeling
framework, which inputs a configuration to define micro-architectural and component parameters. It is then used in a feedback-driven optimization loop with the GPU. In our approach,
we similarly input configuration to the model but specify the computing hardware computations rather than architectural parameters. We use the model output in an optimization loop but

3.1. Computations Energy Modeling

37

extend this latter stage together with the path. Computation-wise, we use both heterogeneous
elements.

3.1.3

CPU features modeling

Numerous other contributions model the CPU energy specifically and investigate how to lower
the power (Chowdhury and Chakrabarti, 2005; I. Hong et al., 1999; J. Luo and Jha, 2001) by some
system-level optimization techniques. These include DVS, DFS, multiple asymmetric cores (such
as the ARM big.LITTLE architecture), and power gating (Walker et al., 2017). They usually
incorporate information about configuration parameters into the scheduler (Seewald, Schultz,
Ebeid, et al., 2021a) and focus on homogeneous hardware.
Lee and Brooks provide extensive coverage of regression modeling and propose a regressionbased model (B. C. Lee and Brooks, 2006a,b) for microprocessors. The model uses a small number
of samples of both the power and performance in a joint architecture-computations search space.
The entire search space is sampled uniformly at random, an approach that allows identifying
trends and trade-offs between the parameters (B. C. Lee and Brooks, 2006a). The results show high
accuracy even with a relatively small number of samples. We likewise use a regression model in our
computations energy modeling approach but cover all the heterogeneous elements. Nonetheless,
Lee and Brooks’ approach is of interest to evaluate the accuracy of regression techniques and
distributions of samples. Depending on the configuration space, we sample the computations
uniformly using a linear or exponential distribution of samples (we specify the sampling distance
in a configuration file), whereas Lee and Brooks sample architectural parameters.
Takouna et al. propose statistical multicore CPU power models (Takouna et al., 2011) based
on the average running frequency and the number of active cores. The models use multivariate
linear regression commonly to other computations energy models in this section. Although
insightful in terms of multicore CPU power models, the approach does not model GPUs nor
heterogeneous elements and is tailored on virtualized serves, opposed to mobile computing
hardware that we focus on in this work. Moreover, Takouna et al. do not consider computations
configurations in the regression but a variable selection of architectural parameters.
Reddy et al. propose an empirical CPU power model (Reddy et al., 2017) that uses measured
data and simulates the energy consumption of a quad-core ARM Cortex-A15 processor and
gem5–a full-system architectural performance simulator. Reddy et al. evaluate the model against
sixty workloads reporting high accuracy. To collect the measurements, the model uses builtin power monitors in the ODROID-XU3 platform. Our model shares compatibility with this
computing hardware but is not simulator-dependent. We further evaluate the model on multiple
heterogeneous computing hardware such as NVIDIA Jetson TK1, TX2, and Nano platforms.
Nunez-Yanez and Lore and Nikov et al. develop other models (Nikov et al., 2015; Nunez-Yanez
and Lore, 2013) for mobile computing hardware. These models use hardware event registers
and capture the state of the CPU under a representative workload. The latter study proposed
by Nikov et al. is of particular insight, as they focus on ODROID-XU3 computing hardware;
the model has three modeling stages: data collection of a benchmark running on the platform

38

Chapter 3. State of the Art

occurs in the first stage. The second and third stages are performed offline on a different architecture. They process the collected data (in the second stage) and generate the model (in the third
stage) (Seewald, Schultz, Ebeid, et al., 2021a). The model further deals with ARM big.LITTLE
architecture. We use these models to evaluate the performance of our computations energy modeling in Section 6.1.4.
Walker et al. propose a run-time model (Walker et al., 2017) that uses performance monitoring
counters (PMCs) for mobile computing hardware, implemented on mobile CPUs such as ARM
Cortex-A7 and Cortex-A15. Walker et al. use the architectural performance simulator gem5 comparably to Reddy et al. and the ODROID-XU3 computing hardware to both Reddy et al. and
Nikov et al. The approach is to build a linear regression for a given CPU power prediction experiment. Although the study considers CPU-powered computing hardware only, it is insightful
in terms of proposed statistical rigor in building run-time CPU power models.

3.2

Battery Modeling

This section describes battery modeling approaches and focuses on battery models to be used
for both the computing hardware and the aerial robot. There are several models for this purpose,
each with its advantages and disadvantages. Usually, battery models derive the battery state of
charge (SoC) (Xia et al., 2015), at various levels (Deng et al., 2017; Kurzweil and Scheuerpflug, 2021;
Kurzweil and Shamonin, 2018; Sundén, 2019). Physical models use ordinary and partial differential
equations, accurately predicting the battery evolution in time (R. Rao et al., 2003) with a considerable time and computational cost (Doyle et al., 1993; Lotfi et al., 2017; Marcicki et al., 2013; Moura
et al., 2017). Hybrid models are similar but less accurate, predicting the battery with less computational complexity (T. Kim and Qiao, 2011; T. Kim, Qiao, and Qu, 2019). Empirical models use a
set of trials (Pedram and Q. Wu, 1999; Syracuse and Clark, 1997), similarly to some computations
energy models in Section 3.1. Mixed models use empirical data to derive parameters for analytical
expressions (Rakhmatov and Vrudhula, 2001; R. Rao et al., 2003). Abstract models use techniques
such as the time evolution of an equivalent electrical circuit (Benini et al., 2001; Gold, 1997; Hasan
et al., 2018; X. Hu et al., 2012; S. Lee et al., 2008; Xing et al., 2014) comparably to hybrid models (T.
Kim and Qiao, 2011) but with less computational complexity. Sometimes referred to as equivalent
circuit models (ECMs), they have compelling trade-offs concerning analytical insight, accuracy,
complexity, and ease of implementation (R. Rao et al., 2003). They are the models of our choice
for battery modeling. ECMs use different constructs, including RC (resistor-capacitor) circuits
for dynamic loads, resistors for internal resistances, and other components (Hamza and Ayanian,
2017). Their complexity depends on the level of detail required and the parameters involved in
modeling. The parameters are usually estimated with empirical data (C. Zhang, K. Li, et al., 2014).
Rao et al. survey (R. Rao et al., 2003) the state of the art in battery modeling.
Xing et al. and Hasan et al. propose such abstract models (Hasan et al., 2018; Xing et al.,
2014) based on an equivalent electrical circuit. The first model (Xing et al., 2014) utilizes an
unscented Kalman filter to tune parameters at each sampling step, and the second (Hasan et al.,
2018) estimates the SoC with an eXogenous Kalman filter (Johansen and Fossen, 2017). There

3.3. Planning

39

are multiple others who focus on equivalent electrical circuits for battery modeling (He et al.,
2011; Hinz, 2019; Madani et al., 2019; Mousavi G. and Nikdel, 2014; C. Zhang, Allafi, et al., 2018;
F. Zhang, Liu, and Fang, 2009; F. Zhang, Liu, Fang, and H. Wang, 2012).

We will see a concrete
implementation of a circuit termed “Rint” (He et al., 2011; Hinz, 2019; Mousavi G. and Nikdel,
2014) in Section 4.2.1 for a Li-ion aerial robot’s battery.
Rao et al. (V. Rao et al., 2005) propose a battery model for computing hardware specifically. The
approach consists of an abstract stochastic model that uses Markov processes with probabilities
related to the physical characteristics of the battery (Panigrahi et al., 2001). Rao et al. further
improve the accuracy of the model, including physical battery characteristics. The approach is
insightful in terms of evaluating models for computing hardware. Indeed our approach relies
similarly on an abstract model, whereas we focus on an equivalent electrical circuit which requires
less battery-specific knowledge for modeling. We can then model the SoC with little information
of what battery the aerial robot mounts.
Zhang et al. propose a modeling approach for smartphones (L. Zhang et al., 2010) that consists
of an automated technique based on the battery discharge behavior and voltage sensors. The
technique models the power using a multivariate regression (similarly to our approach and many
computations energy models in Section 3.1) and the battery using an equivalent electrical circuit.
Although the analysis is limited to smartphones, it provides insights into automated modeling
techniques for computing hardware. We have similarly derived an automated technique for
computations energy and battery models in Chapter 4.
Benini et al. propose a battery model (Benini et al., 2001) for the low-power design of computing hardware. Discrete-time and intended for system-level design environments, the model
is also derived from an equivalent electrical circuit. Although specific to the design of computing hardware applications, it evaluates different battery types. A first Li-ion implementation is
extended to various others with both non and rechargeable cells.

3.3

Planning

Planning algorithms for mobile robots include broad and diverse topics. Energy-wise, the algorithms select an energy-optimized trajectory (Mei, Y.-H. Lu, Y. C. Hu, et al., 2004), e.g., by maximizing the operational time (Wahab et al., 2015). However, many studies apply to a limited number
of robots (C. H. Kim and B. K. Kim, 2005) and focus exclusively on planning the trajectory (H.
Kim and B.-K. Kim, 2008), despite compelling evidence for the energy consumption also being
significantly influenced by computations (Mei, Y.-H. Lu, Y. C. Hu, et al., 2005; Ondrúška et al.,
2015). In the remainder of this chapter, and before discussing the studies in mobile robotics that
deal with computations and motion energies altogether, we detail planning in the literature. We
are interested in planning and scheduling, and specifically, in coverage planning of a given space.
We discuss the available literature on coverage planning for mobile robots later in this section
and emphasize relevant studies for aerial robots in Section 3.4.1. There are multiple approaches
in this sub-topic of motion planning (Cabreira, Brisolara, et al., 2019; H. Choset, 2001), including

40

Chapter 3. State of the Art

studies that derive an energy-efficient cover (Cabreira, Franco, et al., 2018; Wei and Isler, 2018). In
Section 3.3.3 and Section 3.4.2, we discuss these studies respectively for mobile and aerial robots.

3.3.1

Motion planning

Within simple motion planning instead of the derivation of a cover, Mei et al. propose an energyefficient approach for mobile robots distinguishing the two energy consumers–the computations
and motion energies. In (Mei, Y.-H. Lu, Y. C. Hu, et al., 2004), they focus on motion energy optimizations and analyze the computations energy in the following iteration of their work (Mei, Y.-H.
Lu, Y. C. Hu, et al., 2005), discussed in Section 3.5. In the former, a path plan and a velocity schedule form a “motion plan”. The path plan is similar to ours in Definition 2.4.2, and the velocity
schedule contains velocities, accelerations, and decelerations along the route. The study analyzes
the most energy-efficient motion plan by evaluating the energy cost of turns and accelerations
and differentiating between the travel and motors velocities. The experimental setup consists
of Palm Pilot Robot Kit with polyurethane omnidirectional wheels and three MS492MH DC
servo motors. It relies on external power monitors and five batteries: one 9 and four 1.5 volt batteries for the control circuit and motors. The energy efficiency is measured in terms of squared
meters per jouls. Here, Mei et al. report an improvement of 50% by using an energy-optimized
path plan.
The study has encouraged our initial analysis in many respects. It is the first we encountered
analyzing motion and computations energies (Mei, Y.-H. Lu, Y. C. Hu, et al., 2005). However,
Mei et al. do not consider optimizations in terms of path variations. They focus on straight
lines, spirals, and the energy cost of turns, whereas we vary CPP within given limits. They do
not explicitly address planning-scheduling energy awareness but propose foundations for future
studies. We have optimized the coverage plan in Section 2.6.1 (and Section 5.2.2) compared to
the traditional coverage planning that uses, e.g., boustrophedon motion (LaValle, 2006). We do
not consider a velocity schedule due to the physical constraints of airborne systems. Nevertheless,
we also optimize the plan against sudden accelerations. Indeed the boustrophedon-like motion
requires sudden decelerations in contrast to the Zamboni-like motion for fixed-wing crafts.
Dressler and Fuchs undertake a different approach (Dressler and Fuchs, 2005) to energyefficient motion planning. The approach models the energy of motion plans for specific tasks–the
term is not to be confused with computations–where, e.g., the mobile robot has to explore and
supervise unknown surroundings. Dressler and Fuchs propose a future planning direction based
on energy control and battery management for efficient tasks allocation but do not investigate
further. The study models energy-consuming parts of the robot with corresponding characteristic curves. Dressler and Fuchs observe a linearly approximable curve for the SoC for sub-tasks
of a given task, such as movement and wireless communication. Although we do not explicitly
model the energy of a given task, we similarly formulate the plan as a set of paths and computations in Definition 2.4.2. The study has thus inadvertently introduced the differentiation between
computations and motion energies. The reported sub-tasks energy models are relative to one of
the two components: wireless communication to a computation that transfers data airborne; the

3.3. Planning

41

movement to a path to reach a location. Dressler and Fuchs have further developed the approach,
focusing on sensor networks (Dressler and Dietrich, 2006; Fuchs et al., 2006).
The majority of other contributions focus on optimizing motion planning to increase power
efficiency. There are several studies that survey the available literature for mobile robots’ planning, along with some textbooks (H. M. Choset et al., 2005; LaValle, 2006). Notably, LaValle’s
textbook (LaValle, 2006) groups planning algorithms literature and focus on robot motion planning. Juliá et al. propose an extensive survey (Juliá et al., 2012) of the most important methods for
motion planning for autonomous exploration and mapping of unknown environments. The
survey presents different techniques, classifying for multi-robot coordination level and integration with simultaneous localization and mapping (SLAM) algorithm.

3.3.2

Coverage path planning

In autonomous mobile robotics use cases, it is often required to explore every location in a given
elemental region (Cao et al., 1988); this problem is defined in the literature as the CPP problem. In
this section, we briefly discuss some surveys that deal with CPP in mobile robotics generically. We
detail approaches that involve aerial robots in this sub-topic of motion planning in Section 3.4.1.
Our work uses CPP to cover a space in Problem 2.5.2.
CPP is related to the covering salesman problem, a variation of the famous traveling salesman
problem (TSP) (E. M. Arkin and Hassin, 1994). The salesman visits a neighborhood of each city,
minimizing the travel length (E. M. Arkin and Hassin, 1994), and passes over all the points rather
than through all the neighborhoods (H. Choset, 2001). This problem is sometimes referred to
as the lawnmower problem (Galceran and Carreras, 2013) and is proven to be NP-hard (E. M.
Arkin, S. P. Fekete, et al., 2000). Early studies solve the CPP problem using a heuristic with no
coverage guarantee (H. Choset, 2001). For instance, Arkin and Hassin propose simple heuristicbased algorithms for constructing the tours (E. M. Arkin and Hassin, 1994). There have emerged a
variety of approaches ever since. Arkin appears in other studies that propose a continuous version
for the covering salesman problem algorithm (E. Arkin et al., 1993; E. M. Arkin, S. P. Fekete, et al.,
2000; S. Fekete et al., 1994). These studies solve the problem with lawn moving and milling
algorithms (E. M. Arkin, S. P. Fekete, et al., 2000). Many approaches either implicitly or explicitly
use cellular decomposition to guarantee the coverage (exact or approximate), decomposing the
space to cover into cells (H. Choset, 2001). The overall solution to the CPP problem is then the
union of the solutions of the cells (H. Choset, 2001).
To cover each cell in a cellular decomposition, the robot can use simple back and forth motion
parallel to the cell’s boundaries–often referred to as boustrophedon motion (LaValle, 2006)–and
reduce the CPP to motion planning between the cells (H. Choset, 2001). The cells are geometric
structures that represent the robots’ free space and are decomposed into trapezoids in a popular
class of solutions under the name of boustrophedon decomposition (since they are related to
the boustrophedon motion). In this decomposition, the algorithm splits the cell in case of an
obstacle (change in connectivity) (H. Choset, E. Acar, et al., 2000). Choset et al. propose exact
cellular decomposition methods (H. Choset and Pignon, 1998), complemented with different

42

Chapter 3. State of the Art

motions in the following instance (H. Choset, E. Acar, et al., 2000) (e.g., spiral, spike, diamond
pattern, and others). Within the cellular decomposition method, some approaches (E. U. Acar
et al., 2002; H. Choset, E. Acar, et al., 2000) work with the concept of Morse function to indicate
the cell boundaries location, dealing with generalized obstacles. We adapt the boustrophedon
decomposition proposed by Choset et al. with the Zamboni-like motion in Section 5.2.1. Grid
decomposition is another way of solving the coverage in the literature (Gabriely and Rimon, 2002;
Shnaps and Rimon, 2016; Wei and Isler, 2018; Zelinsky et al., 1993), which divides the space into
equally sized cells. Other approaches are based on graphs (Cheng et al., 2019) or derive an optimal
coverage (Huang, 2001; T.-K. Lee et al., 2011; Y. Li et al., 2011; Wei and Isler, 2018; Xu et al.,
2011). The choice of the approach depends on the practical application (Wei and Isler, 2018). The
optimal coverage approaches are often variations of known studies but with a cost that has to be
optimized (Galceran and Carreras, 2013). Our work fits into this latter class of approaches. In the
remainder of this section, we discuss two surveys that deal with CPP and further detail relevant
studies on optimal coverage later on.
Choset proposes a survey (H. Choset, 2001) of literature on coverage for robotics. The survey
classifies the studies according to the decomposition algorithm. The classification includes heuristic and cellular decomposition-based algorithms (approximate, partial-approximate, or exact).
Choset reports that many algorithms for CPP with some guarantee in terms of either optimality or completeness are based on cellular decomposition. Approximate cellular decomposition
algorithms described by Choset correspond to grid-based algorithms in other studies.
It is the case in Galceran and Carreras’ survey (Galceran and Carreras, 2013) of CPP approaches.
The survey classifies the algorithms among the others in online and offline classes. The former
relies on stationary information under a known environment and the latter on sensor measurements to sweep the space (Galceran and Carreras, 2013). Like Choset, Galceran and Carreras
report that most coverage planning algorithms decompose the space in sub-regions called cells.
The survey is extensive in terms of reviewed literature. It compromises studies focusing on cellular decomposition, cellular decomposition based on critical points of Morse functions, graphs,
and grids algorithms. The work further surveys some approaches for natural landmarks detection
and robots with contact sensors. It covers methodologies operating in rectilinear and 3D environments, for optimal coverage, for multiple robots, and based on reduction of the localization
error.

3.3.3

Optimal coverage

Huang analyzes an optimal coverage methodology based on cellular decomposition. The
study (Huang, 2001) emphasizes the cost of performing turns, utilizing round turns similar to the
boustrophedon-like motion. To derive the coverage, Huang minimizes the sum of sub-region
altitudes–a metric related to the sweep direction of a sub-region. Figure 3.1 illustrates the principle, where different sweeping directions produce a different number of turns. Huang proposes
the methodology for both convex and non-convex shapes and uses dynamic programming for

3.3. Planning

43

p(t0 )

p(t0 )
p(tl )

(a) same sweep direction

p(tl )

(b) different directions

Figure 3.1. An example (Huang, 2001) showing that different sweep directions for sub-regions in a
cellular decomposition algorithm produce a coverage with an optimized number of turns; the robot
moves from point p(t0 ) to p(tl ) and in (b) has almost half the turns of (a).

the optimal direction in the coverage. The approach performs better than other approaches and
is insightful in terms of analyzing the coverage optimality. We similarly try to optimize the turns.
Arkin et al. focus (E. M. Arkin, Bender, et al., 2001, 2005) on optimal coverage and, similarly
to Huang, consider the length of the tour with the number of turns. Both Arkin et al. and
Huang remark that in many routing problems, the turns dominate the cost, with the robot
being required to decelerate (E. M. Arkin, Bender, et al., 2001). Arkin et al.’s studies are insightful
in terms of algorithmic rigor. They prove that coverage planning with turn costs is NP-complete
even when the objective is just to minimize the turns. They propose various approximation
algorithms to compute nearly optimal covering tours. However, the two studies and Huang’s
study are inconclusive in terms of nonholonomic robot constraints. They do not consider aspects
such as the radius of the turn nor replanning in case of, e.g., external interferences affecting the
feasibility of the original plan. The latter scenario can happen when an aerial robot suffers a
sudden battery drop flying a given optimal tour.
Shnaps and Rimon propose a solution to this problem, focusing on robotics scenarios explicitly. In the study (Shnaps and Rimon, 2016), a robot covers an unknown environment with a strict
battery constraint. Starting from a given point, the robot equipped with position and obstacles
sensors navigates the environment and eventually covers the entire space. In a battery discharge
event, it returns to the starting point to recharge the battery. Shnaps and Rimon model the energy
cost with the path length. Although insightful in terms of coverage planning for battery-powered
robots, the approach does not account for aerial robots. Indeed in this latter class, the robots
would require to land to recharge or replace the battery. Wei and Isler also consider the eventuality of strict energy constraints for mobile robots and revisit Shnaps and Rimon’s approach.
They propose an algorithm (Wei and Isler, 2018) restricted to axis-parallel motion generalized for
arbitrary polygons. The approach is tested on aerial robots but is limited to rotary-wing crafts.
In both Shnaps and Rimons’s and Wei and Isler’s studies, the methodology divides the space
into equally sized cells in a grid, and the energy optimality is considered within CPP rather than
planning-scheduling energy awareness.

44

3.4

Chapter 3. State of the Art

Planning for Autonomous Aerial Robots

For what concerns planning for aerial robots, Popović et al. propose a study (Popović et al., 2017)
for planning and subsequent replanning to satisfy dynamic constraints. The study addresses
uncertainty with a noise-dependent model, including a time budget. Popović et al. plan the path
online, combining evolutionary optimization and global viewpoint selection. They validate the
approach with a precision agricultural use case to detect weeds. Although the proposed use case
has similarities with ours, it does not account for different aerial robots nor involves planningscheduling energy awareness. Furthermore, the use case does not require complete coverage,
making it unsuitable for some applications we consider, such as hazards detection. Hayat et al.
derive an approach (Hayat et al., 2017) based similarly on evolutionary optimization. It plans tasks
of multiple aerial robots (the notion of task refers to a specific action rather than computation)
in a search and rescue use case. The approach has similar limitations as Popović et al.
Many other studies in planning for aerial robots under some energy constraints limit to energyaware motion planning (Kreciglowa et al., 2017; Morbidi et al., 2016; X. Wang et al., 2017). They do
not consider CPP nor disturbances. Kreciglowa et al. focus on the best trajectory between two
hovering configurations in terms of energy (Kreciglowa et al., 2017). Morbidi et al. generate energyoptimal paths solving optimal control problems (OCPs) to obtain the angular accelerations of
four electrical motors of a quadrotor rotary-wing aerial robot (Morbidi et al., 2016). Wang et al.
propose a study (X. Wang et al., 2017) of motion planning applied to fixed-wing aerial robots.
The approach passes through a set of waypoints by satisfying a given constraint on curvature.
Two surveys (Dadkhah and Mettler, 2012; Goerzen et al., 2010) summarize approaches for aerial
robotics planning. The earlier survey (Goerzen et al., 2010) emphasizes a classification based on
differential constraints, grouping the motion planning algorithm with and without differential dynamics. The survey observes a lack in approaches dealing with uncertainty, whereas the
later survey (Dadkhah and Mettler, 2012) analyzes these explicitly. It groups the motion planning
approaches by the class of uncertainty, e.g., vehicles’ dynamics uncertainty, environmental uncertainty, etc. In the former, the survey proposes studies based on optimal control and artificial
intelligence, and in the latter, on mapping.

3.4.1

Aerial coverage path planning

In the context of aerial robots, the survey (Galceran and Carreras, 2013) proposed by Galceran and Carreras that we discussed in Section 3.3 focuses on optimal coverage (Xu et al., 2011)
and multi-robot coverage (Ahmadzadeh et al., 2008; Araújo et al., 2013; Barrientos et al., 2011;
Maza and Ollero, 2007). Our work comes into the intersection of optimal coverage and coverage with aerial robots. Indeed in our coverage planning, we refine a plan in-flight to achieve
energy-aware behavior.
Cabreira et al. propose a survey (Cabreira, Brisolara, et al., 2019) that covers CPP exclusively for
aerial robots. The study classifies the algorithms using the classification introduced by Choset (H.
Choset, 2001) and Galceran and Carreras (Galceran and Carreras, 2013) from Section 3.3. It fo-

3.4. Planning for Autonomous Aerial Robots

45

cuses on the shape of the coverage area and reports the performance metrics such as the path
length, coverage time, and the number of turning maneuvers. Cabreira et al. focus on single and
cooperative strategies for exact cellular decomposition and report the type of information used
for the decomposition (full or partial). Remarkably, they analyze studies based on genetic algorithms and ant colony optimizations and focus on different covering strategies. They describe
the Zamboni motion.
Motions are similarly analyzed in Araújo et al.’s work (Araújo et al., 2013). It details the boustrophedon (that appears under the name “lawnmower”), Zamboni, spiral, spiral-like, modified
boustrophedon, modified Zamboni (these are different from boustrophedon-like and Zambonilike motions), and Dubins path motions.
Nam et al. propose an approach (Nam et al., 2016) for CPP for aerial robots that generates
the covering tour offline. The methodology consists of a grid decomposition method, which
visits the cells with a wavefront algorithm–a specialized version of the Dijkstra algorithm that
optimizes the number of stages to reach the goal (LaValle, 2006). Nam et al. generate the optimal
path between given points in space but do not focus on optimal criteria. Indeed experimentally,
the results are not optimized w.r.t., e.g., the number of turns. Furthermore, Nam et al. do not
deal with replanning nor account for energy explicitly, and the planning happens before the
flight. Moreover, the approach focuses on rotary-wing aerial robots.
Sadat et al. propose an approach (Sadat et al., 2014) for non uniformly shaped areas distributed
into clusters. The methodology is to cover adaptively, depending on the distributions of the
regions of interest in the space. Sadat et al. use coverage trees for the purpose (a structure where
the child nodes cover the same area as the parents but with higher resolution) and propose
different strategies to visit the tree (breadth-first, depth-first, and shortcut heuristic). Although
insightful in defining the coverage area sparsely, the approach does not account for the aerial
robot’s battery nor discusses other aerial robots other than the rotary-wings.

3.4.2

Optimal aerial coverage

Di Franco and Buttazzo propose an energy-aware CPP for aerial robots. The study (Di Franco and
Buttazzo, 2015) focuses on energy and other requirements, such as the completeness of the coverage and resolution. The energy model is generic for a given aerial robot. It outputs the energy
consumption as a function of velocity and operating conditions, using an interpolating curve of
the power measurements. These curves are derived with the robot flying in several phases (during maximum acceleration and deceleration, horizontal flight, climbing, descending, hovering,
and turns). In an extension (Di Franco and Buttazzo, 2016) of the original study (Di Franco and
Buttazzo, 2015), they cover a polygon with the boustrophedon motion and consider the quality
of the coverage with varying distances between the lines. Furthermore, the energy model is planspecific–different paths have different analytical expressions. Our model in Section 4.3 is generic,
once trained with enough measurements. Nonetheless, the study is insightful for defining the
energy cost of a given coverage and for analyzing the energy effect of variations in the coverage
quality. The experimental setup compromises an IRIS rotary-wing aerial robot, a GoPro camera

46

Chapter 3. State of the Art

mounted on a gimbal stabilizer, and a PX4 flight controller (PX4, n.d.). The systems are powered
with a 3S 11 volts and 5.5 amperes per hour lithium polymer battery (LiPo) battery. The aerial
robot is not equipped with mobile computing hardware for computations, and the study does
not consider other classes of aerial robots.
Concerning other related approaches for aerial CPP, Li et al. propose a study (Y. Li et al., 2011)
based on an enhanced cellular decomposition method. The approach minimizes the number
of turns, showing that they are less efficient from energy, duration, and tour length points of
view. The turns are already considered in the generic CPP by Arkin et al. and Huang (E. M.
Arkin, Bender, et al., 2001, 2005; Huang, 2001). For complex polygons, Li et al. propose a convex
decomposition algorithm, based on a greedy recursive method. To connect the decomposed subregions, the authors propose a minimum traversal algorithm of a weighted undirected graph.
The approach is complete in terms of algorithmic analysis. Li et al. provide the algorithms, analyze their complexity, and simulate the coverage on polygons of various shapes. They show the
optimality in terms of turns, nonetheless, they do not consider further requirements for different
aerial robots, such as the turning radius.
Mannadiar and Rekleitis and Xu et al. propose studies (Mannadiar and Rekleitis, 2010; Xu et al.,
2011, 2014) on a near-optimal complete coverage methodology, using a sequence of waypoints.
The methodology (Mannadiar and Rekleitis, 2010) was first presented by Mannadiar and Rekleitis
and extended to nonholonomic robots (Xu et al., 2011, 2014) by Xu et al. It uses the cellular
decomposition with an arbitrary number of obstacles. To derive the coverage order, the cells are
stored in a Reeb graph–an encoding for cyclic paths where critical points are vertices and cells
are edges (Fomenko and Kunii, 1997)–that is visited via the Chinese postman problem (Eiselt and
G. Laporte, 2000). The resulting path ensures that cells are not traversed more than twice and that
the robot returns to the starting point. Xu et al. analyze possible planning strategies for fixedwing aerial robots and, notably, affirm that this latter class of robots lack the maneuverability
needed to follow a sharp-turned path. To this end, Xu et al. append a turning segment to the
path by adding curlicue orbits at turns (Xu et al., 2014); whereas we incorporate the turning
maneuver in our coverage planning rather than embedding external segments.
There are several other approaches for energy-aware aerial coverage. Cabreira et al. and Artemenko et al. propose studies (Artemenko et al., 2016; Cabreira, Franco, et al., 2018) in this direction,
focusing on photogrammetry in localization use cases. Cabreira et al. propose spiral coverage for
some polygon shapes and alter the velocity to achieve energy savings. Artemenko et al. propose
a boustrophedon motion with smoothed turns using Bézier curves. Another study provides an
efficient coverage using different motion patterns for specific locations such as urban areas (Dille
and Singh, 2013) but does not derive a generalized methodology. Some studies deal with optimal
coverage deriving approaches (Bouzid et al., 2017; Valente et al., 2013) for rotary-wing aerial robots
using interesting novel algorithms to find the optimal tour in a graph. In particular, Valente et al.
use harmony search–a meta-heuristic algorithm based on musical harmony (Geem, 2009)–and
Bouzid et al. use a genetic algorithm.
Generally, the studies in this section do not deal with planning-scheduling energy awareness
nor in-flight replanning. We take these aspects into account in our coverage planning.

3.5. Planning Computations with Motion

3.5

47

Planning Computations with Motion

There are some approaches that deal with planning-scheduling energy awareness in the robotics
research literature. Table 3.2 summarizes the most relevant to ours. We discuss these approaches
in the remainder of this chapter.
Sudhakar et al. examine the trade-off between motion and computation energies for mobile
robots in their recent study (Sudhakar et al., 2020), focusing on robots with similar motion and
computations energies. In the study, the robot moves on a path with a given length and velocity
and, computations-wise, computes a specific number of nodes. Sudhakar et al. first derive an analytical expression for energy prediction that incorporates the path’s length and velocity and the
number of computations’ nodes. The approach they propose consists of an algorithm for anytime planning–a planning approach that identifies an initial feasible plan then refined towards
optimal (Karaman, Walter, et al., 2011). The algorithm eventually stops the refinements when it
estimates computations energy exceeding the potential savings in terms of motion energy (Sudhakar et al., 2020). To derive a path, the algorithm uses Bayes estimation on the edges of a graph
in a sampling-based path planning algorithm–probabilistic roadmaps (PRM*) widely used in
practice (Karaman and Frazzoli, 2011; LaValle, 2006). The study motivates our investigation and
proposes an initial step towards further analysis. Nevertheless, it lacks rigor in deriving an energy
model, and it does not account for battery SoC. Notably, Sudhakar et al. emphasize the importance of considering both the motion and computations for robots’ energy-awareness; we share
similar findings except for the study’s claimed primate in analyzing trade-offs between motion
and computations energies. By a closer inspection of the scientific literature, other studies have
emerged in this direction. Mei et al., Sadrpour et al., and many others propose studies that deal
with mobile robots motion and computations energies (Brateman et al., 2006; Mei, Y.-H. Lu, Y. C.
Hu, et al., 2005; Mei, Y.-H. Lu, Y. C. Hu, et al., 2006; Sadrpour et al., 2013a,c; W. Zhang and J. Hu,
2007). Recent contributions include studies (Lahijanian et al., 2018; Ondrúška et al., 2015) carried

by Ondrúška et al. and Lahijanian et al.
Mei et al., which we already analyzed for their contribution to motion planning in Section 3.3,
have proposed a study (Mei, Y.-H. Lu, Y. C. Hu, et al., 2005) analyzing both motion and computations energies. The study differentiates the microcontroller and embedded computer the mobile
robot carries for a more flexible robot design. To this end, Mei et al. derive an energy model
from empirical data and show that the motion accounts for less than 50% of the total power
consumption. Motivated by this finding on Pioneer 3DX ActivMedia mobile robot–Pioneer
mobile robots from Adept MobileRobots were popular at the time of publication within the
research community (Anguelov et al., 2004; Erickson, 2003; Lemay et al., 2004)–they propose
real-time scheduling and dynamic power management to reduce the power consumption. The
latter dynamically adjusts power states (e.g., DVS, DFS, and peripherals selection) of components
without compromising overall performance (Mei, Y.-H. Lu, Y. C. Hu, et al., 2005), and the former
schedules computations energy-wise. The study is of particular interest as they quantify the computations’ contribution to the overall energy expenditure of mobile robots. We further extend
the study; it was indeed one of the starting points of our analysis. Mei et al. do not implement

48

Mei et al.
Brateman et al.
Zhang et al.
Sadrpour et al.
Ondrúška et al.
Lahijanian et al.
Ho et al.
Sudhakar et al.

(3)
7
3
(3)
3
7
3
3

Class
ground
ground
ground
ground
ground
ground
ground
ground

Robot
Pioneer 3DX
Pack-Bot UGV
ARC Q14
ARC Q14
Pioneer 3DX
-

Planning-scheduling
DVS, DFS, peripherals selection
DVS, DFS, velocity
hardware frequency, velocity
peripherals selection
perception (path following)
localization
navigation (waypoints)
anytime planning

Energy model
regression
analytical
analytical
regression, Bayesian
analytical
analytical
analytical
analytical

7
7
7
7
7
(3)a
7
7

Approach
greedy
optimization
optimization
greedy
greedy, optimization
Pareto front
RL
greedy

Ours

3

aerial

Opterra fixed-wing

coverage path planning

regression, differential

3

otpimization

Replan.

Bat.

a

The approach does not account explicitly for the battery. However, it derives some implications of different trade-offs w.r.t. the battery SoC.

Chapter 3. State of the Art

Table 3.2. Different methodologies in the literature for planning-scheduling energy awareness against ours (last line). The studies are ordered by ascending
date. Replan. indicates that the planning-scheduling runs online (e.g., in-flight). Bat. that the approach accounts for the battery. (3) that the approach is
“hypothesized”.

3.5. Planning Computations with Motion

49

the proposed techniques nor focus on planning within battery constraints–a research gap we are
filling with our energy-aware coverage planning and scheduling. Mei et al. have extended their
analysis in future instances (Mei, Y.-H. Lu, Y. Hu, et al., 2005a,b; Mei, Y.-H. Lu, Y. C. Hu, et al., 2006)
to CPP using multiple robots with both time and energy constraints. They have then solved
repeated coverage (Mei, Y.-H. Lu, C. Lee, et al., 2006) but have not implemented computations
scheduling nor focused on coverage replanning. This latter aspect is of particular interest to aerial
robots.
Brateman et al. propose an approach (Brateman et al., 2006) on the intersection of modeling techniques for CPUs, which we discuss in Section 3.1.3, and planning computations and
motion for mobile robots. The methodology varies the computing hardware’s frequency and
voltage via DFS and DVS and the motor’s speed for energy efficiency. To find the best trajectory
of the frequency, voltage, and speed over time, Brateman et al. formulate a nonlinear optimization problem (NLP) that they then solve using numerical optimization methods. The predicted
energy is an analytical expression derived via probabilistic analysis that the methodology employs as an optimization cost within a time constraint. There are many more approaches that
employ optimization techniques for energy-efficiency of computations and motion in mobile
robotics (Lahijanian et al., 2018; Ondrúška et al., 2015; W. Zhang and J. Hu, 2007). Zhang et al. vary
the robot’s speed and the computing hardware’s frequency using optimal control on a random
horizon. To this end, they transform an optimal control problem (OCP) into a nonlinear optimization problem (NLP) and solve the latter using a standard numerical optimization approach.
The OCP has an analytical expression of the frequency and speed as the cost (W. Zhang and J. Hu,
2007). Interestingly, they also derived an analytical solution to the OCP for some simplified costs
and found up to 30% energy savings compared to the heuristics methods. Like Brateman et al.
and Zhang et al., we derive an OCP for replanning the coverage in Chapter 5 but vary the coverage path and the schedule on the computing hardware rather than the frequency, voltage, and
speed. The intuition behind our more complex planning is that by scheduling and replanning
appropriately, we can ensure coverage despite external adversities.
Sadrpour et al. focus on mission energy prediction–the energy needed to complete a given set
of tasks by the robot traveling some paths while interacting with the environment (Sadrpour et al.,
2013a)–for unmanned ground vehicles (UGVs). In their two studies (Sadrpour et al., 2013a,c),
Sadrpour et al. propose two prediction approaches depending on a priori mission knowledge
(i.e., constant power drain of static components, driving style, road rolling resistance, road grade
information, and vehicle internal resistance). In case of no a priori knowledge, they propose linear
regression and Bayesian estimation otherwise. Sadrpour et al. report the findings on the energy
prediction using PackBot UGV (Yamauchi, 2004): the computations have an order of magnitude
lower consumption than motion. Notably, Sadrpour and other researchers shared some findings
in later studies (Ersal et al., 2014; Sadrpour et al., 2013b) in the direction of UGVs performing CPP.
Although the studies and their later iterations focus on energy modeling, they propose a future
instance in dynamic mission decision-making. When the energy exceeds a reasonable threshold,
the UGV might, e.g., revise the initial plan or tune energy-expensive components (Sadrpour et al.,
2013a). Our replanning shares a similar principle of tuning the plan to accommodate energy

50

Chapter 3. State of the Art

expenditure. We further focus on computational aspects, as in the mobile robots under our
study–and nonetheless, in recent energy-efficient robotics platforms–the motion energy has the
same order of magnitude as computations energy (Sudhakar et al., 2020).
More recently, Ondrúška et al. proposed a study (Ondrúška et al., 2015) to reduce energy consumption by scheduling perception at given times while traveling a path. The study focuses
on Oxford Robotics Institute (ORI) ARC Q14 mobile ground-based robot–a robotic platform
used mainly for research in planetary exploration rovers (Yeomans et al., 2017). The robot follows
a predetermined path and accounts directly for computations energy by scheduling the perception so that it remains within a margin from the path. For the scheduling itself, Ondrúška et al.
derive two algorithms. A greedy algorithm guarantees feasibility by employing a simple heuristic,
and a belief planning algorithm uses optimal control to provide energy-efficient schedules on a
given horizon. The approach considers path following rather than CPP, yet it is of interest in
many respects. Firstly, Ondrúška et al.’s algorithm is based on optimal control. It is similar to
ours based on output model predictive control (MPC). Secondly, the algorithm runs on a finite
horizon. We employ the same technique for replanning. Finally, the approach further motivates
our planning: Ondrúška et al. report a saving of 11.5% using a power-saving scheduler on the
robot. Our methodology alters both the schedule and the path for aerial CPP.
Lahijanian et al. have further extended Ondrúška et al.’s work and proposed a framework (Lahijanian et al., 2018) for resource-performance trade-offs exploration. The methodology consists
of finding a schedule for mobile robots under a given resource budget using quantitative multiobjective verification and controller synthesis. This latter is a technique that starts from constraints such as time and energy and produces a set of optimal achievable trade-offs via a Pareto
front (Forejt et al., 2012). Although insightful in selecting the best schedule, the approach does
not account for replanning, whereas in our work, an initial plan accounts for the highest achievable performance. It is then replanned both path- and computations-wise in an energy-aware
fashion. Lahijanian et al. also use the ARC Q14 robot.
Recent contributions in planning-scheduling energy awareness include the work (D.-K. Ho et
al., 2018, 2019a,b) by Ho et al. The methodology varies the navigation on a set of waypoints and
the schedule using reinforcement learning (RL). Concerning the motion energy, Ho et al. derive
variations of controller frequency and travel velocity of a ground-based mobile robot. Whereas
for the computations energy, they derive variations of schedules frames and resolution rates
within specific QoS. Similar to Mei et al., the experimental setup consists of Pioneer 3DX ActivMedia mobile robot. Although the methodology derives plans-schedules online, the approach
does not model the battery explicitly nor focuses on aerial robots.

3.6

Summary

This chapter discussed the state of the art in topics ranging from heterogeneous computing hardware energy modeling to planning-scheduling energy awareness. Initial sections are dedicated
to past approaches in energy modeling, focusing on heterogeneous elements such as CPUs and
GPUs. Follows the literature for battery modeling of both the computing hardware and the

3.6. Summary

51

aerial robot, and studies for the planning of mobile robots with an emphasis on approaches for
CPP and optimal coverage. Within aerial robots, the chapter details relevant contributions for
both motion planning and CPP and the derivation of an optimal aerial cover. Finally, the chapter
compromises studies that, similarly to ours, deal with planning-scheduling energy awareness by
accounting for computations and motion energies.

Chapter 4

Energy Models
“Robots require energy to operate. Yet they only have access to limited energy storage
during missions.”
— Ondrúška et al., 2015

n e rg y is an essential aspect of many autonomous mobile robotics scenar(Mei, Y.-H. Lu, Y. C. Hu, et al., 2005) and often a limiting factor to improving computing
performance (Horowitz, 2014). In the previous chapters, we emphasized the growing importance
of both computations and motion energy components. Indeed, limited energy availability against
the high computing performance requirements of autonomous aerial robots is the motivation
for the planning-scheduling energy awareness in this work. For this purpose, we first need an
accurate energy model that predicts future energy consumption. We derive such a model in this
chapter, providing different energy models predicting the energy of the motion and computations and the battery state of an aerial robot flying a coverage plan. For the former two, we first
derive a way to accurately predict the energy spent running a given set of computations on the
computing hardware. We then merge the resulting computations energy model with a motion
energy model using some empirical observations. The energy output of the motion model is the
input of the battery model, which predicts the battery evolution.
We saw in Chapter 3 some computations energy and battery models and discussed energyaware approaches for aerial (and mobile) robots performing coverage path planning (CPP) or
motion planning generally. In this chapter, we then use the previous literature and derive the
energy models for our use case, an autonomous aerial robot employed in coverage planning,
monitoring an agricultural field. Although applied to a given use case, the approach is general
in terms of the proposed methodology. In Section 4.1, we derive the model for the energy of
computations based on regressional analysis. In Section 4.2, we provide a battery model based
on an equivalent electrical circuit, and in Section 4.3, we derive a model for the motion that

E ios

53

54

Chapter 4. Energy Models

incorporates the computations energy model. We then use the models in Chapter 5 to plan and
schedule altogether.
This chapter connects to the remainder of this work as follows. We provided some energy
implications of autonomous aerial robots in Chapter 1 and formulated the basic constructs in
Chapter 2, including the concepts of computations and motion energies. We then use all the
information we discussed in the previous chapters for the energy models in this chapter. In
Chapter 5, we use the models to replan the coverage and schedule the computations in an energyaware fashion. The results, including the outcomes of the models and future implications, are
in Chapters 6–7.

4.1

Energy Model of the Computations

This section describes the computations energy model, which predicts the energy consumption
of a given configuration of computations. In Section 2.1, we parametrized the computations
by a set of σ computations parameters ciσ := {ci,ρ+1 , . . . , ci,ρ+σ }, where ρ is the number of
path parameters. We parametrize the computations that impact the overall energy consumption
(see Definition 2.1.1). For instance, in the agricultural use case, the computation object detection.
Parametrization indicates these computations that can be scheduled via our planning-scheduling
energy awareness, and run on, e.g., a lower/higher rate requiring lower/higher power. Practically,
this means that if the system is composed of σ computations, the configuration of computations
parameters ciσ (T ) for each stage i over time T := [t0 , tl ] (where t0 , tl are respectively the first time
instant and the time instant when the aerial robot reaches the final point pΓl in Definition 2.3.2)
is a schedule of the computations. Chapter 5 details ways to derive the optimal schedule, whereas
this section predicts the energy of any possible configuration. In the remainder, we derive an
energy model that maps any choice of parameters ciσ to the power at any t ∈ T , extending the
past work on energy modeling for heterogeneous computing hardware.
In Section 4.1.1, we summarize the heterogeneous elements modeling from Section 3.1.1 and
outline our approach, which consists of two layers. We detail the layers in Sections 4.1.2–4.1.3
and describe an automated modeling tool we developed in Section 4.1.4 along with its configuration specification in Section 4.1.5. The tool works well for computing hardware equipped with
internal power meters, yet, some computing hardware does not provide any. We discuss how to
model such hardware also in Section 4.1.4.
4.1.1

Model for the heterogeneous elements

We saw in Chapter 3 that traditionally, models for computing hardware focus on a specific computing element, such as CPU or GPU, or model the elements heterogeneously. The models
provide a regression function (measuring the power consumption over time), analytical (using
some architectural parameters), or other expressions to infer future energy consumption. The
regression functions, analytical or other expressions might depend on low-level architectural parameters and be employed in an energy-efficient selection of such parameters, including voltage

4.1. Energy Model of the Computations

55

and frequency. Alternatively, they might depend on high-level parameters (such as the computations parameters ciσ in this work) and be employed in an energy-aware configuration of software
(and hardware), e.g., the tasks allocation on the CPU cores. An expression depending on a configuration is more common for heterogeneous models, as we summarized in Table 3.1. We focus on
these models; in Chapter 1 and formally in Definition 2.1.1, we assumed the aerial robot caries heterogeneous computing hardware for energy-demanding computations. We refer to Section 3.1
for an extensive discussion of energy modeling approaches in the literature for CPUs and GPUs
powered and heterogeneous computing hardware.

Figure 4.1. NVIDIA Jetson Nano heterogeneous computing hardware for computations energy modeling. The hardware in the image includes the Jetson Developer Kit board that the Nano heterogeneous
board is mounted on and has a total size of 100x80 millimeters and a weight of approx. 140 grams.

The approach in this section is based on our work (Seewald, Schultz, Ebeid, et al., 2021a) on
heterogeneous computing devices’ energy modeling. It is generic, modeling virtually a wide range
of computing hardware with little user effort. We use statistical methods to derive a regressionbased model segmented into two layers. In the first, the measurement layer, we map the time to
the power, and in the second, the predictive layer, we map the computations configuration ciσ (t)
to the power. To generate a model, our approach inputs a user-defined configuration file, which
simply specifies the computations along with the computations parameters constraint sets Si,k in
Definition 2.3.1, per each computation k ∈ [σ ]>0 and stage i ∈ [l]>0 (or [n]>0 if the computations
are specified along the primitive paths and reiterated when the aerial robot reaches pΓn with a
shift d). From the configuration, an automated modeling tool termed powprofiler measures
the energy consumption of a discrete set of configurations ci,ρ+j ∈ Si,j , per each computation
parameter j ∈ [σ ]>0 and derives a set of measurement layers. The tool allows merging then the
measurement layers into a predictive layer via linear regression. As heterogeneous computing
hardware, we use different devices, such as NVIDIA Jetson Nano, TX2, and TK1 in Figures 4.1–
4.2 and Figure 4.4 and ODROID XU3 in Figure 4.3. We summarize the computing hardware
that we explicitly consider in this work in Table 4.1. These devices are commonly employed in

56

Chapter 4. Energy Models

Figure 4.2. NVIDIA Jetson TX2 heterogeneous computing hardware mounted on the Jetson Developer
Kit board as Nano in Figure 4.1 with a total size of 170x170 millimeters and a weight of approx. 512
grams.

Figure 4.3. ODROID XU3 heterogeneous computing hardware with a total size of 94x70 millimeters
and a weight of 70 grams.

robotics literature to power complex computations. For instance, Jetson TX2 has been employed
in path planning (Dharmadhikari et al., 2020; Ryou et al., 2018), simultaneous localization and
mapping (SLAM) (Aldegheri et al., 2019), and object detection via convolutional neural networks
(CNNs) (Andrew et al., 2019). Jetson Nano in SLAM and CNNs (Alexey et al., 2021; T. Peng et al.,
2019; L. Wang et al., 2020), and ODROID XU3 (Bhat et al., 2019; Giusti et al., 2016; Papachristos
et al., 2015) and Jetson TK1 (Gong et al., 2016; Holper et al., 2017) in similar applications. Although
we report some in this paragraph, heterogeneous computing hardware power computations in
many other mobile robots use-cases.

4.1. Energy Model of the Computations

Hardware
NVIDIA Jetson Nano
NVIDIA Jetson TX2
NVIDIA Jetson TK1
ODROID XU3

57

CPU

GPU

-A57

NVIDIA Maxwell

-A57

NVIDIA Pascal

-A15

NVIDIA Kepler

-A15, -A7 MALI

Memory
Sensor
4 GB LPDDR4 RAM
3
8 GB LPDDR4 RAM, 32 GB NV 3
1 GB DDR3L RAM, 16 GB NV
7
2 GB LPDDR3 RAM
3

Table 4.1. Mobile computing hardware explicitly analyzed in this work. All the CPUs are ARM Cortex.
All the hardware provides random access memory (RAM), and some a non-volatile (NV) memory. All
the boards have energy measuring capabilities except NVIDIA Jetson TK1.

4.1.2

Measurement layer

The measurement layer is the basic building block of the computations energy model: one or
more measurement layers form the predictive layer–the model output–which we describe in
Section 4.1.3. For a specific computations parameters configuration ciσ (t), the measurement
layer maps the time t ∈ [t0 , tf ] := T ⊂ R>0 (the final and initial time instants t0 , tf are
given) to the power measured in watts, the energy measured in joules (watts per unit of time),
and the battery state of charge (SoC) expressed in percentages. The measurement layer thus
provides a primitive model for ciσ of power, energy, and SoC over a given time interval. The
derivation of the layer is automated with powprofiler, the modeling tool that we describe in
detail in Section 4.1.4, which outputs the layer after executing ciσ on T . Additionally, the model
(and the powprofiler tool) can output the triplet of metrics from the measurement layer per
each energy sensor: some computing hardware that we analyze indeed provide different sensors
for different computing elements, i.e., NVIDIA Jetson TX2, Nano, and ODROID XU3 boards
all provide energy-sensing capabilities for CPU, GPU, overall, and/or memory.
Let us define the measurement layer formally, assuming there are one or more energy sensors
or other energy measuring devices (these include, e.g., internal power resistors or shunt resistors,
amperometers, and multimeters).
Definition 4.1.1: Measurement layer.

Given a specific energy measuring device, computations
parameters configuration ciσ (t), and an initial and final time instants t0 , tf such that t ∈ T :=
[t0 , tf ], the measurement layer is the function g : Z>0 × Zσ × T → R3 . It returns the power in
watts, energy in joules, and SoC in percentages of an energy measuring device, a configuration
of computations parameters, and time interval.
The measurement layer physically samples the computing hardware for T and returns the metrics. Sampling-to-completion is also possible, where a configuration runs up until it terminates
rather than for a given interval. In the latter eventuality, T is ∅.
As an instance of the measurement layer, let us return briefly to the precision agriculture
use case (the aerial robot detects ground hazards and communicates the detections to a ground
station). The computations parameters in Section 2.6.2 are ci,2 , the frames per second (FPS) rate,
and ci,3 , encryption or no encryption of the robot—ground station data link. The configurations
ci,2 (t) ∈ Si,2 , ci,3 (t) ∈ Si,3 have any value within the constraint sets in Equations (2.20–2.22).
The constraint sets are the same in each stage i in the plan Γ except for the circles where the

58

Chapter 4. Energy Models

aerial robot travels the turns out of the boundaries, and the detections are inhibited. To build
the measurement layer, we can discretize the configurations with a given δ1 , δ2 for parameters
ci,2 and ci,3 , where δs are the sampling steps. The measurement layer is then built by sampling
the power for T , one for all the possible configurations
ciσ := {ci,2 , ci,3 | ∀j, k ∈ Z, c i,2 + jδ1 ∈ Si,2 , c i,3 + kδ2 ∈ Si,3 }.

(4.1)

A value can be, e.g, δ1 = 2, δ2 = 1, so that there are ten configurations and consequently ten
measurement layers (there are two possible configurations of parameter ci,3 with δ2 and five of
ci,2 with δ1 ). The powprofiler tool automatically builds the layers, storing the results in commaseparated values (CSV) files (we see further the tool in Section 4.1.4). Equation (4.1) provides a
way to sample the search space linearly, but other sampling strategies are equally possible. These
include random sampling with the condition merely ci,j ∈ Si,j and exponential sampling with
ciσ := {ci,2 , ci,3 | ∀j, k ∈ Z, δ1 j ∈ Si,2 , δ2 k ∈ Si,3 },

(4.2)

where δ1 , δ2 are now bases. Currently, the powprofiler tool supports automated linear and
exponential sampling and complex sampling formed by different sampling strategies (Seewald,
Schultz, Ebeid, et al., 2021a), e.g.,
ciσ := {{ci,2 | ∀k ∈ Z, c i,2 + kδ1 ∈ Si,2 }, {ci,3 | ∀k ∈ Z, δ2 k ∈ Si,3 }}.

(4.3)

Parameter ranges (Si,2 , Si,3 ) choice is dictated by the range at which the computations run at
runtime, whereas δs choice is made so that the modeling terminates in a reasonable amount of
time (Seewald, Schultz, Ebeid, et al., 2021a).
With the measurement layer described in this section, we know the power and other energy
metrics of the sampled configurations. However, we want to predict the energy consumption
for any configuration of parameters in the constraint sets (and not only the sampled ones). We
address this latter requirement in the next section, merging the measurement layers via linear
regression.
4.1.3

Predictive layer

The predictive layer describes coarse-grained metrics, e.g., the power over FPS rate, mapping them
to the metrics from the measurement layer, thus providing energy data for each configuration
of parameters. To this end, it uses the set of measurement layers, building a two-by-two linear
regression between consecutive layers. In the precision agriculture use case example from the
previous section, there are ten measurement layers. The predictive layer consists of a regression
between data points {ci,2 , ci,3 } for all the possible computations parameters (we recall that
a measurement layer corresponds to a sampled computations configuration), opposed to the
sampled ones.
Definition 4.1.2: Predictive layer.

parameters configuration

ciσ (t)

Given a specific energy measuring device and computations
the predictive layer is the function g : Z>0 × Zσ → R3 . It

4.1. Energy Model of the Computations

59

returns the power in watts, energy in joules, and SoC in percentages of any configuration of
parameters within the constraint sets.
Analogously to the measurement layer, there can be various energy measuring devices, resulting in multiple triples of energy, power, and SoC, one per device. The predictive layer returns
the same metrics of the measurement layer in Definition 4.1.1, without physically sampling the
computing hardware but using the stored measurement layers. Indeed due to a potentially large
search space in computational energy modeling, it is critical to infer the energy properties of the
entire search space from a subset of all the possible samples (Bailey et al., 2014; B. C. Lee and
Brooks, 2006a,b). The linear regression to infer such properties utilizes a method that we term
the approximation method (Seewald, Schultz, Ebeid, et al., 2021a). It builds a linear regression
between two adjacent data points rather than merely for all the data points. Indeed we do not
assume an apriori knowledge of the computations energy evolution with explicit models for all
the data points such as linear or exponential, but rather model the energy linearly on tuples of
data points (Seewald, Schultz, Ebeid, et al., 2021a).
Given an (unsampled) configuration ciσ , the predictive layer is approximated with
g(ciσ ) = (g(dciσ e, T1 ) − g(bciσ c, T2 ))(ciσ − bciσ c)/(dciσ e − bciσ c) + g(bciσ c, T2 ),

(4.4)

where dciσ e, bciσ c are the two adjacent measurement layers of the computations configuration
ciσ (e.g., if we use δ1 = 2 in Equation (4.1), ciσ with just the parameter c i,2 < ci,2 < c i,2 + δ1 has
bciσ c equal to two and dciσ e to four), and T1 , T2 are the two time intervals in the measurement
layer for configurations bciσ c, dciσ e respectively.
4.1.4

The powprofiler tool

The powprofileri tool (Seewald, Schultz, Ebeid, et al., 2021b) is an automated profiling and modeling utility that generates the measurement layers for a discrete set of possible computations
configurations (automated profiling) and merges these layers later, providing the predictive layer
(modeling). We proposed an early version of the tool earlier in our work (Seewald, Schultz, Ebeid,
et al., 2021a; TeamPlay Consortium, 2019a), which we extended to support per-component energy
modeling in a dataflow computational network (Seewald, Schultz, Roeder, et al., 2019), and integrated (Zamanakos et al., 2020) with Robot Operating System (ROS) middleware (Quigley et al.,
2009). The tool is written in C++ and distributed under the popular open-source MIT license.
It supports all the computing hardware explicitly mentioned in this work, i.e., NVIDIA Jetson
TX2, Nano, and TK1 and ODROID XU3 in Table 4.1. It is predisposed further for extensibility supporting possibly any Linux-based computing hardware that provides energy measuring
devices or that alternatively provide a mechanism to measure the energy with an external device.
The tool uses an object-oriented programming approach (Stroustrup, 1988; Wegner, 1990),
where each computing hardware has its own class that inherits from the class sampler the functions get_sample and dryrun. The former function returns a power measurement from all the
The latest version of the tool can be retrieved from https://github.com/adamseew/powprofiler, whereas
the version 1.0.2 released on October 2021 in this work from https://doi.org/10.5281/zenodo.5562457.
i

60

Chapter 4. Energy Models

measuring devices (power for the measurement layer in Section 4.1.2 for, e.g., CPU, GPU, overall,
etc.), and the latter simply attempts to read from the measuring devices returning a boolean value
indicating if the attempt was successful. The tool contains classes sampler_tx2, sampler_nano,
and sampler_odroid already implementing the necessary utilities to store the models from the
computing hardware that we explicitly analyze.

Figure 4.4. NVIDIA Jetson TK1 heterogeneous computing hardware mounted on a Toradex Ixora
carrier board with a total size of 125x95 millimeters and a weight of approx. 160 grams.

The function get_sample further relies on a specific data type: vectorn. Each value in vectorn
has its flag, indicating the metric and the measuring device. For instance power_cpu, soc_gpu are
two flags indicating that the metric is for the power and the measuring device is of the CPU
and the SoC of the GPU respectively. The enumeration vectorn_flags contains all the flags.
The tool stores a set of vectorns sampled at discrete intervals (powprofiler is highly personalizable, allowing to change the frequency via the configuration specification in Section 4.1.5) in
another structure termed pathn. Each pathn corresponds to a measurement layer in Section 4.1.2.
The tool further provides mechanisms, such as the overload of the constructor, to automatically
load the layers from a previously stored CSV file. Internally the tool stores pathns (the measurement layers) in a wrapper, model_1layer, which contains information such as the parameters
configuration and the set T ; model_2layer is then another internal structure that returns the
predictive layer in Section 4.1.3. In this setting, NVIDIA Jetson TK1 computing hardware does
not include any energy measuring device. powprofiler uses an external device in the sense that
it can import data in the model directly through the overload of the constructor into a measurement layer (and therefore a set of measurement layers into a predictive layer). An early instance
of our work (Seewald, Ebeid, et al., 2019) consisted of three hardware units for the purpose of
this latter energy modeling of the TK1 computing hardware, similarly to another study in the
literature (Calore et al., 2015). The main hardware unit in the early instance was the computing hardware itself, whereas the others were a multimeter and a workstation that interprets the

4.1. Energy Model of the Computations

61

data from the multimeter for subsequent processing by the tool (Seewald, Schultz, Ebeid, et al.,
2021a).
The tool further interoperates with ROS middleware, generating a measurement layer for
configurations of computations implemented in the middleware. It can be imported in an existing project as a library; in C/C++ by simply adding the preprocessor’s directive #include with
<powprof/async.h>. In a setting where an energy-expensive ROS node is a computation (we
implement both the CNN detection and encryption from Section 2.6.2 as ROS nodes in Chapter 6), the user simply instances model_1layer with a specific computations configuration and
calls function start to start profiling, and stop to stop. The latter then returns a measurement
layer. The modeling can, in this fashion, happen online by running different computations configurations and generating computations energy models corresponding to a realistic run-time
computations load.
Alternatively to ROS middleware, the tool runs from a configuration specification, detailing
each computation, the constraint sets, and the δs, along with some other, model-specific details.
We discuss the configuration specification in the next section.

4.1.5

Configuration specification

The configuration specification is simply a way to communicate the plan Γ to the powprofiler
tool, along with some other model-specific details. To run powprofiler with a configuration specification, the user invokes the command powprofile, followed by the path of the configuration.
If, for instance, the configuration specification is stored in config.cfg in the current directory,
the user invokes powprofile config.cfg. The tool then parses the configuration specification
to reconstruct the computations configurations and the constraint sets, to automatically generate
measurement layers and consequently provide a predictive layer. The configuration specification
starts with the line [settings] that indicates to powprofiler all the following lines are a configuration specification. In the lines that follow, it contains a set of key-value properties delimited by
an equal character. The property frequency indicates the frequency measured in hertz the tools
samples at (e.g., with ten hertz, the property is set as frequency=10). The property h is the integration step the battery model integrates at (we discuss further the battery model in Section 4.2).
The property directory indicates the path where the models are stored. Additionally, the tool
allows an arbitrary number of comments and white spaces, and the parser does not require a
specific indentation. Any data followed by char # are ignored up to the next line.
The following set of lines specifies the configurations ciσ for each computation parameter ci,ρ+1 , ci,ρ+2 , . . . , ci,ρ+σ , starting with the line [components], followed by
[component.computation] where computation is a string uniquely identifying each computation (there cannot be two computations with the same string, but the name is arbitrary). Per
each computation, the configuration file then contains another set of key-values properties. The
property src indicates the executable source of the computation. If powprofiler runs with a
configuration specification rather than as a library, we assume the source accepts as arguments
the configurations along with other eventual arguments. The following properties then specify

62

Chapter 4. Energy Models

these arguments, ordered as they appear in the configuration specification. The property range
indicates that the argument is a computation parameter. Let us assume the parameter is ci,ρ+1 .
If it is sampled linearly as in Equation (4.1), the value contains c i,ρ+1 , c i,ρ+1 , and δ delimited by
commas, where δ is the step to sample ci,ρ+1 in a reasonable amount of time in Equation (4.1).
If it is sampled exponentially as in Equation (4.2), the value contains the same data as before,
but for δ that is expressed pow(δ ) and δ is the base. Additional properties are then: fixed that
indicates another eventual argument the computation might have (that is not a computation
parameter), and runtime the value tf − t0 . If runtime is not specified, the tool assumes T = ∅.

4.2

Battery Model

The battery model is an abstraction that predicts how the draining power at future time instants–
due to varying computations and motion load–affects the SoC. Generally, battery SoC is the
most important measure for battery management, yet, it cannot be directly measured (Xia et
al., 2015). There are numerous approaches to formulate its model, and we discussed the most
common ones in the literature in Section 3.2 . In this section, we then use the past literature to
derive a battery model of an aerial robot’s battery. The model that we derive is an equivalent
electrical circuit. Such models do not require detailed information about, e.g., battery chemistry;
nonetheless, they accurately predict future SoC at a relatively low computational complexity
compared with complex and exhaustive models (R. Rao et al., 2003).
We detail the equivalent electrical circuit that we adapted from the literature in Section 4.2.1;
it is the building block of our battery model. We then provide some further information on the
implementation of the equivalent electrical circuit in the powprofiler tool in Section 4.2.2. We
will use the battery model in Section 5.3.2 to define the output constraint in Definition 5.3.1.
4.2.1

Equivalent electrical circuit

In summary of Section 3.2, equivalent electrical circuits are abstract models, frequently referred
to as battery equivalent circuit models (ECMs). They are common in the literature for battery
SoC estimation (C. Zhang, Allafi, et al., 2018) and treated in numerous studies relative to Li-ion
rechargeable battery cells (Hasan et al., 2018; Hinz, 2019). Although there are more accurate
models to predict SoC for these batteries from a given power and time trajectories–namely physical or electrochemical models (R. Rao et al., 2003)–for mobile robots and more in general for
resource-constrained systems it is usually required to balance the models’ complexity and the accuracy (Hasan et al., 2018; R. Rao et al., 2003). For what concerns the specific battery chemistries
to be modeled, we focus on Li-ion batteries. These batteries have broad applications involving
electric vehicles, mobile, and aerial robots (Hasan et al., 2018; Shi and Zhao, 2006; Xia et al., 2015;
C. Zhang, K. Li, et al., 2014), due to their characteristics such as low self-discharge rate, absence of
memory effect, and high power and energy density (C. Zhang, K. Li, et al., 2014). We omit further
details that interfere in the calculation, such as battery state of health, temperature, and C-rate.
Indeed there are other methods in the literature (Espedal et al., 2021; L. Lu et al., 2013; R. Zhang

4.2. Battery Model

63

et al., 2018) to estimate more accurately the SoC together with other battery parameters (these

are, however, beyond the scopes of our work).
Rr
I
+
- V

Figure 4.5. Equivalent electrical circuit for battery modeling with one resistor, representing the internal
battery resistance.

Here, we propose a simplistic battery model to model a Li-ion battery of an aerial robot in
flight, focusing on lesser complexity. The battery SoC changes–when computations and motion
require a current to be drained from the battery–according to the equation (Hasan et al., 2018;
C. Zhang, Allafi, et al., 2018)

ḃ(y(t)) = −I(y(t))/Qc ,

(4.5)

where Qc ∈ R is the battery constant nominal capacity measured in amperes per hour, I(y(t)) ∈
R is the internal current that we derive later in this section, and y(t) ∈ R≥0 is a power drain,
i.e., the power needed for the computations and the motion. If we use the computations energy
model in Section 4.1, it is the power metric in Definition 4.1.2 and the corresponding value of the
measurement layer in Definition 4.1.1 for each time step.
We propose a simplistic ECM with an internal resistance from the literature (He et al., 2011;
Hinz, 2019; Mousavi G. and Nikdel, 2014) in Figure 4.5, sometimes termed the “Rint” model (He et
al., 2011; Hinz, 2019). The circuit models the battery simply as a perfect voltage source connected
with a resistor Rr ∈ R measured in ohms, representing the internal battery resistance. The
voltage V ∈ R measured in volts is the internal battery voltage, which depends on SoC (Hasan et
al., 2018) and can be retrieved from a battery data sheet (Hinz, 2019), and I is the current running
through the circuit that depends on the power requirements of the load.
The voltage on the extremes of the ECM then respects
Ve = V − Rr I,

(4.6)

where Ve ∈ R is the external battery voltage. If we assume that the voltage needed by the
computations and motion is stable, let’s call it Vs ∈ R measured in volts, and that the current
required by the load (computations and motion) is Il , we can write
Vs Il = Ve I,

(4.7)

using simply Kirchhoff’s circuit laws (the power into the load should match the power out).
Combining the Equations (4.6–4.7)ii , we obtain the quadratic expression Rr I 2 − V I + Vs Il = 0,
ii

Practical implementations would then require a voltage regulator.

64

Chapter 4. Energy Models

I(y(t))

high load

0.3

low load
average load
0.1

0.1

0.2

y(t)/Vs

Figure 4.6. Evolution of I for a given linear load, showing that a constant load is to be preferred
compared to one that repeatedly changes.

which leads to

I(y(t)) =

V−

q


V 2 − 4Rr y(t) /(2Rr ),

(4.8)

where Il := y(t)/Vs is the current of the load depending on the computations and motion
power y(t) at a given time instant t in Equation (4.5). Furthermore, we take the negative solution
of the quadratic expression: when Il is zero, I should also be zero. With the internal current in
Equation (4.8) combined with the battery SoC in Equation (4.5), we can model how the computations and motion power trajectory y(t) on t ∈ T := [t0 , tf ] for given initial and final time
instants (t0 , tf respectively) affects the battery.
In one of our earlier intuitions (Seewald, Schultz, Ebeid, et al., 2021a), we expected a constant
energy load to result in a better overall SoC compared to, e.g., a spiked one, even if the two have
the same overall energy. The model above confirms this intuition. In Figure 4.6, we show the
evolution of I in Equation (4.8) for a given linear load y(t)/Vs from zero to approximately onethird, assuming V = Vs = Rr all one. The curve in the plot bends upwards for the plotted
range: a line between two points will always be above the curve; it implies that a constant load is
to be preferred compared to a load that repeatedly changes from high to low.
There are also more complex ECMs in the literature (Hasan et al., 2018; Hinz, 2019), which
add additional elements to, e.g., account for the changes in the load current. One such ECM
is the Thevenin model and the Thevenin-based model (M. Chen and Rincon-Mora, 2006; Hasan
et al., 2018; Hinz, 2019; Mousavi G. and Nikdel, 2014; Salameh et al., 1992; C. Zhang, Allafi, et
al., 2018).

Sometimes termed the dual-polarization model (He et al., 2011), we illustrate the
ECM in Figure 4.7. It models further details, such as the short-term transient behavior with the
first RC element (R1 , C1 ) and the long-term transient behavior with the second RC element
(R2 , C2 ) (Hinz, 2019).

4.3. Energy Model of the Motion

65

R1

R2

C1

C2

Rr
I
+
- V

Figure 4.7. Thevenin-based equivalent electrical circuit for battery modeling with one resistor and two
RC internal elements. The two elements add some complexity, making the model able to account for
changes in the load current.

4.2.2

Battery model in the powprofiler tool

The powprofiler tool allows automated battery modeling and directly derives battery SoC for
each measurement layer in Section 4.1.2. Indeed in Definition 4.1.1, the function g returns a triplet
of values, including the SoC. For the predictive layer in Definition 4.1.2 in Section 4.1.3, the tool
similarly outputs the SoC for a given configuration of parameters and energy sensor or other
energy measuring device. To this end, it implements the simplistic equivalent electrical circuit in
Figure 4.5 from the literature (He et al., 2011; Hinz, 2019; Mousavi G. and Nikdel, 2014), with the
class soc_1resistor, where the constructor accepts in input the parameters Il , V , Rr , Vs and
Qc that we discussed in Section 4.2.1. The current load Il is expressed via the data type pathn
in Section 4.1.4. One can implement a similar battery model, e.g., the Thevenin-based ECM in
Figure 4.7, by simply inheriting from class first_derivative the function get_value. It returns
the modeled battery SoC at the next time instant from an independent variable, i.e., time, and a
dependent variable represented via the data type vectorn in Section 4.1.4.
Internally, the tool implements a numerical simulator based on the Runge-Kutta methods
for numerical integration (Iserles, 2009). One can then personalize the size of the integration
step h ∈ R>0 via the property h in the configuration specification in Section 4.1.5 (a practical
value of such property is, e.g., one hundredth). The tool first derives a model for the power and
energy and later numerically simulates the battery model via the equivalent electrical circuit in
Figure 4.5 adjoining the battery SoC.

4.3

Energy Model of the Motion

In this section, we provide a model for the motion energy of aerial robots in CPP. To this end, we
derive a differential periodic energy model that we formally prove in Section 4.3.1. We enhance
the model with the path and computations parameters in Section 4.3.2, to predict the energy
consumption of a given configuration of parameters, and explain how we convert the parameters
into variations of energy consumption in Section 4.3.3.

66

Chapter 4. Energy Models

30

Power (W)

25

20
0

100

200

300

Time (sec)
Figure 4.8. Empirical energy data of the Opterra fixed-wing aerial robot in coverage planning. The
data shows that the energy signal is periodic over time as the fixed-wing aerial robot reiterates a set
of paths.

Spectrum (102 dB)

4

2

0
-2

0

2

Frequency (10−2 Hz)
Figure 4.9. Frequency spectrum of the empirical energy data in Figure 4.8 where the aerial robot
does the coverage planning.

Let us suppose the aerial robot is operating in an autonomous use case, planning the coverage
and scheduling some computations for detections and encryption in Section 2.6. It expectedly
iterates some paths (the primitive paths) for CPP and schedules the computations periodically,
as we outlined in Section 1.4, and further backed with the concept of primitive paths in Definition 2.4.1. Since the paths and tasks are periodically iterated over time, we expect the energy
to evolve similarly. This assumption is further supported by our previous contribution on the
topic (Seewald, García de Marina, Midtiby, et al., 2020), showing that a Fourier series of a given
order can model the energy of the aerial robot (in the contribution, we used the order three). We
will ease the assumption of the periodic evolutions in practice to periodic with disturbance in
Chapter 6. We motivate the choice of a periodic energy model further with some empirical energy data of the Opterra fixed-wing aerial robot flying the agricultural use case in Figures 4.8–4.9.
The data shows the robot’s energy along its frequency spectrum. The latter is centered at zero
frequency, and peaks at four hundred kilo decibels. The peak visually depicts the shift on the
power axis in Figure 4.8 (and further backs the choice of the Fourier series of order three in our

4.3. Energy Model of the Motion

67

earlier work, illustrating that the power evolution needs approximately three frequencies to be
modeled). To obtain the spectrum in frequency space, we computed the Fourier transform.
4.3.1

Derivation of the differential periodic model

In the remainder of this section, we refer to the power (or instantaneous energy consumption)
evolution simply as the energy signal. We model the signal using energy coefficients vector q ∈
Rm that characterize the energy signal. We derive the coefficients from Fourier analysis: the size
of the vector m is then related to the order of the series. We prove a relation between the energy
signal and the energy coefficients in Lemma 4.3.1.
First, let us consider a periodic energy signal of period T ∈ R>0 , and a Fourier series of an
arbitrary order r ∈ Z≥0 for the purpose of modeling the signal
h(t) = a0 /T + (2/T )

r
X


aj cos ωjt + bj sin ωjt ,

(4.9)

j=1

where h : R≥0 → R maps time to the power, ω := 2π/T is the angular frequency, and
a0 , aj , bj ∈ R the Fourier series coefficients ∀j ∈ [r]>0 .
The energy signal can be modeled by Equation (4.9) and by the output of a linear model
q̇(t) = Aq(t) + Bu(t),

(4.10a)

y(t) = C q(t),

(4.10b)

where y(t) ∈ R is the power at time instant t. We discuss matrices A, C , and B in Equation (4.12),
Equation (4.14), and Equation (4.46), and the nominal control u in Section 4.3.2.
The state q(t) contains the energy coefficients
h
i0
q(t) := α0 (t) α1 (t) β1 (t) · · · αr (t) βr (t) ,
(4.11)
where q(t) ∈ Rm with m = 2r + 1. We will estimate the value of q with a state estimator
(Kalman filter) in Algorithm 5.3, exploiting the linearity of the model in Equation (4.10).
The state transition matrix


0
01×2 01×2 . . . 01×2
 02×1 A
02×2 . . . 02×2 


1
 2×1
2×2
2×2 

,
0
0
A
.
.
.
0
2
A=
(4.12)

.
.
.
.
..
 .

.
.
.
.
 .
.
.
. 
2×1
2×2
2×2
0
0
0
. . . Ar
where A ∈ Rm×m . In matrix A, the top left entry is zero, the diagonal entries are A1 , . . . , Ar , the
remaining entries are zeros. Matrix 0i×j is a zero matrix of i rows and j columns. The submatrices
A1 , A2 , . . . , Ar or generically
"
#
0
ωj
Aj :=
,
(4.13)
−ωj 0

68

Chapter 4. Energy Models

∀j ∈ [r]>0 . The output matrix
2r

z
}|
{i
C = (1/T ) 1 1 0 · · · 1 0 ,
h

(4.14)

where C ∈ Rm (the first value in the first column is one, the pattern one–zero is then repeated
2r times).
The linear model in Equation (4.10) allows us to include the control in the model of Equation (4.9), a concept that we build upon further in Section 4.3.2 where we merge the computations
and motion energies. In the remainder, we formally prove an important concept in our work: we
can use Equation (4.10) to model the energy signal of an aerial robot, assuming the robot iterates
periodically a set of paths and computations to achieve a given space coverage. We already know
that we can model a periodic energy signal with Equation (4.9), so we prove the equivalence and
equality of the models in Equation (4.9) and Equation (4.10).
Suppose control u is a zero vector, matrices A, C are described
by Equations (4.12–4.14), and the initial guess at a given time instant t0 ∈ R>0 q(t0 ) is
h
i0
q(t0 ) = a0 a1 /2 b1 /2 · · · ar /2 br /2 .

Lemma 4.3.1: Signal, output equality.

Then, the signal h in Equation (4.9) is equal to the output y in Equation (4.10).
Proof. The proof justifies the choice of the items of the matrices A, C and the initial guess
q(t0 ) in Equations (4.11–4.14). We write these elements such that the coefficients of the series
a0 , . . . , br are the same as the coefficients of the state α0 , . . . , βr .
Let us re-write the Fourier series expression in Equation (4.9) in its complex form with the
well-known Euler’s formula
eit = cos t + i sin t,
(4.15)
where i is the imaginary unit. With t = ωjt, we find the expression for
cos ωjt = (eiωjt + e−iωjt )/2,

(4.16a)

iωjt

(4.16b)

sin ωjt = (e

−e

−iωjt

)/(2i),

by substitution of sin ωjt and cos ωjt respectively. This leads to (Kuo, 1967)
h(t) = a0 /T +(1/T )

r
X

eiωjt (aj − ibj )+

j=1
r
X

(1/T )

(4.17)

e

−iωjt

(aj + ibj ).

j=1

The solution at time t of the model in Equation (4.10) under the assumptions in the lemma
(the control is a zero vector) can be expressed
q(t) = eAt q0 .

(4.18)

4.3. Energy Model of the Motion

69

Both the solution in Equation (4.18) and the system in Equation (4.10) are well-established
expressions derived using standard textbooks (Kuo, 1967; Ogata, 2002). To solve the matrix exponential eAt in Equation (4.18), we use the eigenvectors matrix decomposition method (Moler
and Van Loan, 2003). The method works on the similarity transformation of the form
A = V DV −1 .

(4.19)

The power series definition of eAt implies then that (Moler and Van Loan, 2003)
eAt = V eDt V −1 .

(4.20)

In this latter expression, let us consider the non-singular matrix V , whose columns are eigenvectors of A. Notation-wise, we can write that
h
i
V := v0 v10 v11 . . . vr0 vr1 .
(4.21)
and that the diagonal matrix of eigenvalues
D = diag(λ0 , λ01 , λ11 , . . . , λ0r , λ1r ),

(4.22)

where λ0 is the eigenvalue associated with the first item of A. λ0j , λ1j are the two eigenvalues
associated with the block Aj . We can then write
AV = V D,

(4.23)

by simply reordering Equation (4.19).
We apply the approach in terms of Equation (4.10) and under the assumptions that we made
in the Lemma 4.3.1
q̇(t) = Aq(t).

(4.24)

The linear combination of the initial guess q(t0 ) and the generic solution can be then expressed

F q(t0 ) = γ0 v0 +

1 X
r
X

γj vjk ,

(4.25a)

k=0 j=1

F q(t) = γ0 eλ0 t v0 +

1 X
r
X

γj eλj t vjk ,

(4.25b)

k=0 j=1

where t is a generic time instant and
h
i
F = 1 ··· 1 ,
F ∈ Rm is a column vector of ones.

(4.26)

70

Chapter 4. Energy Models

Let us consider the expression in Equation (4.25b). It represents the linear combination of all
the coefficients of the state at time t. It can also be expressed in the following form
F q(t)/T = γ0 eλ0 t v0 /T +(1/T )

r
X

γj eλj t vj0 +
0

j=1
r
X

(1/T )

(4.27)
λ1j t

γj e vj1 ,

j=1

where we split the sum and divided each item by the period T .
We prove that the eigenvalues λ and eigenvectors V are such that Equation (4.27) is equivalent
to Equation (4.17). To this purpose, we note that matrix A is a block diagonal matrix, and we can
express its determinant as the multiplication of the determinants of its blocks
det (A) = det (0) det (A1 ) det (A2 ) · · · det (Ar ).

(4.28)

We now conclude the proof by computing the first determinant and the others separately.
By computing the first determinant, we prove that the first terms in Equation (4.17) and Equation (4.27) match. We find the eigenvalue from det(0) = 0, which is λ0 = 0. The corresponding
eigenvector can be chosen arbitrarily
h
i
(0 − λ0 )v0 = 0 · · · 0 ,
(4.29)
∀v0 , thus we choose

h
i
v0 = 1 0 · · · 0 .

The sizes of the zero vector and of v0 in Equations (4.29–4.30) are both Rm .
We find the value γ0 in Equation (4.27) so that the terms are equal
h
i
γ0 = a0 0 · · · 0 ,

(4.30)

(4.31)

where γ0 ∈ Rm .
Then, we prove the other determinants. In this way, we prove that all the terms in the sum
of both Equation (4.17) and Equation (4.27) match. By computing the second determinant, we
prove that the first terms in both summaries in Equation (4.17) and Equation (4.27) match. We
thus focus on the first block A1 and find the eigenvalues from
det(A1 − λI) = 0.

(4.32)

The polynomial λ2 + ω2 , gives two complex roots–the two eigenvalues
λ01 = iω,

(4.33a)

λ11 = −iω.

(4.33b)

The eigenvector associated with the eigenvalue λ01 is
h
i0
v10 = 0 −i 1 0 · · · 0 .

(4.34)

4.3. Energy Model of the Motion

71

The eigenvector associated with the eigenvalue λ11 is
h
i0
v11 = 0 i 1 0 · · · 0 .

(4.35)

Both eigenvectors are equally sized v10 , v11 ∈ Rm .
Again, we find the values γ1 in Equation (4.27) such that the equivalences
(
eiωt (a1 − ib1 )

= γ1 eiωt v10

,

(4.36)

h
i
γ 1 = 0 b1 a 1 0 · · · 0 .

(4.37)

e−iωt (a1 + ib1 )

= γ1 eiωt v11

hold. They hold for

The proof for the remaining r − 1 blocks is equivalent.
The initial guess q0 is built such that the sum of the coefficients is the same in both the signals. In the output matrix, the frequency 1/T accounts for the period in Equation (4.17), Equation (4.27), and Equation (4.9). At time instant zero, the coefficients bj are not present and the
coefficients aj are doubled for each j = 1, 2, . . . , r (thus we multiply by half the corresponding
coefficients in q0 ). To match the outputs h(t) = y(t), or equivalently
F q(t)/T = C q(t),

(4.38)

h
i
C = (1/T ) 1 1 0 · · · 1 0 .

(4.39)

we use

We thus conclude that the signal and the output are equal and that the lemma holds.

We note for practical reasons that the signal would still be periodic with another linear combination of coefficients. For instance
h
i
C = d 1 1 0 ··· 1 0 ,
(4.40)
equivalent to
h
i
C = d 1 0 1 ··· 0 1 ,

(4.41)

h
i
C = d 1 1 1 ··· 1 1 ,

(4.42)

or

for a given constant value d ∈ R.

72

4.3.2

Chapter 4. Energy Models

Nominal control of the energy signal

Let us suppose that at time instant t the plan in Definition 2.4.2 reached the ith stage Γi and the
control contains the configuration of path and computations parameters
ρ

σ

}|
{ z
}|
{ i0
hz
ci (t) : = ci,1 (t) · · · ci,ρ (t) ci,ρ+1 (t) · · · ci,ρ+σ (t)
h
i0
ρ
= ci (t) ciσ (t) ,

(4.43)

where ci (t) ∈ Rn with n = ρ + σ differs from the nominal control u(t) in Equation (4.10). We
include the control in the nominal control exploiting the following observation.
We observe that: (a) a change in path
parameters affects the energy indirectly. It alters the time when the aerial robot reaches the final
point pΓl and enters the final stage Γl , (b) a change in computations parameters affects the energy
directly. It alters the power as more computations require more power (and vice versa).
Observation: Relation between the control and energy.

The second point in the observation is easily verified. The powprofiler tool models the energy
consumption of the heterogeneous computing hardware the mobile robot is carrying. A variation in the computations parameters affects the schedule (as the schedule is parametrized by the
parameters in Definition 2.1.2), and hence results in more/less power required by the computing
hardware.
The first point in the observation can be verified by inspection of the example in Section 2.6. It
is clear that if we decrease the parameter ci,1 relative to the circle radius, the flying time decreases.
This is shown in Figure 5.12 and Figure 5.13. Figure 5.12 illustrates the trajectory of the aerial
robot flying at the highest configuration of the path parameter ci,1 = c i,1 . Figure 5.13 then
illustrates the trajectory flying at the lowest configuration ci,1 = c i,1 . The flying time differs
significantly, along with the quality of the coverage. In Figure 5.13, the parameter ci,1 that alters
the radius and center of the upper circle (defined originally in Section 2.6) is replanned as, e.g.,
adverse atmospheric conditions do not allow to terminate the original plan in Figure 5.12.
We use the observation later in Section 5.3.4 to check that the time to completely discharge
the battery is greater than the flight time and replan the path parameters accordingly. We replan
the computations parameters to maximize the instantaneous energy consumption against the
maximum battery discharge rate.
The nominal control is
u(t) := û(t) − û(t − ∆t),
(4.44)
where û(t) is defined as the energy estimate of a given control sequence at time instant t, û(t −∆t)
at the previous time instant t − ∆t (∆t is the unit of time instant) and
û(t) := diag(νi )ci (t) + τi ,
where diag(νi ) is a diagonal matrix with the parameters νi,j ∈ νi , ∀j ∈ [n]>0 .

(4.45)

4.3. Energy Model of the Motion

73

The input matrix is then
σ

 1×ρ
0
01×ρ

B= .
 ..
01×ρ

z }|
1 ···
0 ···
.. . .
.
.
0 ···

{ 
1 



0


..  2r + 1
. 


0

(4.46)

where B ∈ Rm×n contains zeros except the first row where the first ρ columns are still zeros and
the remaining σ are ones.
û(t) is a stage-dependent scale transformation with
ρ

σ

}|
{ z
}|
{ i0 h
i0
hz
ρ
νi = νi,1 · · · νi,ρ νi,ρ+1 · · · νi,ρ+σ = νi νiσ ,
h
i0 h
i0
ρ
τi = τi,1 · · · τi,ρ τi,ρ+1 · · · τi,ρ+σ = τi τiσ ,

(4.47a)
(4.47b)

scaling factors. They quantify the contribution to the plan of a given configuration of parameters in terms of time for the first ρ parameters, and instantaneous energy consumption for the
remaining σ (we use the same notation for the path and computation scaling factors as for the
parameters).
The nominal control u(t) is then the difference of these contributions of two consecutive
controls ci (t − ∆t), ci (t) applied to the system. Bu(t) merely includes the difference in the
instantaneous energy consumption into the model in Equation (4.10). Matrix B ignores the time
contribution of the path parameters in ci . We use them to verify that the flying time is lower
than the battery time in Section 5.3.5.
4.3.3

Control scale transformation
Energy (J)
energy with νi,2 c i,2

+ τi,2

energy with νi,2 c i,2

+ τi,2

admissible region

νi,1 c i,1 + τi,1

νi,1 c i,1 + τi,1

Time (s)

Figure 4.10. The concept of path and computations parameters scale transformations. Without any
battery constraints, the energy-aware coverage planning and scheduling select the highest configuration which respects the control constraint (admissible region) from Equation (2.6).

74

Chapter 4. Energy Models

To transform the control ci (t) at ith stage and time instant t, we use different approaches for
the path and computation scaling factors. The scaling factors for the path parameters from Equation (4.47) are derived empirically. For example, we can obtain the scaling factor νi,1 relative to
the alteration with the parameter ci,1 of the upper circle φi+3 of the Zamboni-like motion from
Section 2.6 by measuring the time needed to compute the path with the lowest configuration
c i,1 , t in Figure 5.13 and the highest t in Figure 5.12.
The variation of the control hence results in an approximate measure of the plan’s time variation with factors

(4.48a)
νi,j = (t − t)/(c i,j − c i,j ) /ρ,

τi,j = c i,j (t − t)/(c i,j − c i,j ) + t /ρ,
(4.48b)
ρ

∀j ∈ [ρ]>0 . Moreover, let the factors be zero when the parameters ci = ∅. We use the latter to
initialize the algorithm in Section 5.3.5.
The scaling factors for the computations parameters from Equation (4.47) are derived using
powprofiler, the modeling tool from Section 4.1.4. We estimate the energy cost of a given schedule (a given computations configuration) with the function g from Definition 4.1.2. For instance,
if the computation is the CNN ROS node, the computation parameter c1,2 corresponds to the
FPS rate. The tool then measures power according to the detection frequency.
Energy (J)

energy with νi,2 ci,2

νi,1 c i,1 + τi,1

νi,1 c i,1 + τi,1

+ τi,2 for a ci,2 < c i,2

Time (s)

Figure 4.11. Change in the admissible region in Figure 4.10 due to a battery constraint.

The scaling factors add the computational energy component to the model in Equation (4.10).
They are derived similarly to Equation (4.48)
νi,j = (g(c i,j ) − g(c i,j ))/(c i,j − c i,j ),

(4.49a)

τi,j = c i,j (g(c i,j ) − g(c i,j ))/(c i,j − c i,j ) + g(c i,j ),

(4.49b)

∀j ∈ [ρ + 1, n]. We then assume g only returns the power metric (so we do not specify an
additional parameter to numerate the metric) and, for ease of notation, assume all the values from
g(c i,j ) to g(c i,j ) are distributed linearly. Moreover, let the factors be zero when the parameters
ciσ = ∅.

4.4. Summary

75

The concept of a path and a computation parameters (ci,1 , ci,2 ) scale transformation is illustrated in Figure 4.10. The energy domain is bounded by the output of the powprofiler tool and
the flight time domain by the empirical data. The energy-aware coverage planning and scheduling select the highest possible configuration of parameters (control) in the admissible region
(under the constraints). Currently, the highest control corresponds to (c i,1 , c i,2 ). We will see in
Section 5.3 the optimal control derivation over a time horizon N under given battery constraints.
In Figure 4.11 we briefly exemplify this latter case, where due to, e.g., a sudden battery drop, the
energy and time domains are shrunk. The highest possible control is thus now different from
the above scenario.

4.4

Summary

This chapter derives energy models to predict future instances of the energy for both the computations and motion. It details the powprofiler profiling and modeling tool to derive the power,
energy, and battery SoC of computations configurations on the heterogeneous computing hardware within specific boundaries. The computations modeling methodology relies on a two-layer
architecture. The search space is here sampled discretely for several possible configurations in the
measurement layer. The union of multiple measurement layers forms the predictive layer, which
returns the energy metrics in the function of any configuration in the search space. The motion
modeling methodology relies on a differential periodic energy model that predicts future energy
instances, relying on the characteristics of CPP and empirical observation of the aerial robot
flying the precision agriculture use case. It includes the predictive layer from the powprofiler
tool, quantifying the energy effect of schedules variations. The chapter further derives a battery
model to accurately assess the battery SoC evolution. The model utilizes an equivalent electrical
circuit in the literature termed “Rint”. In the next chapter, we exploit the two energy and battery
models for planning-scheduling energy awareness, replanning a plan energy-wise, and w.r.t. the
current battery SoC.

Chapter 5

Coverage Planning and Scheduling
“[I]t may be possible to trade off reduced resource consumption for a slightly lower but
still acceptable level of performance.”
— Lahijanian et al., 2018

n t h e p r evious chapters, we introduced progressively the research questions we are

I interested in addressing. We then provided some preliminaries with basic terminology, formulated the problem formally, detailed the available literature, and derived various energy models.
Once we discussed all these basic constructs, we are ready to describe their interaction to solve
Problem 2.5.2 and Problem 2.5.1 and thus provide an energy-aware coverage planning and scheduling for autonomous aerial robots.
This chapter describes one of the main contributions of our work. Here we generate the
coverage plan Γ that we defined in Definition 2.4.2 solving Problem 2.5.2, replan Γ energy-wise
with the models from Chapter 4 solving Problem 2.5.1 in case of, e.g., sudden battery drops,
and guide the aerial robot on Γ. In particular, we first detail how we guide the aerial robot on
the plan in Section 5.1, recalling some constructs in Chapter 2. These include path functions,
stages, triggering points, and primitive paths. In Section 5.2, we discuss the generation of the
coverage plan with a union of path functions and triggering points in Sections 2.2–2.3 (it is on this
coverage that we are interested in guiding the aerial robot). In Section 5.3, we then discuss how
to replan the coverage energy-wise. To guide the aerial robot, we use the theory of vector fields
that point to the path functions. To generate the coverage path, a class of methods under the
name of cellular decomposition, generating a coverage motion that respects the nonholonomic
and other constraints of a fixed-wing aerial robot (such as the Opterra craft in Figure 1.1 that we
have discussed extensively in this work), including requirements on the turning radius. To replan
the coverage path, we use an optimal control approach termed model predictive control (MPC)
along with the periodic model in Chapter 4 (which we proved formally and motivated empirically
77

78

Chapter 5. Coverage Planning and Scheduling

in Section 4.3.1). We describe all these concepts and contextualize them in the solution to the
problems in this chapter.
This chapter connects to the remainder of this work as follows. Here we provide the solution
to the problems in Chapter 2. To this end, we use the available literature on planning in Chapter 3
and the energy models in Chapter 4. We provided the motivation and discussed why it is important to solve these problems in Chapter 1. We discuss the result of our planning-scheduling in
Chapter 6. Although we provide an algorithm for energy-aware coverage planning and scheduling
for autonomous aerial robots, some research questions remain open. We discuss these questions
in Chapter 7.

5.1

Guidance on the coverage

In this section, we describe how we guide the aerial robot in space Q ⊆ R2 for an inertial
navigation frame OW . For this purpose, we briefly recall some concepts we introduced in Chapter 2. We describe the path the aerial robot flies in Section 2.2 with a mathematical function
φi : R2 × Rρ → R that maps a point in 2D space and the path parameters to a given value on the
z-axis in Definition 2.2.1 and Definition 2.3.1. We saw two examples of such functions. In the first
example, we proposed a line at an altitude h ∈ R in Figure 2.1. The value on the z-axis given a
point p(t) at the time t is then the length, let’s call it d, of a vertical segment parallel to the z-axis
that goes from the plane φ(x, y) = h and intersects the plane in Equation (2.2). In the second
example, we proposed a circle (at the same altitude h) in Figure 2.2. The value on the z-axis is
the length d2 of a similar segment, going from the plane φ(x, y) = h to the intersection of the
paraboloid in Equation (2.3). We further recall from Definition 2.3.1 in Chapter 2 that we store
path functions in stages. The set of stages form the plan Γ in Definition 2.4.2. The aerial robot
flies the ith a stage Γi traveling the ith path function φi up until it encounters the triggering
point pΓi in Definition 2.3.2; at the occurrence, the action depends on how we defined Γ. We can
define Γ with all the stages explicitly so that the aerial robot switches to Γi+1 up to reaching the
final point pΓl in Γl , the final stage. Alternatively, we can define Γ with n stages and a shift d.
When the aerial robot reaches the knth triggering point pΓkn for some k ∈ Z>0 , it advances the
n stages of d. It iterates the process up to reaching the final point pΓl .
In the remainder of this section, we detail how we guide the aerial robot on a path function φi
from the stage Γi , ∀i ∈ [l]>0 (or ∀i ∈ [n]>0 with a consequent shift of d when we reach pΓkn
for a k) up to reaching pΓl with the theory of vector fields. The path function can be, e.g., the
line and circle in Figures 2.1–2.2. By guidance, we mean where to fly next with the aerial robot
starting from an initial point in space p(t0 ) at the first time instant t0 up to the final triggering
point p(tl ) = pΓl at tl > t0 .
5.1.1

Vector fields for guidance

Let us briefly discuss the intuition behind vector fields for guidance with the concept of potential
functions. These are differentiable real-valued functions φ : Rd → R, of which the value we

5.1. Guidance on the coverage

79

can consider as energy, and hence their gradient as force (H. M. Choset et al., 2005). There are
several pseudonyms for potential functions for different fields, e.g., the electrostatic potential for
electrostatics, velocity potential for hydrodynamics, and temperature for flowing heat (Needham,
1998). We use the concept for exemplification; we don’t deal with aerial robots’ dynamics directly
in our model and see gradients as velocity and not force vectors, being p the position. We note
that the gradient of the potential function points where it maximally (locally) increases (H. M.
Choset et al., 2005). We define the gradient of φ

ρ
∂φi (p(t), ci )/∂p1 (t)
∂φi (p(t), c ρ )/∂p2 (t)
i


ρ
∇φi (p(t), ci ) := 
,
..


.


(5.1)

ρ

∂φi (p(t), ci )/∂pd (t)
where ∂φ/∂pk for k ∈ [d]>0 indicates the differential and p1 , p2 , . . . are
h
i0
p(t) = p1 (t) p2 (t) · · · pd (t) ,

(5.2)

simply the components of the vector p (i.e., when we are dealing with 2D space, d is two, and
the components are x and y).
We can then use the gradient in Equation (5.1) to define a vector field–a function that assigns
a vector at each p in Q (LaValle, 2006), which will then point in the direction of the gradient
[
ρ
ρ
Φ(t, φi , ci ) :=
∇φi (p(t), ci ).
(5.3)
p(t)∈Q

We note some analogies in the physical theory of potential functions with our path functions;
indeed vector fields are a well-known concept in physics, with applications such as electrostatic,
gravitational, and magnetic fields (Feynman et al., 2015). Imagine that the aerial robot is a positively charged particle in an electrostatics analysis, attracted by a negatively charged goal. Via
the gradient, we can then direct the particle (the aerial robot) to the goal (where the function
maximally locally decreases) (H. M. Choset et al., 2005). In the setting of Equation (2.2) and Equation (2.3), i.e.,
2y − x = h, (x − 3)2 + (y − 3)2 − 2 = h,
(5.4)
the gradient then points away from the base of the plane in Equation (2.2) and the center of the
circle in Equation (2.3) in Figure 5.1. If the goal is not to fly over the circle in Figure 2.2, but to
its center (xc , yc ) in Equation (2.3), the vector field Φ in Equation (5.3) direct us in the opposite
direction; we can then use −∇φi to direct the robot to the goal.
Vector fields are common in the motion planning literature (H. M. Choset et al., 2005; LaValle,
2006) and in studies (García de Marina et al., 2017; Gonçalves et al., 2010; Kapitanyuk et al.,
2017; Lindemann and LaValle, 2005; Panagou, 2014; Zhou and Schwager, 2014) for navigation
and guidance of different mobile robots. A well-known intuitive method based on vector fields
brought from optimization is the gradient descent algorithm (Bryson and Y.-C. Ho, 1975; H. M.

80

Chapter 5. Coverage Planning and Scheduling

z
∇φi
y
φ(p) = d2

(xp , yp , d2 )
(x − 3)2 + (y − 3)2 − 2 = h

−∇φi

h

(xp , yp , h)

∇φi = 0

x

Figure 5.1. The direction of the gradient ∇φi in the point (xp , yp ) at an altitude h w.r.t. OW for the
circle path function in Equation (2.3) and Figure 2.2. The gradient directs where the function locally
maximally increases; the opposite thus to the center of the circle in Equation (5.4) (or the base of the
paraboloid φi ).
Input : t0 initial time step
ρ

1
2
3
4

ci value of the path parameters
j current stage
Output : p(K) trajectory
foreach i ∈ K := {t0 , t0 + h, t0 + 2h, . . . } do
ρ
if ∇φj (p(i), ci ) ≤ ε then
return p(K)
ρ
p(i + h) ← p(i) + θ(i)∆φj (p(i), ci )
Algorithm 5.1. Gradient descent

Choset et al., 2005), where

an intuitive choice of the search direction is the negative gradient
∆φi := −∇φi (Boyd et al., 2004). We detail the gradient descent method in Algorithm 5.1, where
we iterate at discrete time steps, meaning that at instant n ∈ Z>0 , K contains t0 , t0 +h, . . . , t0 +
nh. We discuss further the time step h (h is not to be confused with the altitude when used in
the path functions) later in this chapter in Section 5.3.5. In the algorithm, p(t0 ) is given (e.g.,
from sensors data), θ(i) is a scalar step size at time instant i (H. M. Choset et al., 2005)–there

5.1. Guidance on the coverage

81

can be indeed different step sizes at different instants–and ε ∈ R>0 is chosen based on the task
requirements (it is unrealistic to assume we will reach ∇φi = 0).
We discuss in the next section how to fix Φ so that it directs us to follow Equation (5.4) rather
than, e.g., to ∇φi = 0.
5.1.2

Derivation of a path following vector field
y
+4
+3
+2

-1

h
+1

∇φi = 0
p(t0 )

p(t0 + h)
x
Figure 5.2. The gradient descent algorithm after the first two steps, with the following step being
dashed and directing the aerial robot to the center of the circle where the gradient is zero ∇φi = 0.
The paraboloid φi representing the path function circle at altitude h is illustrated in the contour plot.
Algorithm 5.1 that we illustrate in Figure 5.2 directs to the center of the circle when we have a
circle as a path function in Equation (5.4). However, we want to track (or follow) these functions.
Concretely, in the path sub-plan in Equations (2.13–2.14) in Section 2.6.1, we want to follow
the path function φi+1 by flying over rather than heading the center when we follow a circle
path function. In the example, we started following the circle described by φi+1 after reaching
pΓi while tracking φi (for all the previous and following path functions). To this end, we use
a vector field-based approach proposed in the literature specifically for aerial robots (García de
Marina et al., 2017), which points to the contours of the functions in Figures 2.1–2.2 and thus to
Equation (5.4).
The expression for the search direction ∆φi in Algorithm 5.1 using the vector field in (García
de Marina et al., 2017) becomes
ρ

ρ

ρ

ρ

∆d φi (p(t), ci ) := Ei ∇φi (p(t), ci ) − ke φi (p(t), ci )∇φi (p(t), ci ),
ρ

(5.5)
ρ

where Ei ∇φi (p(t), ci ) is a vector pointing perpendicularly to the gradient ∇φi (p(t), ci ), Ei is
the ith stage direction
"
#
0 1
Ei =
,
(5.6)
−1 0

82

Chapter 5. Coverage Planning and Scheduling

with Ei being the counterclockwise, −Ei the clockwise direction. The contribution of the comρ
ρ
ponent −ke φi (p(t), ci )∇φi (p(t), ci ) in Equation (5.5) points in the direction of the path function. It depends on the coefficient ke ∈ R>0 –indicating the speed of convergence (García de
Marina et al., 2017)–and on the value of φi at the current point (of course also on the path parameters and the value of the gradient). We illustrate ∆d φi in Figure 5.3. When we take a point within
y
+4
+3
+2

∆d φi
h

Ei ∇φi

−ke φi ∇φi

+1

p−
-1

x
Figure 5.3. The direction of the vector field for guidance in (García de Marina et al., 2017) with a point
p− inside the circle: ∆d points to the path function opposite to the center of the circle.
ρ

ρ

the circle, let’s call it p− , the value of φi is negative; −ke φi (p− , ci )∇φi (p− , ci ) points outwards
ρ
of the circle center, in the direction of the path function. Ei ∇φi (p− , ci ) points perpendicularly
ρ
to the gradient ∇φi and to the path function itself. The resulting vector ∆d φi (p− , ci ) then
points to the direction of the path function.
Now we take a point p+ out of the circle, and not exactly over the path function. The value of
ρ
ρ
φi is positive; −ke φi (p+ , ci )∇φi (p+ , ci ) points inwards of the circle center and the resulting
ρ
vector ∆d φi (p− , ci ) in the direction of the path function. If we finally take a point p0 exactly
ρ
ρ
ρ
over the path function, φi is zero; −ke φi (p0 , ci )∇φi (p0 , ci ) is thus also zero, and ∆d φi (p0 , ci )
points perpendicularly to the path functions. We illustrate these two cases in Figure 5.4. Let us
thus define the vector fields
[
ρ
ρ
Φd (t, φi , ci ) :=
∆d φi p(t), ci .
(5.7)
p(t)∈Q

This vector fields points to the path function such as the line and the circle in Equation (5.4)
for every point in space Q as we illustrate in Figure 5.5 for the circle (x − 3)2 + (y − 3)2 − 2 = h.
Finally, let’s reconsider Algorithm 5.1 with the vector field Φd and guide the aerial robot in
space to track a specific path function φi in Algorithm 5.2. The algorithm iterates at discrete time
steps on Line 1 as Algorithm 5.1. It stops tracking the jth path function at the occurrence of the
triggering point pΓj on Line 2 using the Euclidean distance with a small enough ε ∈ R>0 rather

5.1. Guidance on the coverage

83

p0

y

Ei ∇φi

Ei ∇φi
∆d φi

+4
-1

−ke φi ∇φi

+3

h

p+

+2

+1

x
Figure 5.4. The direction of the vector field with p+ outside the circle: ∆d points to the path function in
the direction of the center of the circle. With p0 , ∆d points perpendicularly to the path function.

y

p+ (t0 )

p− (t0 )

x
Figure 5.5. Path-following vector field Φd of a circle path function with the aerial robot starting inside
p− (t0 ) and outside p+ (t0 ) the circle.

than evaluating if the function reached a local minimum with ∇φj = 0 in Algorithm 5.1. The
algorithm then computes a simplified version of the next position on Line 4 using the current
position p(i) and the gradient ∆d φi without considering vehicles’ velocity v(i) and other parameters (such as external interferences, e.g., wind speed and direction). We can further simplify
Algorithm 5.2 and use the same value for the time step h that we used for the step size θ for all the
time instants in K.

84

Chapter 5. Coverage Planning and Scheduling

Input : t0 initial time step
ρ

1
2

ci value of the path parameters
j current stage
Output : p(K) trajectory
foreach i ∈ K := {t0 , t0 + h, t0 + 2h, . . . } do
if p(i) − pΓj ≤ ε then

3
4

return p(K)
ρ
p(i + h) ← p(i) + θ(i)∆d φj (p(i), cj )
Algorithm 5.2. Path function tracking

5.2

Coverage Path Planning

In this section, we solve Problem 2.5.2. Let us recall briefly our objective of providing a set of
paths (a tour) in the plan from Definition 2.4.2 that covers each point in a given space. We describe
the space with a set of vertices v := {v1 , v2 , . . . } that form a polygon. The aerial robot is free to
fly and compute anywhere within the polygon except for some no-interest zones (NIZs), where
it should avoid computations. These are described by other sets of vertices, one per each NIZ
o1 := {o1,1 , o1,2 , . . . }, o2 := {o2,1 , o2,2 , . . . }, . . . . There are several different approaches in
the literature to solve this problem. We have detailed some in Sections 3.3.2–3.3.3 for mobile
robots and in Sections 3.4.1–3.4.2 for aerial robots specifically. In summary, the sub-class of
motion planning that finds the coverage tour of a given space is called coverage path planning
(CPP) (H. Choset and Pignon, 1998). The CPP algorithms are NP-hard (E. M. Arkin, S. P. Fekete, et
al., 2000) and use (either implicitly or explicitly) the cellular decomposition, dividing the robot’s
free space into sub-regions that can be easily covered (H. Choset, 2001; Galceran and Carreras,
2013). Our approach extends one cellular decomposition method with the Zamboni-like motion
we introduced in Section 2.6.1, respecting the turning radius constraint of, e.g., the Opterra in the
precision agriculture use case. Fixed-wing aerial robots have limited maneuverability (Mannadiar
and Rekleitis, 2010; Xu et al., 2011, 2014), hence a large turning radius (X. Wang et al., 2017). The
decomposition is then between interest zones and NIZs; we compute over the former and solely
fly over the latter. We provided a partial solution in Section 2.6, which here we generalize. A strict
interpretation of NIZs as no-flight zones (NFZs), e.g., tall buildings in an urban monitoring use
case, is also possible. We consider this latter case in the future directions in Chapter 7.
There are numerous methodologies for cellular decomposition itself. Some decompose the
polygon into equally sized sub-regions that form a grid (see Figure 5.6) and then visits only the
sub-regions where the robot is free to move (Galceran and Carreras, 2013). This methodology
is termed grid decomposition. Another way is to sweep the polygon with a line and divide it
into sub-regions when the sweep line encounters a change in connectivity. We implement this
latter class in Section 5.2.1. Once the algorithm divides the free space into sub-region, it builds
an adjacency graph. The vertices contain the sub-regions, whereas the edges connect adjacent
sub-regions (H. M. Choset et al., 2005). A covering order between the sub-region to derive the

5.2. Coverage Path Planning

85

v2
v1
o1,2

o1,3
o1,4

o1,1

o1,5

o1,6

v3

v4
Figure 5.6. A polygonal space where we want to find a coverage tour and visit all the points delimited
by v := {v1 , . . . , v4 }. A way to cover the space is the grid decomposition that divides the polygon into
equally sized cells and visits each cell.

sequence of the coverage in the literature is then an exhaustive walkthrough of the adjacency
graph with, e.g., depth-first search algorithm (H. M. Choset et al., 2005). We use the covering
order in terms of future directions, analyzing the energy implications of different sub-coverages
against overall coverage avoiding computations over NIZs.
5.2.1

Cellular decomposition of the space

In detail, a cellular decomposition decomposes the coverage space into non-overlapping subregions called cells. Let us define the robot’s free space or the full coverage space as Qv for an
inertial navigation frame OW . Let Qoi ⊂ R2 be the space delimited by the NIZ oi . Physically,
the free space is where the robot is free to fly the coverage and compute the computations, Qoi
where it avoids computations. Qv ⊆ R2 contains all the points delimited by the vertices of the
polygon v except for NIZs delimited by the vertices of polygons in o. The entire space in the
S
polygon v, including all the NIZs o, is then Q := ( i∈|o| Qoi ) ∪ Qv . In Figure 5.7, the polygon
v2

Sx v
v1
o1,2
o1,1

o1,3
o1,4

c1

o1,5
c1

o1,6

v3

v4
Figure 5.7. The boustrophedon decomposition for coverage path planning sweeps the space and
adds cells in case the sweeping line encounters a change in connectivity. Figure shows an initial step
with c1 the first cell formed.

is delimited by v := {v1 , . . . , v4 } and forms Q, whereas the NIZ by o1 := {o1,1 , . . . , o1,6 }

86

Chapter 5. Coverage Planning and Scheduling

and forms Qo1 . The aerial robot in our implementation flies over Q but avoids computations
over Qo1 .
An important approach in the polygonal environment is the boustrophedon decomposition (H. Choset, 2000). For non-polygonal environments where v and oi are, e.g., elliptical functions, a significant result is the decomposition in terms of critical points of Morse functions (H.
Choset, E. Acar, et al., 2000). Both the boustrophedon decomposition and decomposition in
terms of critical points of Morse functions sweep Q with a line and decompose Qv adding a
cell in case of a change in connectivity or when they encounter a critical point (H. Choset, 2000,
2001; H. M. Choset et al., 2005). In Figure 5.8, the change in connectivity happens when the
v2

v10
v1

c2
o1,2

c2

o1,3

c1

o1,4

o1,1

c3

o1,5
o1,6

c1
v4

v3

c3
Sxo1,4

v40

Figure 5.8. An intermediate step of the boustrophedon decomposition, with c2 , c3 formed at the first
encounter of the NIZ o1 . The black points indicate the critical points or changes in connectivity.

sweeping line encounters the NIZ o1 . This approach optimizes the neighboring cells that can
be thus aggregated as opposed to, e.g., trapezoidal decomposition (Galceran and Carreras, 2013)
in Figure 5.9, which splits the space into cells when it encounters a vertex (LaValle, 2006). For
v2
v1

c2 c4

c6

c8
c2

c4

c6
c8

c1
c3
c1

c3

c5

c7

c5

c7

v3

v4
Figure 5.9. In the trapezoidal decomposition a lot of small cells are created (i.e., the cells c2 , c3 , c7 )
that can be otherwise merged resulting in disconnected coverage. Boustrophedon decomposition
solves the problem by splitting/merging the cells at critical points rather than at vertices. The resulting
tour has eight cells as opposed to four cells with boustrophedon decomposition in Figure 5.10.

the decomposition in terms of critical points of Morse functions, the intuition of using critical
points (H. Choset, E. Acar, et al., 2000) comes from some early studies on roadmaps (J. Canny,

5.2. Coverage Path Planning

87

1988a,b; J. F. Canny and M. C. Lin, 1993).

Notably, these studies show that topology (i.e., connectivity) changes only at critical points of a sweeping function restricted to the boundaries of
obstacle (or NIZs in our case). We briefly summarize some findings (H. Choset, E. Acar, et al.,
2000) for this latter method before discussing the coverage motion for the cells.
Let us define Sλ as the vertical sweeping function that sweeps Q. A change in the value of λ
moves the function in Q. Let further x v , x v be the highest and lowest coordinate x of all the
vertices in v, i.e., λ ∈ [x v , x v ]. If we refer to the sweeping function with at a specific point in
space as a slice, we can express the entire space as the union of all the slices, i.e., Q = ∪λ Sλ . Let
us further define the slice contained in the free space Sλv := Sλ ∩ Qv . At this point, a change in
connectivity of S v means that the original cell has to be closed and two more opened, or that two
cells are closed and one is opened respectively when the connectivity increases or decreases (H.
Choset, E. Acar, et al., 2000). In Figure 5.8, Sλ sweeps the space from λ = x v in Figure 5.7 up
to λ = xo1,1 . At this latter lambda, Sxo1,1 encounters a change in connectivity (Sxvo forms two
1,1
disconnected slices). The decomposition builds two new cells c2 , c3 , and adds these cells to the
adjacency graph. Sλ encounters another change in connectivity at λ = xo1,4 (Sxvo is again one
1,4
connected slice). This latter is different from the previous: the cells are merged with forming
a new cell c4 . The coverage tour which goes through Qv is then a visit through the adjacency
graph, resulting in the coverage order c1 , c2 , c4 , and finally c3 .
v20

v10
v1

c2
o1,2

v2
c4
c2

o1,3
o1,4

o1,1

c1

o1,5
o1,6

c1
v4

v40

c4

c3
v3

c3
v30

Sx v

Figure 5.10. The final step of the boustrophedon decomposition, where the sweeping line Sλ encounters the final point of its domain x v . The decomposition results in four cells. To determine the order of
the coverage tour, the methodology is to visit the adjacency graph.

In summary, the methodology iterates through the environment with Sλv in Figure 5.7. When
the connectivity of Sλv increases in Figure 5.8, it closes a cell and opens two new cells–the literature (H. Choset, E. Acar, et al., 2000; H. M. Choset et al., 2005) refers to these cells as ceiling and
floor cells (for c2 and c3 in Figure 5.10 respectively). When the connectivity decreases back in
Figure 5.10, the two opened cells are closed, and a new one is opened. The overall complexity is
P|o|
O(n log n) with n := |v| + i=1 |oi | the total number of vertices (H. Choset, E. Acar, et al.,
2000). Indeed, for polygonal environments, it is enough to verify the change in connectivity by
iterating the vertices and visit the constructed adjacency graph to find the coverage order.

88

5.2.2

Chapter 5. Coverage Planning and Scheduling

Coverage motion generation

Once we delimited the space to cover, the tour that travels through such space is termed the coverage motion. A classical approach in the literature is to travel back and forth. We saw in Chapter 3
and discussed briefly at the beginning of Section 5.2 that this is termed the boustrophedon motion. We propose a slight variation of this motion for our problem, which we introduced with
the intuitive path in Section 2.6.1 in Figure 2.6. The variation called the boustrophedon-like
motion optimizes the turns of the aerial robot flying. The past literature analyzes broadly turns
optimizations in the coverage for both mobile (Huang, 2001) and aerial robots (Artemenko et al.,
2016; Y. Li et al., 2011). The problem is that mobile robots are often subject to various constraints,
including the turning radius. The original boustrophedon motion has edges parallel to the polygon where a mobile robot might have to slow to perform the turn. For instance, a lawnmower
mobile robot would have to drive outside the path to turn efficiently (Huang, 2001). An aerial
robot traveling the boustrophedon motion might have to follow a greedy path planning algorithm instead or travel an additional turning maneuver such as a curlicue orbit (Xu et al., 2011,
2014). To this end, the boustrophedon-like motion in Section 2.6.1 considerably smooths the
turns. Given two following back and forth parallel lines in the original version, ours connects
these lines using a semi-circle of a given radius rather than connecting them with additional lines.
We illustrate how we cover merely the cell c1 in Q in Figure 5.10 using the boustrophedon-like
motion in Figure 5.11. The remaining cells are covered in the same manner. The overall coverage
v20

v10
v1

v4

c3

c2

v3

c4

c1
v40

v2

v30

Figure 5.11. The boustrophedon-like motion covering the cell c1 , composed of back and forth parallel
lines and circles connecting of radius half the ideal coverage distance.

is achieved by visiting the cells in the appropriate order derived in the previous section (c1 , c2 , c4 ,
and c3 ).
Let us assume for an instant that the turning radius in Problem 2.5.2 is not given. Let us further
assume that the aerial robot can overfly the boundaries of the polygons v and oi for the turns. The
methodology that outputs the plan Γ that covers Q with boustrophedon-like motion is to build
four paths: (a) the line φ1 from Figure 2.6 parallel to the edge formed by vertices v1 and v4 , (b) the
circle φ2 with the center laying on the edge formed by vertices v4 and v3 , (c) the line φ3 parallel
to φ1 that connects the right side of φ2 and extends up to the left side of φ4 , and (d) the circle φ4
whose center is on the edge formed by vertices v1 and v2 . The remaining paths φ5 , φ6 , . . . are

5.2. Coverage Path Planning

89

formed similarly. To evaluate the radius of the circles, let us assume the ideal distance between
the vertical lines in the motion (the lines φ1 , φ3 , φ5 , . . . ) is a given constant. Then the radius
in the plan (the circles φ2 , φ4 , φ6 , . . . ) is half the ideal distance. We can change the radius of
the circles and thus alter the quality of the coverage accordingly. Indeed our planning approach
consists of generating an initial plan that can be changed in a replanning phase using an optimal
control technique in Section 5.3.1 with the aerial robot being subject to uncertainty and external
interferences in flight.
Although the turns are considerably smoothed with the plan containing the boustrophedonlike motion, they are still impractical for fixed-wing aerial robots with the turning radius exceeding the radius of these turns (Dille and Singh, 2013; Xu et al., 2011, 2014). For this latter class of
robots, we propose the Zamboni-like motion. The Zamboni motion is in some literature for
fixed-wing aerial robots (Ablavsky and Snorrason, 2000; Araújo et al., 2013; Majeed and S. Lee,
2019). The name of this coverage motion comes from the hockey arenas’ ice maintenance machines (Ablavsky and Snorrason, 2000; Araújo et al., 2013; Dille and Singh, 2013), which have a large
turning radius like the aerial robots we study. They resurface the ice by sweeping distant lines first
instead of adjacent lines in a back and forth motion (the boustrophedon or boustrophedon-like
motions). The Zamboni-like motion is similar to the original Zamboni motion in the literature
but applied to our scenario with variable size of the coverage, enabling the possibility of future
coverage replanning in Section 5.3.1. We illustrate the Zamboni-like motion for c1 in Figure 5.12
(whereas the boustrophedon-like motion in Figure 5.11).

v1

v4

v20

v10
c2

c4

c1
v40

v2
c3

v3
v30

Figure 5.12. The Zamboni-like motion to cover the cell c1 . It is similar to the boustrophedon-like motion
in Figure 5.11 but travels distant lines first, respecting the large turning radius constraint of, e.g., the
fixed-wing aerial robots.

In Problem 2.5.2, we assumed the aerial robot can overfly the NIZs. The intuition is that
although the robot has a further computations constraint specifying that it cannot perform any
computation. For ease of notation, let us adopt the notation v1 |v|v| for an edge connecting vertices
v1 and v|v| (in this latter case, the first and last vertex). To generate the plan Γ that covers Qv
with the Zamboni-like motion we build four paths: (a) the line φ1 parallel to v1 |v|v| that extends

90

Chapter 5. Coverage Planning and Scheduling

from v|v| |v|v−1| to v1 |v2 (similarly to the boustrophedon-like motion), (b) the circle φ2 of which
the left side intersects the line that we just created and the right vx |vy with vx , vy ∈ v being two
vertices of the polygon v at a point xΓ2 (the name of the point is relative to the nomenclature in
Figure 2.7). This latter point depends on the radius of the circle r1 . For the following path, let us
call vx |vy the floor edge and vw |vz the corresponding ceiling edge constructed with the sweeping
function Sλ intersecting vw |vz at λ = xΓ2 , (c) the line φ3 parallel to φ1 that intersects the right
side of φ2 and extends from the ceiling to the floor edge at xΓ2 , and (d) the circle φ4 of a given
radius and a parameter introduced in Section 2.6.1. The left edge of the circle lays on φ3 , whereas
the right intersects another edge of the polygon. In Figure 5.12, the circle intersects v1 |v2 . Once
we built these four paths, let us assume the polygon is regular and composed of four edges. It is
then enough to generate the coverage tour from the primitive paths φ1 , . . . , φ4 with a shift d in
the same way as we did in Section 2.6.1. The corresponding plan Γ contains the stages and some
additional NIZs dependent constraints: to perform the computations only in Qv , or analogously,
cells c1 , c2 , . . . coming from the cellular decomposition in Section 5.2.1. We discuss the actual
implementation of the aerial robot flying the plan Γ in the next section, where we execute the
plan according to the constraints (of the plan and the cellular decomposition) and replan the
original plan in case of unexpected and uncertainty-driven events. For the plan Γ, we thus use the
Equations (2.13–2.14) for the paths, and Equation (2.15) for the triggering points (i.e., the points
in Definition 2.3.2 where happens the change of the path).
If the polygon is not regular and composed of four edges, we still build the remaining paths
in the plan Γ φ5 , φ6 , . . . starting from the primitive paths with slight variations. If, for example, the ceiling edge points higher than the floor edge, the line segments φ5 , φ9 , φ13 , . . . and
φ7 , φ11 , φ15 , . . . are longer than φ1 and φ3 of a given rate. If, on the contrary, the ceiling edge
points lower than the floor edge, the line segments are shorter. Complex shapes are equally possible by, e.g., generating the plan online at each period (i.e., the time needed to fly primitive paths
in Definition 2.4.3).
The complexity of the coverage motion generation algorithm for a cell that returns Γ with the
primitive paths is simply the complexity of building then the four primitive paths φ1 , . . . , φ4 .
We saw that this is enough to cover both a complex polygon or a regular one with four edges
in Figure 5.12, and thus the running time is constant O(1). The overall complexity of cellular
decomposition of a polygon and the plan generation is thus O(n log n), where n is the number
of vertices v and the vertices of NIZs o (H. Choset, E. Acar, et al., 2000).

5.3

Energy-Aware Coverage Replanning and Scheduling

In this section, we solve Problem 2.5.1, finding the optimal control in the model in Section 4.3.2,
ρ
the configuration of the path the aerial robot is flying ci , and computations it is computing
ciσ . The path configuration is relative to the coverage (we built the paths for a coverage tour in
Section 5.2); the computations configuration in the precision agriculture use case to the hazard
detection (we discussed the computations running on the robot in the use case in Section 2.6.2).

5.3. Energy-Aware Coverage Replanning and Scheduling

91

Generally, the exact final time instant tl , when the aerial robot reaches the final point p(tl ) =
pΓl in the last stage Γl , is unknown. We hence derive the optimal control on a finite horizon rather
than the entire time frame [t0 , tl ] with MPC or receding horizon predictive control (RHPC), an
optimal control technique extensively treated in modern optimal control literature (Camacho and
Alba, 2007; Kwon and Han, 2005; Rawlings et al., 2017; Rossiter, 2004; L. Wang, 2009). A problem
of the generic optimal control is its difficulty and computational complexity. MPC overcomes
this difficulty by optimizing for “a bit” of the time frame at each optimization step with no a
priori knowledge of tl (Camacho and Alba, 2007). It forecasts the system behavior–the energy
evolution–and optimizes the forecast to derive a control action (Rawlings et al., 2017). There have
been many MPC developments in optimal control literature. These range from robust (where
the model is subject to uncertainty), output (where noisy sensors’ data estimates a model state),
to distributed MPC (that splits the original MPC into sub-problems) (Camacho and Alba, 2007;
Kwon and Han, 2005; Rawlings et al., 2017; Rossiter, 2004; L. Wang, 2009).
In detail, we derive an approach that uses the model in Section 4.3 in the cost and constraints
of an optimal control problem (OCP) subsequently solved with MPC. Similar approaches are
being studied in modern aerial robotics literature. These include studies that apply MPC in
path following (Gavilan et al., 2015), trajectory tracking (Torrente et al., 2021), and involving
fixed (Cavanini et al., 2021; Chao et al., 2011; Kang and Hedrick, 2009; Stastny and Siegwart, 2018)
and rotary-wings (Bicego et al., 2020; Kostadinov and Scaramuzza, 2020; Song and Scaramuzza,
2020). Planning-scheduling energy awareness is also the object of study in the context of optimal
control on a finite horizon (Ondrúška et al., 2015; W. Zhang and J. Hu, 2007), along with various
optimization techniques (Brateman et al., 2006; Lahijanian et al., 2018). A detailed discussion of
the state-of-the-art is in Chapter 3; for planning-scheduling in Section 3.5.
In Section 5.3.1, we discuss output MPC that we use for replanning of Γ: a technique that uses
estimates to refine the state of a model and thus to derive a control action robust to noise (Rawlings
et al., 2017). We then provide a further construct to include the battery model from Section 4.2
and derive the OCP in Sections 5.3.2–5.3.3. In Section 5.3.4, we dig further into the implementation discretizing the OCP, and finally, in Section 5.3.5, we discuss an algorithm for the coverage
replanning and scheduling.

5.3.1

Output model predictive control

The literature commonly refers to the problem of applying MPC to a system with an unknown
state q as output MPC. A variation where estimates q̂ refine the state of a perfect model via state
estimation for a system of which the state is not fully known (indeed, the name refers to the
notion that some available outputs estimate the state) (Rawlings et al., 2017). For a differential
model, such as Equation (4.10) in Section 4.3, state estimation uses filtering techniques that include
Kalman filtering (Kalman, 1960; Simon, 2006).
In our work, we do not know the state of our model (the coefficients of q that we presented
in Section 4.3.2), which we estimate in this section from the energy sensors measurements. Furthermore, the control differs from the nominal control in the model; in the observation in Sec-

92

Chapter 5. Coverage Planning and Scheduling

tion 4.3.2, we

presented a motivation for such control based on empirical data. The nominal
control maps the change in path and computations parameter to the change in time and power
consumption. We use the latter to see how computations affect instantaneous energy (what happens to the power if we increase/decrease computations?), and the former to estimate the time
needed to cover a given space and thus to the overall energy consumption (what happens to the
energy if we increase/decrease the quality of the coverage?). To this end, the algorithm that we
propose in Section 5.3.5 uses the change in : (a) path parameters to verify whenever a given path
configuration can be done with the current state of charge (SoC) of the battery, (b) computations
parameters to check that the computations configuration is within the battery maximum instantaneous energy consumption. While the former constraint is critical (having less battery SoC
than needed would result in an abrupt flight termination), the latter does not necessarily imply a
plan failure. Indeed the maximum instantaneous energy consumption is an approximated value
derived from the battery model in Section 4.2. However, exceeding such value might degrade
battery performance since the capacity fade of Li-ion batteries is related to different discharging
(and charging) strategies (Lv et al., 2020; Tian et al., 2019). Including this information allows
future analysis on different energy-aware methodologies by, e.g., analyzing the cost of sudden
spikes on the battery life as opposed to constant energy drain. We have conducted an early analysis in this direction (Seewald, Schultz, Ebeid, et al., 2021a), concluding that the spikes that our
scheduler generates are not enough to show a visible effect on the battery life. Nonetheless, there
are multiple optimizations possible within battery energy awareness, most of which depend on
different battery chemistries (Tian et al., 2019) that are not the scope of this work. We discuss
different future directions, including accurate battery optimizations in Chapter 7.
For the sole purpose of exemplification, we discuss the observation in Section 4.3.2 relative to
the coverage path visually, showing how a change in the coverage affects the energy. We discussed
the energy effect of the change of computations on power in Section 4.3.2. It is due to different
schedules on the computing hardware. We observe a decrement in the power consumption
intuitively by running at lower frames per second (FPS) rate (Seewald, García de Marina, Midtiby,
et al., 2020; Seewald, Schultz, Ebeid, et al., 2021a; Zamanakos et al., 2020). The energy effect of
the change of path is due to the length of the coverage path. We elucidate what we mean by this
latter statement in Figures 5.12–5.13, where each figure represents the same coverage but different
radiuses r2 of the fourth circle φ4 in the primitive paths φ1 , . . . , φ4 of the Zamboni-like motion
in Section 5.2.2. Figure 5.12 showed the coverage with the highest configuration of parameter
c4,1 . If we assume that the time needed to travel the circle φ4 (c 4,1 ) is t3 , the vertical lines φ1 , φ3
is 2t1 , and the circle φ2 is t2 , then the overall time to cover c1 with configuration c4,1 = c 4,1 is
tc4,1 = 7(2t1 + t2 + t3 ) + t1 .

(5.8)

Conversely, in Figure 5.13, we assume that the time needed to travel φ4 (c 4,1 ) is t4 ; then the time
needed to cover c1 with configuration c4,1 = c 4,1 is
tc4,1 = 3(2t1 + t2 + t4 ) + t1 .

(5.9)

5.3. Energy-Aware Coverage Replanning and Scheduling

v4

v20

v10

v1

c4
v40

v2
c3

c2

c1

93

v30

v3

Figure 5.13. The Zamboni-like motion to cover the cell c1 with the lowest configuration of parameter
c4,1 relative to the radius of the circle φ4 .

It is clear that t4 < t3 and thus tc4,1 < tc4,1 . If we further assume that traveling all the paths
take a similar time t1 ≈ t2 ≈ t3 ≈ t4 , then we can observe a 45% time reduction in flying
Figure 5.13 compared to flying Figure 5.12. Analogously, in the energy domain, we can expect
a considerable reduction in the battery drain with c4,1 = c 4,1 compared to c4,1 = c 4,1 . Our
purpose in the remainder is to find the configuration of the path (in the latter case of c4,1 ) along
with the computations parameters to maximize the coverage with SoC higher than zero–to find
the optimal control on N w.r.t. a given energy cost.
5.3.2

Re-evaluation of the output constraint

The model output in Equation (4.10) is the power (instantaneous energy consumption) that we
stated earlier evolves in y ∈ R. Nevertheless, the power drainable from a battery at any time
instant is limited. Hence, we redefine the original output constraint to include the battery model
in Section 4.2. To this end, we consider SoC b of the mobile robot’s battery with the model in
Equations (4.5–4.8) using an equivalent electrical circuit


q
2
(5.10)
ḃ(y(t)) = −kb V − V − 4Rr y(t) /(2Rr Qc ),
where kb is an additional battery coefficient determined experimentally, and the values of V , Rr ,
and Qc are detailed in Equations (4.5–4.8). In summary, we derived Equation (5.10) in Section 4.2
from the literature on the battery SoC in Section 3.2, using the “Rint” equivalent electrical
circuit (He et al., 2011; Hinz, 2019; Mousavi G. and Nikdel, 2014).
Using the expression to estimate SoC in Equation (5.10), we can calculate the maximum instantaneous energy consumption by multiplying the constant nominal capacity, the SoC, and
the internal battery voltage. We assume the maximum energy consumption cannot be negative
0 ≤ y(t) ≤ b(y(t))Qc V ,

(5.11)

94

Chapter 5. Coverage Planning and Scheduling

and therefore, we define a time-varying constraint for the output in Definition 5.3.1, being the
maximum instantaneous energy consumption dependent on the SoC b from Equation (5.10).
Definition 5.3.1: Output constraint.

Y(t) := {y | y ∈ [0, b(y(t))Qc V ] ⊆ R≥0 },
is the output constraint, where b(y(t))Qc V is the maximum instantaneous energy consumption.
We assume the aerial robot carries a sensor to obtain the initial SoC b(y(t0 )) in the output
constraint. This is a realistic assumption. Aerial robots often have a flight controller, which returns various metrics. The current SoC can be estimated from, e.g., the voltage. Evaluating the
constraint requires numerical simulation: the battery model in Equation (5.10) is differential, similarly to the energy dynamics of the periodic model in Equation (4.10). We compute the numerical
simulation using, e.g., the Euler or the Runge-Kutta methods (Iserles, 2009). In Algorithm 5.3,
we use the Euler method.
We use the output constraint set in an OCP formulation of Problem 2.5.1 in the next section.
5.3.3

Derivation of an optimal control problem

An OCP that selects the highest configuration of parameters (control) at each time step while
respecting all the constraints we defined so far can be expressed
Z
max lf (q(T ), T ) +

q(t),ci (t)

T

t0

l(q(t), ci (t), t) dt,

(5.12a)

s.t. q̇ = f(q(t), ci (t), t),

(5.12b)

ci (t) ∈ Ui , q(t) ∈ Rm ,

(5.12c)

y(t) ∈ Y(t),

(5.12d)
v

Si,j := {0}, ∀j ∈ [σ ] when p(t) ∈
/ Q ,

(5.12e)

q(t0 ) = q̂0 given (last estimated state), and

(5.12f)

b(y(t0 )) = b0 given,

(5.12g)

where constraints in Equations (5.12b–5.12e) are evaluated on t ∈ [t0 , T ]. q(t) and ci (t) are the
state and control trajectories, and p(t) is the aerial robot’s trajectory w.r.t. an inertial navigation
frame OW . The sizes of the state and control (m and n) are defined in Sections 4.3.1–4.3.2. By
solving the OCP in Equation (5.12), we want to derive the trajectory
∗
∗
∗
∗
ci∗ (t) = {ci,1
(t), . . . , ci,ρ
(t), ci,ρ+1
(t), . . . , ci,ρ+σ
(t)},

(5.13)

for a given stage i in Definition 2.3.1. In the max term in Equation (5.12), we further derive the
trajectory of the ideal state q(t), which we use to derive the optimal control and, e.g., to evaluate
the model’s fidelity against future measured data. Indeed the solution to the OCP evolves the
model from an estimate of the state at the initial time instant t0 in Equation (5.12f). At the very

5.3. Energy-Aware Coverage Replanning and Scheduling

95

beginning of the optimization (when t0 corresponds to the initial time instant of the flight), we
will see in Section 6.3.1 that the perfect model evolution in Equation (5.12b) does not correspond
to the data despite converging later on. The constraints contain the control and state constraint
from Equation (2.6), the output constraint from Definition 5.3.1, and the dynamics with the ideal
state evolution from Equation (4.10) in Equations (5.12b–5.12d). The OCP further contains the
coverage constraint from Section 2.6.1 and Section 5.2.2 in Equation (5.12e). Although the aerial
robot can overfly the NIZs and the polygon edges, it cannot compute any computation. Formally,
we inhibit the computations setting their constraint to {0} when the aerial robot is flying over
the ith NIZ oi and out of the polygon v (it is thus out of the space Qv ). We have similarly
inhibited the computations out of the polygon v in Section 2.6.1.
The dynamic evolution in Equation (5.12b) is then the periodic model in Equation (4.10) together with the scale transformation from Section 4.3.3
f(q(t), ci (t), t) = Aq(t) + Bdiag(νi )(ci (t) − ci (t − ∆t)),

(5.14)

where ci (t − ∆t) is the control at the time instant preceding t, A is the state transition matrix
in Equation (4.12), B the input matrix in Equation (4.46), and νi is the scale transformation in
Equation (4.47). The scaling factors for the first ρ path parameters are given in Equation (4.48)
and for the remaining σ computations parameters in Equation (4.49).
The instantaneous cost function is the quadratic expression
l(q(t), ci (t), t) = q0 (t)Qq(t) + ci0 (t)Rci (t),

(5.15)

where Q ∈ Rm×m , R ∈ Rn×n are given positive semidefinite matrices, resulting in the convexity
of the cost l (Nocedal and S. Wright, 2006) and some solution guarantees (Beck, 2014).
The final cost function is also a quadratic expression but with no control (Rawlings et al., 2017)
lf (q(T ), T ) = q0 (T )Qf q(T ),

(5.16)

where Qf ∈ Rm×m is a given positive semidefinite matrix.
The horizon N is in seconds, and the controller selects the optimal control trajectory ci∗ (t)
over [t0 , T ], with T = t0 + N. At each instant, the controller refines the control trajectory
(replans the coverage and derives the schedule) that respects the constraints. To evaluate the
state trajectory–needed for the instantaneous cost function l and the final cost function lf –the
controller evaluates the battery trajectory b(y(t)) (it has to verify that the output is in Y(t)). It
then maximizes the instantaneous cost function l for all the time instants but T (t0 ≤ t <
t0 + N), and the final cost function lf in Equation (5.16) for the time instant T (t = t0 + N).
The dynamics constraint satisfaction requires to evolve the perfect model f in Equation (5.14)
over horizon [t0 , t0 + N] beginning from the last estimated state q(t0 ) = q̂0 at time instant
t0 . Similarly, the output constraint satisfaction requires then to evolve the battery model b in
Equation (5.10) over [t0 , t0 + N], from b(y(t0 )) = b0 , the last battery measurement at instant
t0 .
The OCP in Equation (5.12) is infinite-dimensional, being the system dynamics in Equation (5.12b) and the battery dynamics in Equation (5.10) given in continuous- and not discretetime, and the cost integrated over the interval. Such an infinite-dimensional OCP has infinite

96

Chapter 5. Coverage Planning and Scheduling

dimensions of constraints and decision variables since there are infinitely many time instants
between t0 and t0 + N. We discretize the OCP to finite dimensions in Section 5.3.4.
5.3.4

Coverage replanning and scheduling: Discretization

In this section, we discretize the infinite-dimensional OCP in Equation (5.12), which result we can
subsequently solve in Section 5.3.5. There are different techniques for this purpose (Grüne and
Pannek, 2017; Rawlings et al., 2017); some relevant to our approach are the direct methods already
employed in many MPC-related applications (Rawlings et al., 2017), which include the single
and multiple shooting methods. They parametrize the control and state trajectories with a finitedimensional vector and derive a nonlinear program (NLP) (Rawlings et al., 2017). Both the methods compute the discretization, but the resulting NLP differs. The multiple shooting method
keeps the states as decision variables at the boundary time points, allowing further optimizations (Rawlings et al., 2017). It combines some of the advantages of the other methods, including
a popular method called the direct collocation method, together with the direct single shooting
method (Diehl et al., 2006; Grüne and Pannek, 2017). Once we obtain the finite-dimensional NLP,
we can solve it numerically with the numerical solvers available in the literature (Diehl et al., 2006;
Grüne and Pannek, 2017; Nocedal and S. Wright, 2006).
A possible NLP derived from discretizing the OCP in Equation (5.12) is then
X
max lf (q(T ), T ) +
ld (q(k), ci (k), k),
(5.17a)
q(k),ci (k)

k∈K

s.t. q(k + h) = fd (q(k), ci (k), k),

(5.17b)

ci (k) ∈ Ui , q(k) ∈ Rm ,

(5.17c)

y(k) ∈ Y(k),

(5.17d)
v

Si,j := {0}, ∀j ∈ [σ ] when p(k) ∈
/ Q ,

(5.17e)

q(t0 ) = q̂0 given (last estimated state), and

(5.17f)

b(y(t0 )) = b0 given,

(5.17g)

where the constraints in Equations (5.17b–5.17e) are evaluated now on a finite interval k ∈ K =
{t0 , t0 + h, t0 + 2h, . . . , T }, and h is a given time step or distance between two consecutive
time instants; the smaller the distance, the more precise the simulation. The other expressions
are analogous to Equation (5.12).
We use numerical simulation to transform Equation (5.12) into Equation (5.17) (Iserles, 2009)
the instantaneous cost function
ld (q(k), ci (k), k) = hl(q(k), ci (k), k),

(5.18)

where l is given in Equation (5.15).
The discrete dynamic evolution in Equation (5.17b)
fd (q(k), ci (k), k) = Ad q(k) + Bdiag(νi )(ci (k) − ci (k − h)),

(5.19)

5.3. Energy-Aware Coverage Replanning and Scheduling

97

where Ad is the discretized version of the state transition matrix A in Equation (4.12) and for a
small enough interval of h
Ad = (hA + diag(1, 1, . . . , 1)),

(5.20)

where diag(1, 1, . . . , 1) ∈ Rm×m is a diagonal matrix of ones. B is then the input matrix in
Equation (4.46), and νi is the scale transformation in Equation (4.47) with the scaling factors that
for the first ρ path parameters are given in Equation (4.48) and for the remaining σ computations
parameters in Equation (4.49), similarly to Equation (5.14).
To discretize the battery dynamics in Equation (5.10), we use
bd (y(k + h)) = b(y(k)) + hb(y(k + h)),

(5.21)

where b is given in Equation (5.10) and y(k) is the output of the model in Equation (4.10b). The
matrix C is to be found in Equation (4.14).
In Equation (5.17), we transformed the OCP in Equation (5.12) into an NLP by first discretizing
and thus effectively implementing the direct multiple shooting method (Rawlings et al., 2017).
We note that we can implement the single shooting method by keeping only the initial state
as the decision variable q̂0 , conversely to using the interval boundary time points as a decision
variable in the multiple shooting method (Rawlings et al., 2017).
Practical implementation requires a rational choice of h in Equations (5.18–5.21), weighting
precision with execution time. For instance, to speed the derivation of the configuration in Section 6.3, we use different hs for Equations (5.19–5.21) and the set K along with the cost in Equation (5.18).
5.3.5

Coverage replanning and scheduling: Algorithm

Finally, Algorithm 5.3 provides the optimal configuration of path and computations parameters
and thus computes the coverage replanning and scheduling. It inputs the initial plan Γ along
with the initial time step and a guess for the energy model q̂(t0 ), and outputs the revised plan,
deriving the configuration of parameters ci∗ in Equation (5.13). It optionally inputs then the
initial stage that is within [n]>0 when Γ compromise primitive stages, [l]>0 otherwise. In the
remainder of this chapter, we discuss in detail the algorithm.
It iterates at each time step h ∈ R>0 on Line 1, with the size of h related to the accuracy and
the time needed for replanning. The higher the step, the lower the accuracy, but the shorter the
time necessary to replan Γ. Nonetheless, there are further constraints on h due to the numerical
simulation algorithm. h has to be small enough (h → 0) so that the numerical simulation (on
Line 10, 14, 15, and 22) does not diverge. To this end, a typical value for h that we adopted is
1/100 of a second. There are various techniques to estimate h more accurately, e.g., by running
the numerical simulation and analyzing the error of two different guesses (Iserles, 2009). Such
techniques are, however, beyond the scope of this work. With a small enough h, Euler method
that we use in Equations (5.18–5.21) converges to the real solution–see (Atkinson et al., 2009;
Iserles, 2009) for a formal proof–whereas for problems with higher accuracy we advise the RungeKutta methods that are among the most popular methods for numerical simulation (Atkinson

98

Chapter 5. Coverage Planning and Scheduling

Input : Γ initial plan

1
2
3
4
5
6
7
8
9

t0 initial time step
q̂(t0 ) initial guess for the energy model
j starting stage within the primitive stages ∈ [n]>0 otherwise j = 1
Output : Γ revised plan
foreach i ∈ {t0 , t0 + h, t0 + 2h, . . . } do
if p(i) 6= pΓl then
return Γ

if p(i)

= pΓj then
j ←j +1
if j ∈
/ [n]>0 then
j←1
φ1 , φ2 , . . . , φn ← shift φ1 , φ2 , . . . , φn of d
pΓ1 , pΓ2 , . . . , pΓn ← shift also pΓ1 , pΓ2 , . . . , pΓn of d

10

q(K \ {i + N}), cj (K) ← solve NLP arg maxq(k),cj (k) lf (q(i + N), i + N)+
P
k∈K ld (q(k), cj (k), k) from Equation (5.17) on K = {i, i + h, . . . , i + N}

11

k ←i
while bd (C q(k)) > 0 do
if k ∈
/ K then
q(k + h) ← Ad q(k)

12
13
14
15
16
17



p
bd (C q(k +h)) ← bd (C q(k))−hkb V − V 2 − 4Rr C q(k + h) /(2Rr Qc )

k ←k +h
tb ← k − i
ρ

18
19
20
21
22
23
24
25
26
27
28

z
}|
{
ρ ρ
ρ
ts ← (diag(νj )cj (i) + τj )[1 1 · · · 1]
tr ← (ts /t)(t − i)
if tr < tb then
ρ
ρ
ρ
cj (i) ← find cj with tc ∈ [0, tb ], otherwise take c j
q̂(i + h) ← Ad q̂(i) + Bdiag(νj )(cj (i) − cj (i − h))
P(i + h)− ← Ad P(i)Ad0 + S(i)
K (i + h) ← (P(i + h)− C 0 )/(C P(i + h)− C 0 + V (i))
q̂(i + h) ← compute q̂(i + h) + K (i + h)(y(i) − C q̂(i + h)) from energy sensor y(i)
ŷ(i + h) + C q̂(i + h)
P(i + h) ← (I + K (i + h)C )P(i + h)−
p(i + h) ← compute from position p(i), velocity v(i) with ∆d φj in Algorith 5.2
Algorithm 5.3. Coverage replanning and scheduling algorithm

5.3. Energy-Aware Coverage Replanning and Scheduling

99

et al., 2009). These methods use quadrature, a procedure that replaces the integral with a finite

sum (Iserles, 2009). We use a Runge-Kutta method inside the powprofiler tool in Section 4.2.2
and the Euler method in Algorithm 5.3.
On Lines 2–3, the algorithm verifies if the aerial robot reached the final point pΓl in Definition 2.3.2 and returns the replanned plan Γ in this latter eventuality. On Lines 4–9, it switches
the stages when the aerial robot reaches a triggering point (also in Definition 2.3.2). If Γ contains
n primitive paths rather than all the stages up to l explicitly, on Lines 8–9, it updates the paths
and the triggering points with the shift d when it reaches pΓn (otherwise it ignores Lines 8–9;
the shift is zero). It then selects the energy-aware configuration of computations on Line 10 by
solving the NLP in Equation (5.17) derived from the OCP in Equation (5.12) using the multiple
shooting method. It thus obtains the trajectory of the controls and states for a given horizon
N expressed in seconds. In particular, the control trajectory contains |K| − 1 items, whereas
the state trajectory |K| items. This discrepancy in the number of sets of the two trajectories is
due to the construction of the OCP. We provide an initial guess for the state q(i) at time instant i but derive the first control cj (i) already from the solution to the OCP. For the horizon
N, we adopted the value of N equal to, e.g., six and ten seconds in Section 6.3, meaning the
algorithm evolves the models in Equation (5.14) and Equation (4.10) for ten future seconds and
selects the control trajectory cj∗ that minimizes the costs in Equation (5.18) and Equation (5.16).
The higher the horizon, the better the accuracy. A typical value in the aerial robotics literature
that implements MPC (Chao et al., 2011; Gavilan et al., 2015; Kang and Hedrick, 2009; Stastny
and Siegwart, 2018) is of dozens of seconds. For instance, it is fourteen in Gavilan et al., ten and
forty in Kang and Hedrick, two to eight in Stastny and Siegwart, and five in Chao et al.
To solve the NLP in Equation (5.17),the algorithm evaluates the constraints in Equations (5.17b–
5.17e) (t0 in the latest two constraints is equal to i), where it has to numerically simulate both
the energy and the battery models from i to i + N with a step size of h. A possible optimization we mentioned in Section 5.3.4 that considerably speeds up the derivation of the optimal control is to use different horizons for numerical simulation and the constraints, i.e.,
H = i, i + nh, i + 2h, i + N, where n ∈ [1, 1/h]. When n is equal to 1/h, the algorithm
adds the constraints at each second but numerically simulates the models on K. Practically, we
implement the MPC on Line 10 using a software framework for nonlinear optimization termed
CasADi (J. A. Andersson et al., 2019; J. Andersson et al., 2012a,b), and a popular NLP solver
called IPOPT (Wächter and Biegler, 2006).
On Lines 22–27, the algorithm estimates the state q of the periodic model in Section 4.3, with
Kalman filtering from the energy sensor’s measurements y(i). The Kalman filter has several
important properties over other methods for state estimation, and among the others, minimizes
the variance of the estimation mean square error (MSE) (Jwo and Cho, 2007; Kalman, 1960;
Simon, 2006). On Line 22, the algorithm computes the a priori, and on Line 25 the a posteriori
state estimation. On Line 23, the a priori covariance state error with P, the covariance of the state
estimation error. We provide an initial guess of P(t0 ) ∈ Rm×m , the covariance error of q(t0 ),
and of the trajectories of S ∈ Rm×m and V ∈ R, the covariances of the state and output noise.

100

Chapter 5. Coverage Planning and Scheduling

On Line 24, the algorithm computes the gain with V (Simon, 2006). To ease the computations,
we keep the covariances fixed in our experimental setup in Section 6.3.
On Lines 11–17, the algorithm estimates the time needed to completely drain the battery with
the differential model in Equation (5.21), using the Euler method for numerical simulation . A
possible optimization in this set of lines is to utilize the state already from MPC on Line 10
for future energy prediction on the horizon N; at further time horizons, we do not have any
trajectory for the control available and thus keep cj (k) = cj (i + N − h), ∀k > i + N −
h. The variable tb on Line 17 contains the estimated available battery time. On Line 18, the
algorithm then computes the scale transformation from the path parameters domain to the time
domain from Section 4.3.3, and on Line 19, the estimated remaining time. It selects a different
configuration of path parameters when the battery time is lower than the remaining time on
Line 21. Finally, on Line 28, the algorithm computes the next position in space using the vector
field for guidance in Section 5.1, where v(i) ∈ R≥0 is the velocity and p(i) the position at the
current time step i.

5.4

Summary

This chapter detailed the derivation of a guidance action for a coverage plan, coverage plan itself,
and energy-aware configuration of both the path and computations, solving the coverage and
planning problems. The guidance uses a path-following gradient descent algorithm in the literature, further adapted to the coverage planning and scheduling. The plan is indeed composed
of multiple path functions that switch at specific triggering points. The algorithm exploits the
theory of vector fields. It points to the path corresponding to the current coverage stage at each
location in space. The coverage integrates a known method named boustrophedon decomposition, deriving a fixed-wing friendly covering tour with the Zamboni-like motion. Both the
coverage and the schedule are varied within specific limits to alter the energy and power by, e.g.,
changing the distance between the coverage lines or the detection rate. The chapter thus proposes
an optimal control-based algorithm for such replanning. The algorithm uses MPC and Kalman
filtering and exploits the computations, motion, and battery models from the previous chapter
to derive the best trajectory of both path and computations variations. In the next chapter, we
show the algorithms both using numerical and Paparazzi flight controller-based simulations.

Chapter 6

Results
“[Computing energy included motion planning] shows improved performance over the
baseline and looks to be promising solution to the low-power motion planning problem.”
— Sudhakar et al., 2020

n t h i s c hapter, we report some results both published in our early studies (Seewald,
García de Marina, Midtiby, et al., 2020; Seewald, Schultz, Ebeid, et al., 2021a) and to appear in a
forthcoming study (Seewald, García de Marina, and Schultz, n.d.), validating our overall approach
of energy-aware coverage planning and scheduling for autonomous aerial robots. The chapter
thus connects to the remainder of the work by describing our experimental setup and results. It
involves Chapters 4–5, which contains our most notable contribution: the energy and battery
models for both the computation and motion of an aerial robot and a coverage planning and
scheduling technique that uses the models. Chapter 2 is limitedly involved as well: we extensively
use the agricultural use case we introduced in Section 2.6 to showcase our approach, along with
other formalities we proposed in the chapter.
The remainder of this chapter is structured as follows. In Section 6.1, we describe our experimental setup and results for the computations energy model obtained with the powprofiler
tool. We then detail case studies of the motion energy of an aerial robot flying a path similar
to Section 2.6 independently and along with the computing hardware in Section 6.2. In both
Sections 6.1–6.2, we describe our experimental setup for a battery of the computing hardware,
aerial robot, and computing hardware with the aerial robot, detailing for each the results. In Section 6.3, we then describe the coverage planning and scheduling in Matlab (R) and the popular
Paparazzi flight controller (Paparazzi, n.d.[b]) and thus, validate our work experimentally.

I

101

102

Chapter 6. Results

12
5.8 FPS

10 FPS

25 FPS

32 FPS

total
CPU
GPU

9
6
3

Power (W)

0
12
9
6
3
0
0

20

40

60

0

20

40

60

Time (s)
Figure 6.1. The darknet-gpu computation measurement layer models, featuring the GPU implementation of the YOLO (Redmon, Divvala, et al., 2016) DNN library modified to introduce delays between
detections. From top left in horizontal order to bottom right, the figure shows the schedules from
approximately six up to thirty-two FPS. The figure appeared in our early study (Seewald, Schultz,
Ebeid, et al., 2021a).

6.1

Computations Energy Modeling

In this section, we describe the results and the experimental setup to obtain computations energy models with the powprofiler tool. We report how we derive both the measurement and
predictive layers from Sections 4.1.2–4.1.3 and the battery model from Section 4.2 to integrate
the two layers with the battery contribution for the computing hardware.
6.1.1

The darknet-gpu computation

In Figure 6.1, we illustrate a concrete example of four different measurement layers from our
early contribution (Seewald, Schultz, Ebeid, et al., 2021a): the power evolution in the function of
time for three measuring devices, CPU, GPU, and overall of the NVIDIA Jetson TX2 computing hardware. The model is relative to one computation with four different schedules where we
observed notable differences in instantaneous and overall energies. The computation consists of
an object detection algorithm that we term darknet-gpu, a neural network-based pattern recognition utility. It is a standard computer vision computation, built upon the darknet (Redmon,
2013–2016; Redmon and Farhadi, 2017) GPU implementation of a deep neural network (DNN)
library YOLO (Redmon, Divvala, et al., 2016), which detects the objects on some pre-trained as
well as trained networks (the latter to detect a personalized set of objects).

6.1. Computations Energy Modeling

0.8

103

75

0.4

50

0.2

25

0

SoC (%)

Energy (kJ)

0.6

100

energy
SoC

total
GPU
CPU

0
5.8

10

25

32

6

12

18

24

30

FPS
Figure 6.2. Per-minute energy consumption and SoC of the darknet-gpu computation in terms of
CPU, GPU, and overall energies. On the right is the resulting predictive layer that shows the energy
(same scale as on the left) and battery SoC in the function of any possible configuration. The figure
is from our early study (Seewald, Schultz, Ebeid, et al., 2021a).

In an initial iteration of our work (TeamPlay Consortium, 2019a), we trained the network using
images of different shapes and colors for a search and rescue aerial robotics use case where the
robot detects vessels on the sea. We benchmarked the corresponding computation on a video
stream of vessels in an offshore area, simulating an aerial robot flying the use case with a camera.
We further modified the darknet-gpu computation to simulate different scheduling options,
such that the computation can be altered with a given parameter, which we call ci,1 in accordance
to Definition 2.3.1 ∀ i ∈ [l] (with the plan lasting assigned l stages). The parameter indicates the
delay between two invocations of the detection, simulating different frames per second (FPS)
rates. We schedule the computation with the parameter ci,1 to assess the predictive layer in
Figure 6.2. On the right of the figure, we further illustrate the battery state of charge (SoC) in
the function of varying FPS for the overall power measuring device of the computing hardware
(dashed line). Similarly, the predictive layer provides the evolution of the energy also in the
function of varying FPS (continuous line).
We used a frequency of ten hertz and a running time of one minute to derive all the measurement layers. The energy measure in Figure 6.2 is then relative to the energy needed to run
the computation for a minute and the correspondent remaining SoC. For the latter, we used an
integration step of one hundredth, internal battery voltage V of 14.8 volts, internal resistance
Rr of 1.2 milliohms, stabilized voltage Vs of twelve volts, and battery capacity Qc of five amperes
per hour in Equations (4.5–4.8) in Section 4.2.1. The parameters that correspond to such configurations are frequency=10, h=0.01, and runtime=60000 in the specification in Section 4.1.5,
whereas the battery values are specified while invoking the constructor of the soc_1resistor
class. Both Figures 6.1–6.2 show the parameter ci,1 within Si,1 constructed so that the resulting
FPS is between 5.8 and thirty-two.

104

Chapter 6. Results

Power (W)

9
7
5
3
60
60

40

nt
ne

30
512

1024

2048

50

Size

Exponent

20256

100

4096

(a) Average power

40

50

SoC (%)

po
Ex

50

30

Energy (kJ)

0.6
20
256

0.4
0.2

0
512

1024 2048 4096

Size

0

(c) Remaining battery capacity

60
40
30

t

en

n
po

Ex

50

20256

512

1024

2048

4096

Size

(b) Overall energy
Figure 6.3. Predictive layers with the power in Figure 6.3a, energy in Figure 6.3b, and battery SoC in
Figure 6.3c of the matrix-gpu component in the function of varying matrix size and exponent. The
figure is from our early study (Seewald, Schultz, Ebeid, et al., 2021a).

6.1.2

The matrix-gpu computation

We then derived a set of measurement and predictive layers of another computation, matrix-gpu,
also related to our early study (Seewald, Schultz, Ebeid, et al., 2021a). Here we use again the
NVIDIA Jetson TX2 computing hardware and its overall power measuring device (the computing hardware supports measurements of the power for CPU and GPU separately, as well
as overall; see Section 4.1.2). matrix-gpu computes the matrix exponentiation on the GPU of
various matrix sizes using parameter ci,1 , with different exponents using ci,2 and delaying the
intermediate steps of the exponentiation with different times using ci,3 (we assume that the
parameters are the same for all the l stages). The exponentiation is meant to simulate the heavy
computational load of, e.g., an algorithm related to computer vision. Indeed these algorithms
often rely on various operations with matrix representations of images where, for instance, color
balancing (i.e., incandescent lighting compensation) occurs by multiplication with a scale factor (Szeliski, 2011). We illustrate the predictive layers for the computation varying the parameter
ci,1 from 256 to 4096 and ci,2 from twenty to sixty in Figure 6.3 (these values enclose the sets Si,1

6.1. Computations Energy Modeling

105

and Si,2 respectively). Particularly, Figure 6.3a shows the average power, Figure 6.3b the overall
energy, and Figure 6.3c the battery SoC as a function of matrix size and exponent. We report the
average power consumption independently of the running time of the matrix-gpu, whereas the
overall energy and the battery state of charge measures are measured up until a given configuration of the two parameters ci = {ci,1 , ci,2 } evaluated the exponentiation. The computation
might pose no notable effect on the total power consumption for values of ci close to c i,1 and
c i,2 for parameters ci,1 , ci,2 . An effect indicating the computation terminated before reaching
the maximal power level (Seewald, Schultz, Ebeid, et al., 2021a), also visible in Figure 6.1. It is the
reason why there is a notable difference in average power for two opposite configurations.

Power (W)

7
5
3
1
8

6

4

2

Sleep

0 256

512

10

4096
2048
1024

8

Size

Sleep

(a) Average power

100

6
50
4

SoC (%)

10

2

Energy (kJ)

0.45
0
256

0.3
0.15

1024 2048 4096

Size

0
10

0
512

8

6

4

Sleep

2

0 256

512

4096
2048
1024

(c) Remaining battery capacity

Size

(b) Overall energy
Figure 6.4. Predictive layers with the power in Figure 6.3a, energy in Figure 6.3b, and battery SoC in
Figure 6.3c of the matrix-gpu component in the function of varying matrix size and delays between
consecutive iterations, simulating different schedules. The figure is from our early study (Seewald,
Schultz, Ebeid, et al., 2021a).

In Figure 6.4, we illustrate the predictive layers by varying the parameters ci,1 and ci,3 relative to
the delay–or “sleep”–between iterations of the matrix exponentiation from none to ten seconds.
Figure 6.4a shows the average power, Figure 6.4b the overall energy, and Figure 6.4c the battery
SoC as a function of the matrix size and sleep. We observe that the latter directly affects the overall
power consumption hence, the higher the delay, the lower the remaining battery SoC (conversely,

106

Chapter 6. Results

Computation

matrix-cpu
matrix-gpu
darknet-cpu
darknet-gpu
nvidia-matrix
nvidia-quicks

ODROID
XU3
528.4 J
(-)
-

TK1
406.7 J
8.1 J
(-)
(-)
(-)

NVIDIA
TX2
241.3 J
4.5 J
240 J
525.5 J
405.4 J
199.5 J

Nano
273.6 J
3.9 J
(-)
(-)
(-)
(-)

Runtime

7
7
3
3
7
7

Table 6.1. Overall energy per computation on different computing hardware. 3 indicates that the
runtime is fixed, 7 unbounded. Unsupported hardware is indicated by “-”, whereas possible future
support by “(-)” from our early study (Seewald, Schultz, Ebeid, et al., 2021a).

the higher the overall energy). In both sets of Figures 6.3b–6.3c and Figures 6.4b–6.4c, we thus
observe a relation between overall energy and battery SoC.
We used the same configuration parameters as with the darknet-gpu computation but for
the running time. In Figures 6.3–6.4, the runtime is unbounded: the average power, overall energy, and battery SoC are relative to the entire exponentiation. The battery parameters
are likewise the same. To define the constraint sets Si,1 , we used the configuration pow, e.g.,
range=256,4096,pow(2), meaning ci,1 utilizes exponential sampling in Equation (4.2).
6.1.3

The darknet/matrix -cpu, nvidia- matrix/quicks computations

We deployed the computations energy model on additional computations and computing hardware, including matrix-cpu and darknet-cpu, similar to matrix-gpu and darknet-gpu computations except that the operations run on the CPU rather than GPU. We used all the computing
hardware described in Section 4.1.1 for matrix-cpu, and NVIDIA Jetson TX2 for darknet-cpu.
On NVIDIA Jetson TX2, we further interfaced some already existing benchmarks with the
powprofiler tool. These were modified to run for several instances over a time interval and
implement a quicksort (nvidia-quicks) and a matrix multiplication (nvidia-matrix), both
with a given problem size (parameter ci,4 ). We summarize the overall energy contribution of all
the computations from this section in Table 6.1. The table shows the performance while running on different computing hardware and heterogeneous elements. For instance, matrix-gpu
requires considerably less energy compared to matrix-cpu; indeed, there is a large performance
gap between GPUs and general-purpose multicore CPUs in terms of heavily parallelizable computations (Kirk and Wen-Mei, 2016): matrix-gpu requires only 4.5 joules, whereas matrix-cpu
241.3 joules for the same operation on the NVIDIA Jetson TX2 computing hardware (Seewald,
Schultz, Ebeid, et al., 2021a); the battery SoC evolves accordingly, with the difference between
matrix-gpu and matrix-cpu in terms of battery SoC being 16%. In our early work (Seewald,
Schultz, Ebeid, et al., 2021a; Seewald, Schultz, Roeder, et al., 2019), we further observe the parallelization effect on the overall energy. We can conserve energy by running computations parallel
on the CPU and GPU compared to a sequential schedule (e.g., scheduling computations sequentially on CPU and GPU in some order) even if we subtract the base power. This latter results in

6.1. Computations Energy Modeling

107

a 20% larger overall energy consumption than a parallel schedule (Seewald, Schultz, Ebeid, et al.,
2021a).
In Table 6.1 we additionally compare darknet-gpu to darknet-cpu, which is similar to its
GPU equivalent but runs merely on the CPU. Although darknet-cpu requires less energy per
minute compared to darknet-gpu, it runs for considerably longer; the energy cost per frame
is then higher on the CPU (Seewald, Schultz, Ebeid, et al., 2021a). We further show the energy
effect of the nvidia-matrix and nvidia-quicks computations on the NVIDIA Jetson TX2
computing hardware. The nvidia-matrix computation runs a significant portion on the CPU
to check whenever the result of the GPU matrix multiplication matches the one on the CPU.
Nonetheless, we observe that the problem size affects the overall energy consumption and battery
SoC in both the nvidia-matrix and nvidia-quicks computations (Seewald, Schultz, Ebeid, et
al., 2021a). One notable difference between the two latter computations is the nature of the
problem they solve; nvidia-quicks uses random data that are being sorted and has thus lower
predictability in terms of overall energy (Seewald, Schultz, Ebeid, et al., 2021a).

6.1.4

Validation

To validate the computations energy model from Section 4.1 illustrated in this chapter via the
output of the powprofiler tool, we demonstrated that the model and the tool function on
numerous heterogeneous computing hardware and various computations (Seewald, Schultz,
Ebeid, et al., 2021a). In Table 6.1, we empirically evaluate the matrix-cpu computation on the
ODROID XU3, NVIDIA Jetson TK1, TX2, and Nano computing hardware. The matrix-gpu
on the NVIDIA Jetson computing hardware, and the rest of the computations in this section on
the NVIDIA Jetson TX2 computing hardware. A cross-platform comparison shows the energy
efficiency of different computing hardware: the matrix-cpu computation is most efficient on
NVIDIA Jetson TX2 computing hardware, followed by Nano, TK1, and ODROID XU3. Some
computations not explicitly evaluated here can be potentially extended in future instances of
our approach (hyphen in parenthesis in Table 6.1) conversely to others that are not supported
(hyphen in Table 6.1).
We then evaluate the powprofiler tool through comparison with an external measuring device, i.e., a multimeter connected to the power source of the NVIDIA Jetson TX2 hardware.
We observe a close co-relation between external and internal power measures. The error is less
than 3% over one minute, with the external exceeding the internal measuring device, possibly
due to the energy impact of the carrier board (Seewald, Schultz, Ebeid, et al., 2021a). Indeed
the NVIDIA Jetson TX2 computing hardware we use is mounted on the Jetson Developer Kit
board in Figure 4.2. We further observe that the internal measurements of the overall power
include the energy impact of the tool itself, and conclude that the tool’s effect on the power is
marginal (Seewald, Schultz, Ebeid, et al., 2021a). We later saw the same effect with other libraries,
such as the Robot Operating System (ROS) middleware (Zamanakos et al., 2020).
We further validate our model against a more fine-grained model in the literature (Nikov et al.,
2015; Nunez-Yanez and Lore, 2013), using the ODROID XU3 computing hardware with the

108

Chapter 6. Results

matrix-cpu computation. We described this further validation step in our early work (Seewald,
Schultz, Ebeid, et al., 2021a). The fine-grained model requires some apriori training, which we

performed by evaluating the computation configuration with parameters ci,1 = 512, and ci,2 =
30 (meaning the thirtieth power of square matrix of size 512). The model returns an expected
energy value, which we compared by subsequently running the computation, obtaining an error
of 3.42% (Seewald, Schultz, Ebeid, et al., 2021a). Similarly, we used the powprofiler tool by
varying ci,2 with a step that excludes the configuration ci,2 = 30. We then obtained an expected
energy value for configuration 30, which we again evaluated against running the configuration
subsequently, obtaining an error of 2.25% (Seewald, Schultz, Ebeid, et al., 2021a), justifying ours
against another model in the literature.

6.2

Case Studies in Motion Energy Modeling

In this section, we discuss case studies of motion energy models from Section 4.3 of an aerial
robot flying the agricultural use case doing static coverage path planning (CPP). We use the
computations energy and battery models from Sections 4.1–4.2 to integrate the static CPP with
computing hardware and the effect of the battery. The coverage is decided offline, with no online
replanning when unexpected events occur (e.g., sudden battery drops). We will then replan such
coverage in Section 6.3 along with the scheduling of the computations.
In detail, here we deploy two case studies of aerial robots flying the Zamboni-like motion: in
Section 6.2.1, we derive an energy model using the expression in Equation (4.9), relying on the
periodicity of the energy signal; we use NVIDIA Jetson TX2 as computing hardware integrated
at a later stage (Seewald, García de Marina, Midtiby, et al., 2020). In Section 6.2.2, we derive a differential energy model based on expressions in Equation (4.10) and Lemma 4.3.1; we use NVIDIA
Jetson Nano and ROS middleware also integrated at a later stage. The first case study uses a
static model where we cannot predict, e.g., future energy consumption with varying schedules
or flight time with varying coverage; whereas the second allows such operation. Indeed we will
use a similar approach later in Section 6.3 for energy-aware coverage planning and scheduling.
6.2.1

Periodic modeling case study

The first case study is the aerial robot flying the agricultural use case and doing static CPP while
exploiting the model in Equation (4.9) for the energy signal, which we studied in our previous
work (Seewald, García de Marina, Midtiby, et al., 2020).
Experimental setup

The aerial robot is the Opterra fixed-wing that we first presented in Chapter 1. It uses the Apogee
v1.00 microcontroller with the popular Paparazzi flight controller (Paparazzi, n.d.[b]) and has
a 3.2 amperes per hour battery. The experimental setup then consists of the NVIDIA Jetson
TX2 computing hardware evaluated separately of the aerial robot with two computations. The
darknet-gpu computation that detects objects with the YOLO (Redmon, Divvala, et al., 2016)

6.2. Case Studies in Motion Energy Modeling

109

DNN library (which we encountered in Section 6.1.1), varying a parameter ci,1 relative to the
delay in two consecutive detections and thus the FPS rate. The blowfish computation then
encrypts the data with a symmetric variable key algorithm named “Blowfish” (Schneier, 1993),
varying a parameter ci,2 , the key-size. To model the motion energy, we analyzed the flight logs
from the Paparazzi flight controller of the aerial robot flying the agricultural use case using a
static Zamboni-like motion in Section 5.2.2 implemented in the flight controller. We derive the
constants a, b, ω in Equation (4.9) from similar flights on the same day with standard atmospheric
conditions (i.e., typical wind and temperature). We rely on the energy evolution periodicity; the
data in Section 4.3 (concretely in Figures 4.8–4.9) refer to this case study and show a periodic
energy evolution. We then model the energy with three frequencies, including the base frequency.
We assume static dependency on motion energy, with only computation energy varying with
different computations. Here again, the darknet-gpu varies in the same range as in Section 6.1.1,
whereas blowfish varies between thirty-two and 448 bits, enclosing the computations constraint
Si,2 . For the latter, we used the OpenSSL (Viega et al., 2002) command-line tool for a heavy data
file of approximately 150 megabytes in an iterated encryption manner. The two computations
were in this use case analyzed separately. An approach we discussed in our previous work where
per-component energy is modeled in a dataflow computational network, decreasing the modeling
effort (Seewald, Schultz, Roeder, et al., 2019).
Motion energy evaluation

The motion energy models are in Figure 6.5 and some corresponding paths in Figures 6.5a–
6.5b. In this use case, we saw marked variability in energy signals for take-off, cruise, and landing
phases per flight. To distinguish between the phases, we analyzed the motor torque, altitude, and
throttle (Seewald, García de Marina, Midtiby, et al., 2020). The Opterra fixed-wing aerial robot
gains altitude during take-off before starting to fly the Zamboni-like motion for coverage. The
modeled energy signal is in Figure 6.5c. It is evaluated from some test flights (the gray area in
the figure), whereas Matlab (R) aids the resulting regression (black line in the figure). Such a
regressional analysis depicts little variability at the beginning of the take-off, likely justified by
different controls necessary by various atmospheric conditions, and very little to no variability
in the remaining. This latter part of the trajectory is where the flight controller guides the aerial
robot on the Zamboni-like motion. Figure 6.5d is the modeled energy signal for the cruise phase.
There is little variability between the test flights; the flight controller takes charge of the guidance.
Finally, there is considerable variability in the landing phase energy signal illustrated in Figure 6.5e.
Initially, the aerial robot flies in small circles (see the path in Figure 6.5b), lowering the altitude
while descending to the ground under human control (Seewald, García de Marina, Midtiby, et al.,
2020). The phase depends on different conditions, including landing site geologic conformations,
sudden wind gusts, and others, presenting thus high energy variability. We measured an average
of 28 and 60 seconds for take-off and landing, whereas the cruise depends on the size of the
polygon to cover (containing the agricultural field).

110

Chapter 6. Results

begin take-off

begin landing
end landing

end take-off

30

30

Altitude (m)

20

20

10

200

10
240
180
120
60

180

120

y (m)

50
60

0
0

100

150

200 0

(b) Landing phase path

(a) Take-off phase path
34

50

x (m)

0 0

y(
m)

100
240

x(

0

m)

150

cruise

take-off

landing

32

Power (W)

30
28
26
24
0

7

14

21

28

00:00

Time (s)
(c) Take-off energy

05:00

Time (mm:ss)
(d) Cruise energy

10:00

0

15

30

45

60

Time (s)
(e) Landing energy

Figure 6.5. Paths and modeled energy evolutions in time for different flight phases as they appeared
in our early study (Seewald, García de Marina, Midtiby, et al., 2020).

Computations energy evaluation

The computation energy model in terms of battery SoC for darknet-gpu and blowfish varying parameters ci,1 , ci,2 is in Figure 6.6c. The figure shows the energy impact: the higher the
key size and FPS rate, the larger the impact on the battery. In Figures 6.6a–6.6b, we show the
remaining battery after flying with different schedules. Particularly, Figure 6.6a illustrates various
static schedules: i indicates the impact on the battery of merely flying the regressions from Figures 6.5c–6.5e, i.e., the energy impact of the motion on the battery; ii a static schedule of flying
the configuration 5.8 FPS, and 32 bits (relative to ci,1 , ci,2 , ∀i ∈ [l] with a fixed number of stages
l); iii also a static schedule with 10 FPS and 240 bits; and finally iv with 32 FPS and 448 bits.
Figure 6.6b shows dynamic schedules. I has a configuration of 5.8 FPS and 32 bits at take-off
and landing, of 32 FPS and 448 bits for the duration of two minutes in the middle of the cruise,
and of 5.8 FPS and 32 bits otherwise, resulting in 2.05% remaining battery SoC at the end of the

6.2. Case Studies in Motion Energy Modeling

111

75

344

50
25
0

i
ii
iii
iv

60

SoC (%)

448

Key-size

SoC (%)

100

240

126
I
II

00:00

05:00

10:00

Time (mm:ss)
(a) Static schedule

00:00

05:00

10:00

Time (mm:ss)
(b) SoC-aware schedule

32

5.8

12

19

26

32

20

FPS
(c) SoC in the function of parameters

Figure 6.6. The effect of different schedules on the battery SoC. The figure appeared in our early
study (Seewald, García de Marina, Midtiby, et al., 2020).

flight. II has the same configuration as I only for the two minutes in the middle of the cruise,
and 5.8 FPS and 32 bits otherwise, resulting in 7.86% remaining SoC (Seewald, García de Marina,
Midtiby, et al., 2020). In both cases, we show that the dynamic scheduling allows completing the
flight while draining the battery optimally w.r.t. the current battery SoC.

6.2.2

Differential modeling case study

The second case study is the same aerial robot and agricultural use case from Section 6.2.1, but
now exploiting the model in Equation (4.10) along with different computing hardware and computations.
Experimental setup

The aerial robot is the Opterra fixed-wing for CPP in an agricultural use case equipped with
the Paparazzi flight controller. The computing hardware is now the NVIDIA Jetson Nano,
implementing the computations with the ROS middleware. In this case study, we evaluated
some initial experiments of the differential model in Equation (4.10) in Section 4.3.1, opposed
to the model in Equation (4.9). Here, we did not consider the energy-aware coverage planning
and various power-saving schedules (empirically demonstrated in the next section) but instead
evaluated the initial feasibility of the differential periodic model.
The computing hardware implements three computations. The first two are the
ssd-mobilenet computation SSD-MobileNet V2 convolutional neural network (CNN) (Sandler et al., 2018) and the pednet computation PedNet fully convolutional network (FCN) (Ullah
et al., 2018). The third computation is termed sender. It sends the eventual detections on the
ground using the technical standard for wireless communication IEEE 802.11 (Crow et al., 1997).
Alike the previous section, the computations and motion energy models are combined without
needing to test the two together, simplifying the modeling effort.

112

Chapter 6. Results

Motion energy evaluation

The coverage path is to be seen in Figure 6.7a; the aerial robot flies the same static CPP with
the Zamboni-like motion in Section 5.2.2, implemented in the Paparazzi flight controller from
the previous section. Figure 6.7b is then the path from above. There is a slight deviation mostly
begin go-to-waypoint
end go-to-waypoint

400
320

30
260

150

0
400

100
300

m)

200

x(

10

y (m)

Altitude (m)

20

240
160
80
60

y (m)

200

(a) 3D path

100

40

120

180

240

x (m)
(b) 2D path with altitude zero

Figure 6.7. Paths for the cruise phase in the second case study with the Opterra fixed-wing aerial
robot flying the Zamboni-like motion.

on the x-axis, attributable to the atmospheric conditions (Seewald, García de Marina, Midtiby,
et al., 2020). Initially, we counted the period approximately at one-fourth of the one we defined
in Section 2.4 (begin and end of go-to-waypoint in Figure 6.7), supposing this would be optimal to model the periodicity of the energy signal. We later corrected this assumption to flying
φi , φi+1 , φi+2 , φi+3 ∀i ∈ [dl/4e] with l a given number of stages (we see the results of the latter
case in the next section). The overall energy assessment for what concerns the motion is then
in Figure 6.8a, and for the motion and computations energies in Figure 6.8b. For the latter, our
early model consisted of an expression similar to Equation (4.10), but for the components Aj of
matrix A
"
#
0
1
Aj :=
,
(6.1)
−j 2 ω2 0
where ω is the same as in Equation (4.9). We note that the expression derived from using Aj in
Equation (6.1) is equivalent to Equation (4.13) for periodic modeling purposes (the equivalence
comes from the proof of Lemma 4.3.1, where we evaluate the determinant of Aj in Equation (4.32)
and thus multiply the first row and second column with the second row and first column with
the negative unit, i.e., j 2 ω2 = jωjω). In the model, we then used the coefficients of the Fourier
series as an initial guess for the state q(t0 ) at a given time instant t0 . We derived the coefficient
via the analysis from Section 6.2.1. For modeling purposes, we limited the actual flying time of

6.2. Case Studies in Motion Energy Modeling

30

113

50

y(t)
energy

Y(t)
energy

46

Power (W)

29
42
28

38
34

27
30
26

26
0

60

120

180

240

Time (s)
(a) Modeled motion energy

300

0

60

120

180

240

300

Time (s)
(b) Coupled motion and computations energy

Figure 6.8. Modeled energy evolution with the differential model of the second case study, corresponding to the cruise path in Figure 6.7.

the cruise phase in Figure 6.7 to five minutes. The model output from the initial guess is then
the gray area, whereas the energy data are the black-solid line.
Computations energy evaluation

For the computations ssd-mobilenet and pednet, the parameter ci,1 alters the hazard detection rate from two to ten frames per second (enclosed in the constraint set Si,1 ). These numbers are evaluated empirically to match our detection criteria, as opposed to the computation
darknet-gpu, where we analyzed all the possible detection rates on the NVIDIA Jetson TX2
computing hardware. The computation sender can be then altered with the parameter ci,2 indicating the frequency at which the detections are sent to the ground (from two to ten hertz
enclosing the constraint set Si,2 ). All the computations are wrapped in ROS nodes, meaning
that ci,1 and ci,2 can be changed or analyzed by subscribing to appropriate ROS topics. The
predictive layers in terms of battery SoC are in Figure 6.9b for the ssd-mobilenet computation,
and in Figure 6.9c for the pednet computation (both the layers vary then the frequency ci,2
for the sender computation). We use the colors here to underline the energy impact of some
configurations, otherwise not visible in grayscale.
We used the computations energy model further along with the motion energy model to
evaluate the maximum allowed configuration as a function of time against the overall energy
budget and the battery SoC in Figure 6.9a. The figure shows the trajectory of the configuration of
the detection rate for the PedNet FCN in order to complete the flight. We have further observed
the cost of ROS bag recording; it is approximately 0.2 watts. The overall energy assessment for
the flight is then in Figure 6.8b, coupling the motion and computations energies–the black line
in the figure. The output constraint Y(t) from Definition 5.3.1 is how much energy is available
from the battery in the function of time–the gray area in the figure. The schedule consists of
ci,1 , ci,2 : (a) two FPS and ten hertz for the first two minutes (eventual cached images from the
previous cruise are sent to the ground, as the frequency is greater than the FPS rate), (b) ten FPS

114

Chapter 6. Results

schedule

10

10

8

8

6

6

4

4

Frequency

8

FPS

6
4
2
0

400

800

1200

Time (s)
(a) Schedule over time

2

Power (W)

10

2
2

4

6

8

10

FPS
(b) sender,ssd-mobilenet

2

4

6

8

10

FPS
(c) sender,pednet

Figure 6.9. Computations energy models in term of SoC as well as the schedule over time for the
second case study.

and two hertz from the second minute to third, (c) ten FPS and eight hertz from the third minute
to fourth, (d) and two FPS and ten hertz from the fourth minute to fifth.
6.2.3

Assessment

We discussed two case studies of the aerial robot flying a static coverage without replanning.
We propose computations models corresponding to the agricultural use case for detections and
ground communication, reporting their energy efficiency in terms of power and battery SoC. The
first case study exploits the model in Equation (4.9) to approximate the energy of different flight
phases, motivating the periodic analysis. The second case study then proposes initial experiments
of the differential periodic energy model in Equation (4.10) with some additional computations
implemented in the ROS middleware we use in the remainder. We expand the model using
variations of paths and computations with replanning in the next section.

6.3

Coverage Planning and Scheduling

In this section, we report the results for energy-aware coverage planning and scheduling; and
thus prove our approach experimentally. We extensively use the constructs from the previous
chapters, including the energy models in Chapter 4, the guidance, coverage, and replanning from
Chapter 5, and demonstrate both the solutions to Problems 2.5.1–2.5.2 from Chapter 2. Indeed,
in the previous sections, we justified the various energy models and discussed merely the solution
to Problem 2.5.2 with the Zamboni-like motion.
In Section 6.3.1, we provide results for numerical simulations derived with Matlab (R) . In
Section 6.3.2, we integrate such simulations with the popular Paparazzi flight controller (Paparazzi, n.d.[b]), and finally, in Section 6.3.3, we extend the previous results to the case of avoiding
the computations over the no-interest zones (NIZs) and out of the polygon.

6.3. Coverage Planning and Scheduling

6.3.1

115

Numerical simulations

The first results report is that of a realistic simulation implemented in Matlab (R) relative
to our forthcoming work (Seewald, García de Marina, and Schultz, n.d.), where we implement
the craft’s flight dynamics. It involves the Opterra fixed-wing aerial robot in the precision agriculture use case we introduced in Chapter 1. It does both the CPP and scheduling and online
in-flight replanning energy-wise. The agricultural field is delimited by vertices v and forms Qv
(see Section 5.2.1 for the notation). There are no NIZs, i.e., Qv = Q.
Experimental setup

The aerial robot in this result is the simulated Opterra fixed-wing for CPP in an agricultural use
case, independent of the specific flight controller. In the remainder, we discuss two sub-results,
each with different atmospheric conditions, I and II, in Figure 6.10. Path-wise, we replan the
coverage embedding a parameter ci,1 (same for all the stages) relative to the radius of the fourth
circle φi+3 in a set of four primitive paths φi , . . . , φi+3 ∀i ∈ [bl/4c] iterated over time up to
reaching a final point pΓl that we proposed in Section 2.6.1. The parameter influences the radius
r2 of the circle φi+3 in Equation (2.16); we discussed further the precise meaning of how such
parameter affects the quality of the coverage in Section 5.3. The result I is that of the aerial robot
flying with a constant wind speed of 5 meters per second, the wind direction of 0 degrees, and
an initial path parameter ci,1 value of 0. Result II is flying under the same conditions but a wind
direction of 90 degrees and the initial path parameter value of -1000. We simulate sudden battery
drops in I, expecting the replanning to occur with both scheduling and coverage shortening
(i.e., lesser quality of the coverage) and an ideal battery behavior in II, expecting scheduling and
coverage largening (i.e., higher quality of the coverage).
Identically to the two case studies from the previous section, the simulation is extended with
computing hardware: NVIDIA Jetson Nano, which runs ROS middleware. The computing
hardware implements two computations via ROS nodes: the pednet computation detects hazards using PedNet FCN (Ullah et al., 2018) and can be scheduled with parameter ci,2 the detection rate in FPS. The sender computation communicates to a ground station and can be
scheduled with parameter ci,3 the sending frequency in hertz. Both are similar to the case study
in Section 6.2.2, and here we further demonstrate the in-flight replanning and scheduling. For
the computations, we expect the scheduler to schedule the computations to respect the output
constraint set in Definition 5.3.1 (i.e., the maximum battery instantaneous power).
For battery modeling, the internal battery voltage V is 14.8 volts, internal resistance Rr of 1.2
milliohms, stabilized voltage Vs of twelve volts, and battery capacity Qc of 3.2 amperes per hour
in Equations (4.5–4.8) in Section 4.2.1. Finally, the battery coefficient kb in Equation (5.10) is set
to 1.83/1000 and determined experimentally. The model’s parameter r in Equation (4.10) is equal
to three. We motivate such a choice with the spectral analysis in Figure 4.9, showing that three
frequencies are adequate to model the energy signal.

116

Chapter 6. Results

300
trajec.

I

II

200
100
0
-100

6

ci,2

10

i

200

y (m)

-.5

0

kci,1

2
0

100

-1
0

2

6

4

10

ii

200

6
100

ci,2

-100

0

-.5

kci,1

2
0

-1

-100
-150

-50

50

x (m)

150

0

3

6

9

Time (min)

Figure 6.10. Trajectory simulations with variations of wind speed and direction. In I and II plan is
static. It is replanned online with the algorithm in i and ii. The algorithm adapts the path parameter
relative to r2 ci,1 and computation parameter FPS rate ci,2 . The figure is to appear in our forthcoming
study (Seewald, García de Marina, and Schultz, n.d.).

Planning evaluation

We show the effects of different conditions on the CPP in Figure 6.10. Both trajectories I and II
are flying the same plan for the coverage with the Zamboni-like motion but with different initial
parameters values, the highest configuration c i,1 and the lowest configuration c i,1 , along slightly
different atmospheric conditions. The energy models of these two trajectories are the top two
sub-figures I and II in Figure 6.11. The simulated energy data are in black the model evolution is
in red. The model evolves for two hundred seconds with no information about the true energy:
it is estimated earlier with the Kalman filter on Lines 22–27 in Algorithm 5.3, whereas now it
merely evolves without further estimation on Line 14. The figure proves the model accuracy
experimentally, i.e., the red line copies the periodic evolution of the energy signal.
The components of the energy model from Section 4.3.1 are illustrated in Figure 6.12. Left sub-

6.3. Coverage Planning and Scheduling

117

energy
y(t)

II

I

40

35

36

31

32

27
0

1

3

2

0

1

3

2
Y(t)

39

i

Power (W)

35
31
↓ c 1,1 − δ

27
0

1

↓ c 1,1
3

2

5

4

39

6

ii

35
31
↓ c 1,1

27
0

2

4

6

8

10

Time (min)
Figure 6.11. Energy models of the trajectories from Figure 6.10 for 200 seconds against the simulated
data (I and II). Below are the energy evolutions with replanning (i and ii). Here, the algorithm replans
the plan when the final time and battery time do not match and the computation as the battery is
discharging. The figure is to appear in our forthcoming study (Seewald, García de Marina, and Schultz,
n.d.).

figures are the initial slices of the models and period estimation (see Definition 2.4.3). On the right
of Figure 6.12, we show the states α0 , ..., β3 evolutions in time of I in Figure 6.11, concluding that
approximately two periods are sufficient to obtain consistent state estimates. With non-periodic
signals, we observed that the estimator on Lines 22–27 in Algorithm 5.3 estimates primarily the
first state α0 and it neglects the others. It hence approximates the non-periodicity with a linear
model.
Replanning evaluation

The practical implementation is based on observations of different variations of paths and computations. A variation of path alters the overall flying time, which we reflect in the factors νi,1 , τi,1
from Equation (4.48). We compare the remaining flight time with the time needed to completely
deplete the battery from Equation (5.10) on Lines 11–17 in Algorithm 5.3 and reduce or increase
the parameter to optimize the battery time. The path parameter ci,1 is equal for all the stages.

118

Chapter 6. Results

40

energy
y(t)

40

I
83

36
T = 46

Value

Power (W)

II

36
84
T = 47
30
0

2

α1

10
-10

32

33

α0

30
10
-10

4

Time (sec)

6

β1

10
-10

α2

10
-10
20

β2

-20
20

α3

-20

β3
0

1

2

3

Time (min)

Figure 6.12. Energy estimation for the first 6 seconds on the left side, the evolution of the state q on
the right. The figure is to appear in our forthcoming study (Seewald, García de Marina, and Schultz,
n.d.).

It changes the radius of the last circle in the current period and therefore shifts the other paths
accordingly. The change is in Figure 2.8, resulting in a shorter distance between the coverage lines
in the Zamboni-like motion (and in an increment or reduction of the flying time). The path
constraint set is set to c i,1 = -1000 and c i,1 = zero (enclosing Ci,1 ), equal for all the stages.
A variation of computations directly affects the power. We thus select the highest computation
which satisfies the constraints in Definition 5.3.1 on Line 10 in Algorithm 5.3, using model predictive
control (MPC). We observed a low effect on the power of the communication ROS node (see
Figure 6.9c); we thus used a static frequency of ten hertz for the parameter ci,3 . Nevertheless, the
detection node varies between approximately 5 and 10 watts for the lowest and highest FPS rate.
We implemented the FPS rate parameter ci,2 with factors νi,2 , τi,2 mapping ci,2 to the data from
powprofiler as we described in Equation (4.49) in Section 4.3.3. The computation constraint set
is set to c i,2 = two and c i,2 = ten (enclosing Si,1 ), equal for all the stages.
Coverage planning and scheduling

We have tested the validity of our approach via a numerical simulation implemented in
Matlab (R) , showing the replanning in Figure 6.10 in i and ii path-wise and in Figure 6.11
in i and ii energy-wise. For the first sub-result I, the plan starts at the highest configuration of
parameters. We simulated two unexpected battery drops at approximately one minute and a
half and four minutes and a half. The algorithm optimizes the path (downward facing arrows
in Figure 6.11) in the proximity of the drops to ensure that the flight is completed. Moreover,
it maximizes the parameter ci,2 when the battery is discharging (green line), respecting the output constraint in Definition 5.3.1. We simulated the opposite scenario for sub-result II. The plan
starts at the lowest configuration of parameters while the battery behaves ideally. We note that

6.3. Coverage Planning and Scheduling

119

the path parameter increases when the algorithm estimates enough data (two periods T ). The
algorithm further optimizes the computation parameter w.r.t. to the battery discharge rate. For
both cases, we used discrete reductions δ of five hundred and two for ci,1 and ci,2 respectively,
and the horizon N equal to six seconds (per the values in the literature, see Section 5.3.5). We
observed a slight increment in overall replanning time (order of seconds) by using a horizon of
ten seconds–attributable to the MPC component on Line 10 of Algorithm 5.3–but did not detect
a notable increment in precision.
6.3.2

Paparazzi flight controller

This section extends the previous, describing the experimental setup and the result for the implementation of our approach in the New Paparazzi Simulator (NPS), an advanced simulator
with sensors models along with JSBSim (Berndt, 2004), an open-source flight dynamics model
(FDM) (Paparazzi, n.d.[a]). It is also relative to our forthcoming work (Seewald, García de Marina,
and Schultz, n.d.). It involves the simulated craft in CPP and hazards detection from the previous
section under more diverse battery conditions, with a further complication of asynchronous
communication between the planner-scheduler and the flight controller. Again, there are no
NIZs Qv = Q.
Experimental setup

The polygon v is described by the set of vertices
v1 := (5, 139.5), v2 := (384.4, 162.4), v3 := (384.4, 32.4), v4 := (5, 9.5),

(6.2)

and is regular. On the contrary to the previous result, the outcome depends on the specific
flight controller, meaning we simulate the actual interactions between the Paparazzi flight controller (Paparazzi, n.d.[b]) and the computing hardware on-board the aerial robot in simulated
flights using the NPS with JSBSim. We implement planning-scheduling in Python open source
programming language and the communication between NPS and planner-scheduler with a
software bus termed Ivy (Ivy lightweight software bus n.d.). The resulting NPS graphical user
interface for one of the flights is in Figure 6.14. The path and computations are analogous to
these that we proposed in the previous result in Section 6.3.1. The battery model parameters, the
constraint sets Ci,1 and Si,2 , and the factors ν1 , ν2 , τ1 , τ2 all have the same values in these two
results. We replan the coverage with varying parameter ci,1 that alters the distance between the
survey lines and schedule the computations with the parameter ci,2 relative to the FPS rate of
the pednet computation. As in the previous result, we keep the parameter ci,3 , the communication frequency of the sender computation, static, motivated by the early results showing low
energy effect of different schedules (see Figure 6.9c). The two computations run on the NVIDIA
Jetson Nano computing hardware using ROS middleware. We recall that the schedule for ci,2
is varied via a ROS topic, whereas the computations are ROS nodes, one implementing PedNet
FCN (Ullah et al., 2018), the other simply communicating with the ground.

120

Chapter 6. Results

200

i

ii

iii

iv

v

vi

vii

viii

100

0

-100
200

100

0

y (m)
-100
200

100

0

-100
200

100

0

-100
0

100

200

300

400

0

100

200

300

400

x (m)
Figure 6.13. Trajectories of flights under various conditions and initial configurations implemented in
NPS. The first cluster of flights i–iv starts with the highest configuration of parameters, the second
cluster v–viii with the lowest. Different battery conditions apply to each flight resulting in different
replannings. The figure is to appear in our forthcoming study (Seewald, García de Marina, and
Schultz, n.d.).

6.3. Coverage Planning and Scheduling

121

Figure 6.14. NPS interface with the simulator flying the coverage planning and energy-aware replanning, implementing the JSBSim flight dynamics model.

Planning evaluation

We performed eight test flights in two clusters. The trajectories of these flights are in Figure 6.13.
A first cluster i–iv compromises flights starting with the highest configurations of parameter
ci,1 = c i,1 and ci,2 = c i,2 , requiring then replanning due to various simulated battery profiles.
A second cluster v–viii starts on the contrary with the lowest configuration of ci,1 = c i,1 and
ci,2 = c i,2 . The evolution of the parameters is then in Figure 6.15. For coverage planning, we
further observe some unexpected flight patterns in ii, v–vii, which are, in part, caused by the
delay between the flight controller and planner-scheduler. Indeed these often happen when
the planner-scheduler evaluates the final battery time tb on Lines 11–17 in Algorithm 5.3, being
these lines computationally expensive. Nonetheless, we observe a minor incidence in a multithread implementation, with each computationally expensive block (i.e., MPC on Line 10 and
battery estimator on Lines 11–17) computing in a separate thread, compared to simple sequential
execution.
Although the flights in the previous section are similar, in Figure 6.10, the reference frame OW
is different along with the flight time. The former is due to different initial conditions. Although
we generated the same coverage, p(t0 ) are different: practically, we shift the paths that form the
plan. The latter is due to the different velocities of the craft. Indeed we solely rely on the values
from FDM rather than our implementation of the dynamics.
Replanning evaluation

All the flights start with a charged battery but have different battery evolutions and initial conditions. For the first cluster of flights, flight i starts with the highest configuration of ci,1 and
ci,2 , and the battery behaves linearly up to 90%. At approx. 95 seconds we simulate a sudden

122

Chapter 6. Results

i

ii

iv

iii

10

ci,2

6
2
0

kci,1

-.5
-1
0

1:15 2:30 3:45 0

1:15 2:30 3:45 0

1:15 2:30 3:45 0

1:15 2:30 3:45

Time (m:ss)
v

vi

vii

viii

10

ci,2

6
2
0

kci,1

-.5
-1
0

1:40

3:20

5 0

1:40 3:20

5 0

1:40

3:20

5 0

1:40

3:20

5

Time (m:ss)
Figure 6.15. Evolution of the parameters configurations for two clusters of flights implemented in NPS.
Each cluster has a similar overall flight time due to the initial conditions. The figure is to appear in our
forthcoming study (Seewald, García de Marina, and Schultz, n.d.).

battery drop of 4%. The battery then again behaves linearly, and the final battery state is approx.
57%. The parameter ci,1 is thus replanned by Algorithm 5.3 in the proximity of the drop and
the computation parameter ci,2 is scheduled to respect the output constraint in Definition 5.3.1
visible in Figure 6.16 (the green line indicates the constraint). Flight ii is similar, but the battery drop happens at approx. 122 seconds. The evolution of the parameter ci,1 is indeed mostly
the same, whereas the parameter ci,2 is replanned with a higher schedule. Flight iii has eventual additional uncertainty due to the communication lag between the flight controller and the
planner-scheduler. We can see that indeed ii–iii are very similar, conversely to flight iv, where the
battery drop happens at approx. 163 seconds.
The second cluster of flights exhibits the same tendency for flights v–vi and, indeed, the energy
in Figure 6.16, the configurations in Figure 6.15, and the trajectories in Figure 6.13 are almost
identical. There are no simulated sudden battery drops and enough battery SoC to respect the
output constraint in Definition 5.3.1. Flights vii–viii are similar to the previous couple, except for a
more steep simulated battery evolution, lower of approx. 4%. There is then a simulated 2% points
battery difference at the end of the flight between vii and viii, requiring additional replanning.

6.3. Coverage Planning and Scheduling

123

40

i

ii

iii

iv

38
36
34
32
40
38
36
34

Power (W)

32
0

0:45

1:30

2:15

3

40

3:45 0

0:45

1:30

2:15

3

3:45

v

vi

vii

viii

38
36
34
32
40
38
36
34
32
0

1

2

3

4

5 0

1

2

3

4

5

Time (m:ss)
Figure 6.16. Energy models for the flights implemented in NPS with different initial and simulated
battery conditions. The green line indicates the output constraint. The figure is to appear in our
forthcoming study (Seewald, García de Marina, and Schultz, n.d.).

124

Chapter 6. Results

Coverage planning and scheduling

We have further validated our approach utilizing NPS with JSBSim as FDM. We simulated
various battery evolutions and drops, corresponding to, e.g., imperfect batteries of fixed-wing
aerial robots operating in real-world conditions. We have simulated the interaction between the
flight controller and the planner-scheduler, interconnecting the two via Ivy bus, showing possible
complications such as delays. We will discuss future possibilities of additional optimizations to
reduce such delays in Chapter 7. In this result, we use a lower reduction δ for the path parameter
of two hundred fifty, with no notable difference in path replanning. We thus conclude that δ
of five hundred from Section 6.3.1 is adequate for path replanning. Conversely to the previous
result, we use a fixed horizon N of ten seconds (see Section 5.3.5).
6.3.3

Coverage with no-interest zones

In this final result, we complement our approach, interrupting the computations over a NIZ
on the ground as we hypothesized in Problem 2.5.2 and Section 5.2, and additionally out of the
polygon v, thus computing only within the space Qv . The result is relative to our forthcoming
work (Seewald, García de Marina, and Schultz, n.d.). The NIZ resulting polygon o1 mimics conveniently the shape and location in Figures 5.6–5.13 in Sections Sections 5.2–5.3, whereas v is
the same as in Section 6.3.2. The polygon o1 , representing the NIZ, has six vertices
o1,1 := (110, 85),

o1,2 := (125, 106.5), o1,3 := (155, 114.5),

o1,4 := (195, 93.5), o1,5 := (175, 76.5), o1,6 := (137, 57.7),

(6.3)

and the resulting trajectory of the aerial robot flying the coverage while avoiding the computations over NIZ and out of the polygon is in Figure 6.17. To simulate the energy effect of the configuration ci,2 = {0}, we evaluated the average power of the NVIDIA Jetson Nano computing
hardware with the powprofiler tool, solely running ROS core with the remaining computations
(pednet, sender) switched off. The rest of the experimental setup is shared with Section 6.3.2,
and the resulting initial and battery conditions are these of flight ii in the first cluster in Figure 6.13,
i.e., the highest configuration of ci,1 and ci,2 with the simulated battery behaving ideally but for
a drop at approx. 122 seconds.
The trajectory is indeed similar to ii. Flight ii.a in Figure 6.17 is that of the coverage while
avoiding computations over Qo1 , whereas flight ii.b avoids the computations everywhere but
over Qv (i.e., additionally to ii.a, it avoids the computations outside of the polygon v). There is an
observable difference in the configuration trajectories for the parameter ci,2 , visible in Figure 6.19.
Indeed ii.a in Figure 6.19 is similar to ii in Figure 6.15, but for the instants when the aerial robot
flies over the NIZ o1 and the computation parameter is inhibited ci,2 = {0}. The corresponding
energy consumption is then in ii.a in Figure 6.18.
Finally, there is a notable difference between the two sub-results ii.a and ii.b in Figures 6.19–
6.18, contrary to Figure 6.17, showing the energy (and configuration trajectory) effect of avoiding
computations everywhere except over Qv . One can further note the impact of the NIZ polygon
o1 shape on the energy and configuration trajectories. Depending on the position in space, it

6.3. Coverage Planning and Scheduling

125

ii.a

200

ii.b

y (m)

100

0

-100
0

100

200

300

0

400

100

200

300

400

x (m)
Figure 6.17. Trajectories of two flights flying the same condition as ii in Figure 6.13 but inhibiting
computations over NIZ in ii.a, and over NIZ and out of the polygon v in ii.b. The figure is to appear in
our forthcoming study (Seewald, García de Marina, and Schultz, n.d.).

41

ii.a

ii.b

Power (W)

38
35
32
29
0

0:45

1:30

2:15

3:00

3:45

0

0:45

1:30

2:15

3:00

3:45

Time (m:ss)
Figure 6.18. Energy evolution of a schedule that additionally inhibits the computations over NIZ in ii.a,
and over NIZ and out of the polygon v in ii.b. The figure is to appear in our forthcoming study (Seewald,
García de Marina, and Schultz, n.d.).

10

ii.a

ii.b

ci,2

5
0
0

kci,1

-.5
-1
0

1:15

2:30

3:45 0

1:15

2:30

3:45

Time (m:ss)
Figure 6.19. Configurations trajectories of a schedule that additionally inhibits the computations over
NIZ in ii.a, and over NIZ and out of the polygon v in ii.b. The figure is to appear in our forthcoming
study (Seewald, García de Marina, and Schultz, n.d.).

126

Chapter 6. Results

takes longer or shorter to fly over the NIZ due to the different lengths of a line segment parallel
to the edge v4 |v1 intersecting the NIZ o1 (see Figure 5.8).

6.4

Summary

This chapter described the experimental setup and results for computations and motion energy
and battery models, two case studies of the aerial robot flying a static coverage, and in-flight coverage planning and scheduling. The computations energy models were derived via the powprofiler
modeling tool, reporting the overall energy, average power, and battery SoC per each computations configuration within a bounded search space. The chapter detailed computations energy
models for several computations ranging from simple matrix exponentiation to object detection.
It then provided two case studies of aerial robots flying physical experiments with a static coverage, showing the periodic energy evolution and motivating the differential periodic energy model
from the previous chapters. The guidance, coverage planning, and online replanning were then
proposed via numerical simulations with various realistic conditions, showing the energy effect
of online replanning from the lowest and the highest initial configurations of the coverage and
detections. These results are then further extended to the popular Paparazzi flight controller and
various battery conditions and to the case of coverage with NIZs. Here, the aerial robot inhibits
the computation when flying over a NIZ of a given size and out of the polygon.

Chapter 7

Summary and Future Directions
“The energy budget for sensing and computing is commensurate with that of actuation–
such as is typically the case for planetary rover missions.”
— Ondrúška et al., 2015

l a n n i n g-scheduling energy awareness demonstrates improved robustness to in-

P flight failures in the autonomous use case, mitigating the adverse effect of environmental

interferences on battery life and overall flight span. In the previous chapters, we progressively
built and showcased our approach using the use case both in simulation and some early flight
of the Opterra fixed-wing autonomous aerial robot. The approach varies both the path and the
schedule while exploiting differential periodic, computations, and battery models. In this chapter,
we summarize our work, discuss the outcomes, and propose future directions and conclusions
in Sections 7.1–7.4.

7.1

Summary

The approach in this work provides an energy-aware path and a power-saving schedule altogether.
Past studies often derive one of these aspects, whereas the analysis of the interactions of the two
is less common (Brateman et al., 2006; Sudhakar et al., 2020). To this end, our work focuses
on coverage path planning (CPP)–a common problem in the planning literature where it is
required to visit each point in a given space (H. Choset, 2001; Galceran and Carreras, 2013)–in
a precision agriculture use case. Here, a fixed-wing aerial robot covers a given agricultural field,
detects ground hazards, and communicates with other ground-based actors. Although use-case
specific, the approach is generic in terms of computations and battery modeling as well as CPP.
The guidance and differential periodic energy modeling can be applied to a broader class of
energy-constrained autonomous mobile robotics use cases.
127

128

Chapter 7. Summary and Future Directions

To derive energy-aware coverage planning and scheduling for autonomous aerial robots, we
defined some basic constructs in Chapter 2. These included the concepts of computations and
motion along with their energies in Section 2.1. Indeed their close interaction is the basis of
this work. Computations are energy-expensive computational tasks that we aim to schedule
energy-wise along with the motion on a coverage path. The coverage path is a succession of
continuous and twice differentiable path functions in Section 2.2. These functions are wrapped
with computations in stages in Section 2.3, along with parameters for scheduling and coverage
replanning. The succession of stages forms a plan in Section 2.4, and the progression from one
stage to another happens in the proximity of triggering points. The plan can be expressed as a
mere succession of stages or using primitive paths with a shift. In Section 2.5, we formally defined
the problems of coverage planning and energy-aware coverage replanning and scheduling.
We discussed the state of the art spanning broadly in Chapter 3. In Sections 3.1–3.2, we reviewed
the literature for computations energy and battery modeling. We focused on energy models for
heterogeneous elements, involving CPUs and GPUs, and on abstract battery models. We then
examined motion planning for mobile and aerial robots in Sections 3.3–3.4, including planningscheduling interactions in the robotics literature in Section 3.5.
In Chapter 4, we provided energy models for future energy estimations of computations, motion, and battery before digging into the technicalities of coverage planning and energy-aware
replanning. The computations energy model in Section 4.1 models heterogeneous elements (i.e.,
CPUs and GPU) of the computing hardware and provides overall energy, average power, and
battery state of charge (SoC) in the function of a software configuration. It utilizes a two-layer
architecture, where the top layer incorporates multiple bottom layers. This approach is implemented in an automatic modeling and profiling tool named powprofiler (Seewald, Schultz,
Ebeid, et al., 2021a,b). We then derived a battery model in Section 4.2 from an abstract model in
the literature termed “Rint”. We proposed a differential periodic energy model for the motion
in Section 4.3, exploiting energy characteristics of the coverage from some empirical observations. The motion energy model includes the computations energy via the control, modeling
the energy effect of different schedules.
We discussed the coverage planning and scheduling, energy-aware replanning, and the guidance on a coverage path in Chapter 5, providing the solution to the original problems in Chapter 2.
First, in Section 5.1, we discussed how to guide the aerial robot given a set of paths in the plan
using the theory of vector fields. We derived a coverage plan that visits all the points in a given
space in Section 5.2, using cellular decomposition and a modified coverage motion for fixed-wing
aerial robots with variable coverage that we termed Zamboni-like motion. We included all the
past constructs in Section 5.3 for energy-aware coverage replanning and scheduling. Here, we
replanned the original path using the computations and motion energy along with the battery
models. We used a modern optimal control and state estimation technique robust to uncertainty.
Finally, in Chapter 6, we discussed the experimental setup and results. In Section 6.1, we provided the computations energy models derived with the powprofiler tool. We saw case studies
of motion and periodic energy models in Section 6.2, and finally, discussed the results for energyaware coverage planning and scheduling in Section 6.3.

7.2. Outcomes

7.2

129

Outcomes

This works contributes to the existing robotics literature on planning-scheduling energy awareness (Brateman et al., 2006; Lahijanian et al., 2018; Mei, Y.-H. Lu, Y. C. Hu, et al., 2005; Mei, Y.-H. Lu,
Y. C. Hu, et al., 2006; Ondrúška et al., 2015; Sadrpour et al., 2013a,c; Sudhakar et al., 2020; W. Zhang
and J. Hu, 2007) by proposing an approach for energy-aware coverage planning for autonomous

aerial robots.
Specific contributions in order as they appear in the previous chapters include: (a) the introduction of the concept of replanning a variable CPP along with scheduling (Seewald, García de
Marina, and Schultz, n.d.), (b) the formal definition of no-interest zones (NIZs) -aware schedules
for further energy savings by selectively running computations only when necessary (Seewald,
García de Marina, and Schultz, n.d.), (c) the design and implementation of an automatic modeling and profiling tool named powprofiler (Seewald, Schultz, Ebeid, et al., 2021a) for various
computing hardwares (Seewald, Schultz, Ebeid, et al., 2021b) that derives power, energy, and battery SoC as a function of software configurations, (d) the extension of the powprofiler tool
to dataflow computational networks (Seewald, Schultz, Roeder, et al., 2019) and to the Robot
Operating System (ROS) middleware (Zamanakos et al., 2020), (e) the adaptation of the “Rint”
equivalent electrical circuit in the literature into the powprofiler tool (Seewald, Schultz, Ebeid,
et al., 2021a) and in the coverage replanning problem (Seewald, García de Marina, and Schultz,
n.d.), (f) the derivation of a differential periodic energy model (Seewald, García de Marina, and
Schultz, n.d.) based on empirical observations (Seewald, García de Marina, Midtiby, et al., 2020)
for future energy predictions and energy predictions under variable schedules for autonomous
coverage, potentially applying to a broader class of mobile robotics use cases (Seewald, 2020),
(g) the adaptation (Seewald, García de Marina, and Schultz, n.d.) of an existing approach for guidance (García de Marina et al., 2017) based on vector fields to coverage plans composed of multiple
paths, (h) the introduction of the Zamboni-like motion for variable coverage (Seewald, García
de Marina, and Schultz, n.d.) for aerial robots with strict turning radius constraints, and (i) the
derivation of an algorithm for replanning of the coverage and scheduling inﬂight and under strict
energy constraints (Seewald, García de Marina, and Schultz, n.d.).

7.3

Future Directions

Multiple observations and open questions regarding possible future studies were made in the
previous chapters. These include further developments spanning from coverage planning to
broad planning-scheduling considerations.
We hypothesized a possible generalization to other mobile robots. Indeed CPP in the literature
applies to diverse use cases. These include decontamination, mine clearance, oceanographic mapping, cleanup, and others (H. Choset and Pignon, 1998) and involve various mobile robots (Galceran and Carreras, 2013). Although the Zamboni-like motion in Section 5.2.2 is best suited for
aerial robots with strict turning radius constraints, the concept of variable coverage can be ap-

130

Chapter 7. Summary and Future Directions

plied broadly. For instance, the boustrophedon-like motion for variable coverage in Section 2.6.1,
to rotary-wings aerial robots and other mobile robots.
In our past brief work (Seewald, 2020), we discussed the approach’s applicability to the planetary exploration context. An unexplored terrain can be covered with variable coverage by trading
a greedy technique with more complex planning. Schedules can vary by, e.g., pattern detections
of features of interest or perception (Ondrúška et al., 2015). Recent contributions are increasingly
proposing onboard autonomy with artificial neural networks (Gankidi and Thangavelautham,
2017) and other machine learning techniques (Ono et al., 2020) for future space exploration missions such as Sample Retrieval and Lander mission (Muirhead and Karp, 2019). In the latter, the
robot is to be solar-powered (Higa et al., 2019). Planning-scheduling energy awareness might pose
an advantage for these systems, despite past instances carrying limited onboard resources due to
radiation levels and temperature changes (Bajracharya et al., 2008; Gankidi and Thangavelautham,
2017). Furthermore, the average motion energy reported in a recent study (Ishigami et al., 2011)
decreased considerably compared to the past literature (Krotkov and Simmons, 1992).
The differential periodic energy model in Section 4.3 is generic, modeling systems energy with
some degree of periodicity. However, other energy models for aperiodic use cases are equally
possible. The only requirement is embedding the controls to the configuration of parameters
for future energy prediction in Section 5.3. A possible model is a differential linear aperiodic
model built via regressional analysis, mapping a change in the schedule to, e.g., the slope of the
regression. Other examples are models that incorporate robots dynamics, that map the energy
to turns, etc.
Section 2.5 mentions the optimal configuration in Equation (5.17) with costs other than the
energy. For instance, it might be required to cover a given space with the fastest tour possible. Or,
similarly, selectively prioritize some computations over the others. These considerations were not
covered by Algorithm 5.3, which merely selects the best possible schedule w.r.t. to the given cost
in Equation (5.15). In a prioritized setting, it might be then possible to utilize a stage-dependent
priority list: let’s call it ri ∈ (0, 1] ⊂ Rn where n is given in Section 4.3.2. The list can be used
in the cost with the parameters, prioritizing specific computations for particular stages. In this
setting, it might be possible to trade-off other non-functional properties, such as security involved
in the TeamPlay project (TeamPlay Consortium, 2019b) that funded a considerable part of this
work, by, e.g., increasing the latter at given “security demanding” stages.
The construct of path functions in Section 2.2 involves aerial coverage flying at a given altitude
h. A more complex coverage planning with, for example, the aerial robot covering a building
requires further investigation. In this latter case, Definition 2.2.1 might be extended to functions
R3 → R, expressing simply a 3D shape of, e.g., the building to cover with a cylinder. The guidance
in Section 5.1 would then adopt different strategies. For example, the introduction of multiple
path functions in 2D discretely “slicing” the cylinder, or the development of the theory of vector
fields further with, e.g., the magnitude of the gradient in Equation (5.1). The varying quality of
the coverage can be achieved by changing the distance between the “slicing” functions.
Future directions involve the extension of the coverage motion, the study of additional motions and their trade-offs, and the shortcomings of Algorithm 5.3. The derivation of the optimal

7.4. Conclusion

131

parameters configuration happens for the current stage i and assumes future stages evolve according to the energy model and the observation in Section 4.3.2. The energy of complex plans
might, however, change completely at each stage and require a stage-dependent energy model.
Algorithm 5.3 would necessitate a trajectory to map the time to the stage for energy predictions
in this latter stage-dependent energy model.
In Section 5.3.5, we scheduled in a NIZ-aware fashion overflying, e.g., supporting infrastructure, without computing. The derivation of a coverage plan accounting for both NIZs and
no-flight zones (NFZs) requires further analysis. Other than for the physical obstacles in form of,
e.g., tall buildings, it might be indeed more convenient to avoid flying over a NIZ energy-wise.
For instance, if the NIZ is attached to one of the vertices v. For some cases, it might be then
advantageous to consider complex battery models, including details such as different battery
chemistries, state of health, temperature, or C-rate. Additional rigor might lead to better modeling with other equivalent electrical circuits models such as the Thevenin-based model (M. Chen
and Rincon-Mora, 2006; Hasan et al., 2018; Hinz, 2019; Mousavi G. and Nikdel, 2014; Salameh et al.,
1992; C. Zhang, Allafi, et al., 2018) outlined in Section 4.2.1.

Further possible development is that of the derivation of an approach for planning-scheduling
energy awareness with multiple robots. Here a swarm of aerial robots might be covering the
agricultural field with a centralized or distributed system handling overall multi-agent planningscheduling. The system might then integrate Algorithm 5.3 for coverage replanning by deciding a
piece-wise coverage. It might even distribute the computations to optimize the battery utilization
of each agent while preserving given use case constraints. Integration of various approaches
might lead to additional new developments; for instance, considering the frequency and voltage
from other planning-scheduling literature (Brateman et al., 2006; W. Zhang and J. Hu, 2007) in
Algorithm 5.3.
These additional studies will possibly further provide insights into planning-scheduling energy
awareness and expedite the research foundations of varying both aspects together, bridging low
power computing and mobile robotics domains.

7.4

Conclusion

In conclusion, even though planning-scheduling energy awareness is a relatively recent research
direction, there are some contributions in the wider mobile robotics research literature. Initial
studies date back to 2000–2010 and focus on varying computational aspects such as frequency
and voltage, along with motional aspects such as velocity or selection of peripherals. Studies in
the following decade 2010–2020, especially in the second half, dig further into computational
aspects proposing various techniques for simultaneous planning-scheduling, emphasizing the
possible savings. Past approaches, however, do not account for aerial robots. With this work, on
the contrary, we emphasize planning-scheduling energy awareness for this latter class of mobile
robotics platforms. We further exploit the battery as an energy source and the possibility of
in-flight online replanning.

132

Chapter 7. Summary and Future Directions

We derive an optimal configuration of both the path and computations, running on heterogeneous computing hardware mounted onto the aerial robot. We use a sub-class of motion
planning where the aerial robot covers each point in a given space, varying the quality of the coverage and ground hazards detections in case of, e.g., sudden battery drops, adverse atmospheric
conditions, etc. We observe the effect of replanning, with the aerial robot completing the coverage under adversities or exploiting the energy budget with ideal conditions in the function of
the available battery SoC. We can back the statement in the introduction: aerial robots are an
ideal instance of an energy-constrained system benefitting from planning-scheduling trade-offs,
answering the research question (d) in Section 1.3.3.
The derivation of such a conclusion required multiple steps. Firstly, it was necessary to predict the energy of future instances of computations, which we addressed with the powprofiler
modeling and profiling tool, answering the research question (a). Knowing only the energy evolutions of computations is not enough. We thus derived a differential periodic energy model that
exploits coverage characteristics and empirical observations, answering the research question (b),
and that predicts energy of variations of schedules and paths, answering (c).

References
9. Ablavsky, V. and Snorrason, M. (2000). “Optimal search for a moving target - A geometric
approach”. In: Guidance, Navigation, and Control (GNC) Conference. AIAA (cit. on p. 89).
10. Abramov, A., Pauwels, K., Papon, J., Worgotter, F., and Dellen, B. (2012). “Real-time segmentation of stereo videos on a portable system with a mobile GPU”. In: IEEE Transactions on
Circuits and Systems for Video Technology 22.9, pp. 1292–1305 (cit. on p. 2).
11. Acar, E. U., Choset, H., Rizzi, A. A., Atkar, P. N., and Hull, D. (2002). “Morse decompositions for
coverage tasks”. In: The International Journal of Robotics Research 21.4, pp. 331–344 (cit. on
p. 42).
12. Acevedo, J. J., Arrue, B. C., Diaz-Banez, J. M., Ventura, I., Maza, I., and Ollero, A. (2014).
“One-to-one coordination algorithm for decentralized area partition in surveillance missions
with a team of aerial robots”. In: Journal of Intelligent & Robotic Systems 74.1, pp. 269–285
(cit. on p. 4).
13. Ahmadzadeh, A., Keller, J., Pappas, G., Jadbabaie, A., and Kumar, V. (2008). “An optimizationbased approach to time-critical cooperative surveillance and coverage with UAVs”. In: 10th
International Symposium on Experimental Robotics. Springer, pp. 491–500 (cit. on p. 44).
14. Aldegheri, S., Bombieri, N., Bloisi, D. D., and Farinelli, A. (2019). “Data flow ORB-SLAM for
real-time performance on embedded GPU boards”. In: International Conference on Intelligent
Robots and Systems (IROS). IEEE, pp. 5370–5375 (cit. on p. 56).
15. Alexey, G., Klyachin, V., Eldar, K., and Driaba, A. (2021). “Autonomous mobile robot with AI
based on Jetson Nano”. In: Future Technologies Conference (FTC). Springer, pp. 190–204
(cit. on p. 56).
16. Aljanobi, A., Al-Hamed, S., and Al-Suhaibani, S. (2010). “A setup of mobile robotic unit for
fruit harvesting”. In: 19th International Workshop on Robotics in Alpe-Adria-Danube Region
(RAAD). IEEE, pp. 105–108 (cit. on p. 3).
17. De-An, Z., Jidong, L., Wei, J., Ying, Z., and Yu, C. (2011). “Design and control of an apple
harvesting robot”. In: Biosystems Engineering 110.2, pp. 112–122 (cit. on p. 3).
18. Anderson, J. D. (2005). Introduction to flight. McGraw-Hill Higher Education (cit. on p. 3).

133

134

References

19. Andersson, J. A., Gillis, J., Horn, G., Rawlings, J. B., and Diehl, M. (2019). “CasADi: A software framework for nonlinear optimization and optimal control”. In: Mathematical Programming
Computation 11.1, pp. 1–36 (cit. on p. 99).
20. Andersson, J., Åkesson, J., and Diehl, M. (2012a). “CasADi: A symbolic package for automatic
differentiation and optimal control”. In: Recent Advances in Algorithmic Differentiation. Springer,
pp. 297–307 (cit. on p. 99).
(2012b). “Dynamic optimization with CasADi”. In: 51st Conference on Decision and
21. —
Control (CDC). IEEE, pp. 681–686 (cit. on p. 99).
22. Andrew, W., Greatwood, C., and Burghardt, T. (2019). “Aerial animal biometrics: Individual
friesian cattle recovery and visual identification via an autonomous UAV with onboard deep
inference”. In: International Conference on Intelligent Robots and Systems (IROS), pp. 237–
243 (cit. on pp. 8, 56).
23. Anguelov, D., Koller, D., Parker, E., and Thrun, S. (2004). “Detecting and modeling doors with
mobile robots”. In: International Conference on Robotics and Automation (ICRA). Vol. 4. IEEE,
pp. 3777–3784 (cit. on p. 47).
24. Araújo, J., Sujit, P., and Sousa, J. (2013). “Multiple UAV area decomposition and coverage”.
In: Symposium on Computational Intelligence for Security and Defense Applications (CISDA).
IEEE, pp. 30–37 (cit. on pp. 24, 44, 45, 89).
25. Arkin, E., Fekete, S., and Mitchell, J. (1993). “The lawnmower problem”. In: 5th Canadian
Conference on Computational Geometry, pp. 461–466 (cit. on p. 41).
26. Arkin, E. M., Bender, M. A., Demaine, E. D., Fekete, S. P., Mitchell, J. S. B., and Sethia, S.
(2001). “Optimal covering tours with turn costs”. In: 12th Annual Symposium on Discrete
Algorithms. SIAM, pp. 138–147 (cit. on pp. 2, 15, 43, 46).
27. —
(2005). “Optimal covering tours with turn costs”. In: SIAM Journal on Computing 35.3,
pp. 531–566 (cit. on pp. 2, 43, 46).
28. Arkin, E. M., Fekete, S. P., and Mitchell, J. S. (2000). “Approximation algorithms for lawn mowing
and milling”. In: Computational Geometry 17.1, pp. 25–50 (cit. on pp. 41, 84).
29. Arkin, E. M. and Hassin, R. (1994). “Approximation algorithms for the geometric covering
salesman problem”. In: Discrete Applied Mathematics 55.3, pp. 197–218 (cit. on p. 41).
30. Artemenko, O., Dominic, O. J., Andryeyev, O., and Mitschele-Thiel, A. (2016). “Energy-aware
trajectory planning for the localization of mobile devices using an unmanned aerial vehicle”.
In: 25th International Conference on Computer Communication and Networks (ICCCN). IEEE,
pp. 1–9 (cit. on pp. 24, 46, 88).
31. Atkinson, K., Han, W., and Stewart, D. (2009). “Euler’s method”. In: Numerical solution of
ordinary differential equations. John Wiley & Sons. Chap. Chapter 2, pp. 15–36 (cit. on p. 97).
32. Bailey, P. E., Lowenthal, D. K., Ravi, V., Rountree, B., Schulz, M., and De Supinski, B. R.
(2014). “Adaptive configuration selection for power-constrained heterogeneous systems”. In:
43rd International Conference on Parallel Processing. IEEE, pp. 371–380 (cit. on pp. 33, 59).
33. Bajracharya, M., Maimone, M. W., and Helmick, D. (2008). “Autonomy for Mars rovers: Past,
present, and future”. In: Computer 41.12, pp. 44–50 (cit. on p. 130).

References

135

34. Barrientos, A., Colorado, J., Cerro, J. d., Martinez, A., Rossi, C., Sanz, D., and Valente, J. (2011).
“Aerial remote sensing in agriculture: A practical approach to area coverage and path planning
for fleets of mini aerial robots”. In: Journal of Field Robotics 28.5, pp. 667–689 (cit. on p. 44).
35. Basilico, N. and Carpin, S. (2015). “Deploying teams of heterogeneous UAVs in cooperative
two-level surveillance missions”. In: International Conference on Intelligent Robots and Systems (IROS). IEEE, pp. 610–615 (cit. on p. 4).
36. Beck, A. (2014). Introduction to nonlinear optimization: Theory, algorithms, and applications
with Matlab. SIAM (cit. on p. 95).
37. Benini, L., Castelli, G., Macii, A., Macii, E., Poncino, M., and Scarsi, R. (2001). “Discrete-time
battery models for system-level low-power design”. In: IEEE Transactions on Very Large Scale
Integration (VLSI) Systems 9.5, pp. 630–640 (cit. on pp. 38, 39).
38. Berndt, J. (2004). “JSBSim: An open source flight dynamics model in C++”. In: Modeling and
Simulation Technologies Conference and Exhibit. AIAA, p. 4923 (cit. on p. 119).
39. Bhat, G., Gumussoy, S., and Ogras, U. Y. (2019). “Power and thermal analysis of commercial
mobile platforms: Experiments and case studies”. In: Design, Automation & Test in Europe
Conference & Exhibition (DATE). IEEE, pp. 144–149 (cit. on p. 56).
40. Bicego, D., Mazzetto, J., Carli, R., Farina, M., and Franchi, A. (2020). “Nonlinear model predictive control with enhanced actuator model for multi-rotor aerial vehicles with generic designs”.
In: Journal of Intelligent & Robotic Systems 100.3, pp. 1213–1247 (cit. on p. 91).
41. Bouzid, Y., Bestaoui, Y., and Siguerdidjane, H. (2017). “Quadrotor-UAV optimal coverage path
planning in cluttered environment with a limited onboard energy”. In: International Conference
on Intelligent Robots and Systems (IROS). IEEE, pp. 979–984 (cit. on p. 46).
42. Boyd, S., Boyd, S. P., and Vandenberghe, L. (2004). Convex optimization. Cambridge University
Press (cit. on p. 80).
43. Brateman, J., Xian, C., and Lu, Y.-h. (2006). “Energy-effcient scheduling for autonomous mobile
robots”. In: IFIP International Conference on Very Large Scale Integration. IEEE, pp. 361–366
(cit. on pp. 1, 8, 12, 23, 31, 47, 49, 91, 127, 129, 131).
44. Bridges, R. A., Imam, N., and Mintz, T. M. (2016). “Understanding GPU power: A survey of
profiling, modeling, and simulation methods”. In: ACM Comput. Surv. 49.3, pp. 1–27 (cit. on
p. 35).
45. Bryson, A. E. and Ho, Y.-C. (1975). Applied optimal control: Optimization, estimation and
control. Hemisphere Publishing Corporation (cit. on p. 79).
46. Bürkle, A. (2009). “Collaborating miniature drones for surveillance and reconnaissance”. In:
Unmanned/Unattended Sensors and Sensor Networks VI. Vol. 7480. International Society for
Optics and Photonics, 74800H (cit. on p. 4).
47. Burri, M., Gasser, L., Käch, M., Krebs, M., Laube, S., Ledergerber, A., Meier, D., Michaud, R.,
Mosimann, L., Müri, L., et al. (2013). “Design and control of a spherical omnidirectional blimp”.
In: International Conference on Intelligent Robots and Systems (IROS), pp. 1873–1879 (cit. on
p. 6).

136

References

48. Cabreira, T. M., Brisolara, L. B., and Ferreira Jr., P. R. (2019). “Survey on coverage path
planning with unmanned aerial vehicles”. In: Drones 3.1 (cit. on pp. 8, 20, 23, 39, 44).
49. Cabreira, T. M., Franco, C. D., Ferreira, P. R., and Buttazzo, G. C. (2018). “Energy-aware
spiral coverage path planning for UAV photogrammetric applications”. In: IEEE Robotics and
Automation Letters 3.4, pp. 3662–3668 (cit. on pp. 24, 40, 46).
50. Calore, E., Schifano, S. F., and Tripiccione, R. (2015). “Energy-performance tradeoffs for
HPC applications on low power processors”. In: European Conference on Parallel Processing.
Springer, pp. 737–748 (cit. on pp. 35, 60).
51. Camacho, E. F. and Alba, C. B. (2007). Model predictive control. Springer (cit. on p. 91).
52. Canny, J. (1988a). “Constructing roadmaps of semi-algebraic sets I: Completeness”. In: Artificial Intelligence 37.1, pp. 203–222 (cit. on p. 86).
53. —

(1988b). The complexity of robot motion planning. MIT press (cit. on p. 87).

54. Canny, J. F. and Lin, M. C. (1993). “An opportunistic global path planner”. In: Algorithmica 10.2,
pp. 102–120 (cit. on p. 87).
55. Cao, Z. L., Huang, Y., and Hall, E. L. (1988). “Region filling operations with random obstacle
avoidance for mobile robots”. In: Journal of Robotic Systems 5.2, pp. 87–102 (cit. on pp. 2, 41).
56. Cavanini, L., Ippoliti, G., and Camacho, E. F. (2021). “Model predictive control for a linear
parameter varying model of an UAV”. In: Journal of Intelligent & Robotic Systems 101.3, pp. 1–
18 (cit. on p. 91).
57. Chao, Z., Ming, L., Shaolei, Z., and Wenguang, Z. (2011). “Collision-free UAV formation flight
control based on nonlinear MPC”. In: International Conference on Electronics, Communications
and Control (ICECC). IEEE, pp. 1951–1956 (cit. on pp. 91, 99).
58. Chen, M. and Rincon-Mora, G. (2006). “Accurate electrical battery model capable of predicting
runtime and I-V performance”. In: IEEE Transactions on Energy Conversion 21.2, pp. 504–511
(cit. on pp. 64, 131).
59. Chen, X. and Touba, N. A. (2009). “Ch. 2 - Fundamentals of CMOS design”. In: Electronic
design automation. Morgan Kaufmann, pp. 39–95 (cit. on p. 32).
60. Cheng, K. P., Mohan, R. E., Nhan, N. H. K., and Le, A. V. (2019). “Graph theory-based approach
to accomplish complete coverage path planning tasks for reconfigurable robots”. In: IEEE
Access 7, pp. 94642–94657 (cit. on p. 42).
61. Choset, H., Acar, E., Rizzi, A., and Luntz, J. (2000). “Exact cellular decompositions in terms
of critical points of Morse functions”. In: International Conference on Robotics and Automation
(ICRA). Vol. 3. IEEE, pp. 2270–2277 (cit. on pp. 2, 41, 42, 86, 87, 90).
62. Choset, H. (2000). “Coverage of known spaces: The boustrophedon cellular decomposition”.
In: Autonomous Robots 9.3, pp. 247–253 (cit. on p. 86).
63. —
(2001). “Coverage for robotics–A survey of recent results”. In: Annals of Mathematics
and Artificial Intelligence 31, pp. 113–126 (cit. on pp. 2, 9, 15, 20, 23, 24, 39, 41, 42, 44, 84,
86, 127).

References

137

64. Choset, H. M., Lynch, K. M., Hutchinson, S., Kantor, G., Burgard, W., Kavraki, L., Thrun, S.,
and Arkin, R. C. (2005). Principles of robot motion: Theory, algorithms, and implementation.
MIT press (cit. on pp. 20, 24, 41, 79, 80, 84–87).
65. Choset, H. and Pignon, P. (1998). “Coverage path planning: The boustrophedon cellular decomposition”. In: Field and Service Robotics. Springer, pp. 203–209 (cit. on pp. 23, 41, 84,
129).
66. Chowdhury, P. and Chakrabarti, C. (2005). “Static task-scheduling algorithms for batterypowered DVS systems”. In: IEEE Transactions on Very Large Scale Integration (VLSI) Systems
13.2, pp. 226–237 (cit. on p. 37).
67. Clercq, K. M. D., Kat, R. de, Remes, B., Oudheusden, B. W. van, and Bijl, H. (2009). “Aerodynamic experiments on DelFly II: Unsteady lift enhancement”. In: International Journal of Micro
Air Vehicles 1.4, pp. 255–262 (cit. on p. 6).
68. Collange, S., Defour, D., and Tisserand, A. (2009). “Power consumption of GPUs from a software perspective”. In: Computational Science (ICCS). Ed. by G. Allen, J. Nabrzyski, E. Seidel,
G. D. van Albada, J. Dongarra, and P. M. A. Sloot. Springer, pp. 914–923 (cit. on p. 36).
69. Colombatti, G., Aboudan, A., La Gloria, N., Debei, S., and Flamini, E. (2011). “Lighter-than-air
UAV with SLAM capabilities for mapping applications and atmpsphere analysys”. In: Memorie
della Società Astronomica Italiana Supplementi 16, p. 42 (cit. on p. 6).
70. Colomina, I. and Molina, P. (2014). “Unmanned aerial systems for photogrammetry and remote
sensing: A review”. In: ISPRS Journal of Photogrammetry and Remote Sensing 92, pp. 79–97
(cit. on p. 4).
71. Corke, P. (2017). Robotics, vision and control: Fundamental algorithms in Matlab. 2nd. Springer
(cit. on pp. 1, 5).
72. Crow, B. P., Widjaja, I., Kim, J. G., and Sakai, P. T. (1997). “IEEE 802.11 wireless local area
networks”. In: IEEE Communications Magazine 35.9, pp. 116–126 (cit. on pp. 27, 111).
73. Cui, J. Q., Phang, S. K., Ang, K. Z., Wang, F., Dong, X., Ke, Y., Lai, S., Li, K., Li, X., Lin, F.,
et al. (2015). “Drones for cooperative search and rescue in post-disaster situation”. In: 7th
International Conference on Cybernetics and Intelligent Systems (CIS) and Conference on
Robotics, Automation and Mechatronics (RAM). IEEE, pp. 167–174 (cit. on p. 4).
74. Czarnul, P., Proficz, J., and Krzywaniak, A. (2019). “Energy-aware high-performance computing:
Survey of state-of-the-art tools, techniques, and environments”. In: Scientific Programming
2019 (cit. on p. 32).
75. Dadkhah, N. and Mettler, B. (2012). “Survey of motion planning literature in the presence of
uncertainty: Considerations for UAV guidance”. In: Journal of Intelligent & Robotic Systems
65.1, pp. 233–246 (cit. on p. 44).
76. Daponte, P., De Vito, L., Glielmo, L., Iannelli, L., Liuzza, D., Picariello, F., and Silano, G. (2019).
“A review on the use of drones for precision agriculture”. In: Conference Series: Earth and
Environmental Science. Vol. 275. 1. IOP Publishing, p. 012022 (cit. on pp. 3, 4, 9).
77. Darke, P., Shanks, G., and Broadbent, M. (1998). “Successfully completing case study research:
Combining rigour, relevance and pragmatism”. In: Information Systems Journal 8.4, pp. 273–
289 (cit. on p. 10).

138

References

78. Deng, Z., Yang, L., Cai, Y., and Deng, H. (2017). “Maximum available capacity and energy
estimation based on support vector machine regression for lithium-ion battery”. In: Energy
Procedia 107. 3rd International Conference on Energy and Environment Research (ICEER),
pp. 68–75 (cit. on p. 38).
79. Dharmadhikari, M., Dang, T., Solanka, L., Loje, J., Nguyen, H., Khedekar, N., and Alexis, K.
(2020). “Motion primitives-based path planning for fast and agile exploration using aerial robots”.
In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 179–185 (cit. on
pp. 8, 56).
80. Di Franco, C. and Buttazzo, G. (2015). “Energy-aware coverage path planning of UAVs”. In:
International Conference on Autonomous Robot Systems and Competitions. IEEE, pp. 111–
117 (cit. on pp. 24, 45).
(2016). “Coverage path planning for UAVs photogrammetry with energy and resolution
81. —
constraints”. In: Journal of Intelligent & Robotic Systems 83.3, pp. 445–462 (cit. on p. 45).
82. Diehl, M., Bock, H., Diedam, H., and Wieber, P.-B. (2006). “Fast direct multiple shooting algorithms for optimal robot control”. In: Fast motions in biomechanics and robotics: Optimization
and feedback control. Springer, pp. 65–93 (cit. on p. 96).
83. Dille, M. and Singh, S. (2013). “Efficient aerial coverage search in road networks”. In: Guidance,
Navigation, and Control (GNC) Conference. AIAA, pp. 1–20 (cit. on pp. 24, 46, 89).
84. Dong, F., Heinemann, W., and Kasper, R. (2011). “Development of a row guidance system
for an autonomous robot for white asparagus harvesting”. In: Computers and Electronics in
Agriculture 79.2, pp. 216–225 (cit. on p. 3).
85. Doyle, M., Fuller, T. F., and Newman, J. (1993). “Modeling of galvanostatic charge and discharge of the lithium/polymer/insertion cell”. In: Journal of The Electrochemical Society 140.6,
pp. 1526–1533 (cit. on p. 38).
86. Dressler, F. and Dietrich, I. (2006). “Lifetime analysis in heterogeneous sensor networks”. In:
9th EUROMICRO Conference on Digital System Design (DSD). IEEE, pp. 606–616 (cit. on
p. 41).
87. Dressler, F. and Fuchs, G. (2005). “Energy-aware operation and task allocation of autonomous
robots”. In: 5th International Workshop on Robot Motion and Control (RoMoCo). IEEE, pp. 163–
168 (cit. on p. 40).
88. Edan, Y., Rogozin, D., Flash, T., and Miles, G. E. (2000). “Robotic melon harvesting”. In: IEEE
Transactions on Robotics and Automation 16.6, pp. 831–835 (cit. on p. 3).
89. Eiselt, H. A. and Laporte, G. (2000). “A historical perspective on arc routing”. In: Arc routing:
Theory, solutions and applications. Springer, pp. 1–16 (cit. on p. 46).
90. Erickson, D. (2003). “Non-learning artificial neural network approach to motion planning for the
Pioneer robot”. In: International Conference on Intelligent Robots and Systems (IROS). IEEE,
pp. 112–117 (cit. on p. 47).
91. Ersal, T., Kim, Y., Broderick, J., Guo, T., Sadrpour, A., Stefanopoulou, A., Siegel, J., Tilbury,
D., Atkins, E., Peng, H., et al. (2014). “Keeping ground robots on the move through battery &
mission management”. In: Mechanical Engineering 136.06, pp. 1–6 (cit. on p. 49).

References

139

92. Espedal, I. B., Jinasena, A., Burheim, O. S., and Lamb, J. J. (2021). In: Energies 14.11 (cit. on
p. 62).
93. Fekete, S., Arkin, E., and Mitchell, J. (1994). “The lawnmower problem and other geometric
path covering problems”. In: 15th International Symposium on Mathematical Programming
(cit. on p. 41).
94. Feynman, R., Leighton, R., and Sands, M. (2015). The Feynman lectures on physics, Vol. II:
The new millennium edition: Mainly electromagnetism and matter. Vol. 2. Basic Books (cit. on
p. 79).
95. Fisher, M., Dennis, L., and Webster, M. (2013). “Verifying autonomous systems”. In: Communications of the ACM 56.9, pp. 84–93 (cit. on p. 1).
96. Flautner, K., Reinhardt, S., and Mudge, T. (2001). “Automatic performance setting for dynamic
voltage scaling”. In: 7th Annual International Conference on Mobile Computing and Networking
(MobiCom). ACM, pp. 260–271 (cit. on p. 32).
97. Floreano, D. and Wood, R. J. (2015). “Science, technology and the future of small autonomous
drones”. In: Nature 521.7553, pp. 460–466 (cit. on p. 5).
98. Fomenko, A. T. and Kunii, T. L. (1997). Topological modeling for visualization. Springer (cit. on
p. 46).
99. Forejt, V., Kwiatkowska, M., and Parker, D. (2012). “Pareto curves for probabilistic model checking”. In: Automated Technology for Verification and Analysis. Springer, pp. 317–332 (cit. on
p. 50).
100. Fuchs, G., Truchat, S., and Dressler, F. (2006). “Distributed software management in sensor networks using profiling techniques”. In: 1st International Conference on Communication Systems
Software Middleware. IEEE, pp. 1–6 (cit. on p. 41).
101. Fui Liew, C., DeLatte, D., Takeishi, N., and Yairi, T. (2017). “Recent developments in aerial
robotics: A survey and prototypes overview”. In: arXiv e-prints, arXiv–1711 (cit. on p. 6).
102. Gabriely, Y. and Rimon, E. (2002). “Spiral-STC: An on-line coverage algorithm of grid environments by a mobile robot”. In: International Conference on Robotics and Automation (ICRA).
Vol. 1. IEEE, pp. 954–960 (cit. on p. 42).
103. Galceran, E. and Carreras, M. (2013). “A survey on coverage path planning for robotics”. In:
Robotics and Autonomous Systems 61.12, pp. 1258–1276 (cit. on pp. 2, 9, 15, 20, 23, 41, 42,
44, 84, 86, 127, 129).
104. Gankidi, P. R. and Thangavelautham, J. (2017). “FPGA architecture for deep learning and its
application to planetary robotics”. In: Aerospace Conference. IEEE, pp. 1–9 (cit. on p. 130).
105. García de Marina, H., Kapitanyuk, Y. A., Bronz, M., Hattenberger, G., and Cao, M. (2017).
“Guidance algorithm for smooth trajectory tracking of a fixed wing UAV flying in wind flows”. In:
International Conference on Robotics and Automation (ICRA). IEEE, pp. 5740–5745 (cit. on
pp. 79, 81, 82, 129).
106. García-Martín, E., Rodrigues, C. F., Riley, G., and Grahn, H. (2019). “Estimation of energy
consumption in machine learning”. In: Journal of Parallel and Distributed Computing 134,
pp. 75–88 (cit. on pp. 35, 36).

140

References

107. Gavilan, F., Vazquez, R., and Camacho, E. F. (2015). “An iterative model predictive control
algorithm for UAV guidance”. In: IEEE Transactions on Aerospace and Electronic Systems
51.3, pp. 2406–2419 (cit. on pp. 91, 99).
108. Geem, Z. W. (2009). Music-inspired harmony search algorithm: Theory and applications.
Vol. 191. Springer (cit. on p. 46).
109. Giusti, A., Guzzi, J., Cireşan, D. C., He, F.-L., Rodríguez, J. P., Fontana, F., Faessler, M., Forster,
C., Schmidhuber, J., Caro, G. D., Scaramuzza, D., and Gambardella, L. M. (2016). “A machine
Learning approach to visual perception of forest trails for mobile robots”. In: IEEE Robotics and
Automation Letters 1.2, pp. 661–667 (cit. on p. 56).
110. Goerzen, C., Kong, Z., and Mettler, B. (2010). “A survey of motion planning algorithms from
the perspective of autonomous UAV guidance”. In: Journal of Intelligent and Robotic Systems
57.1, pp. 65–100 (cit. on p. 44).
111. Gold, S. (1997). “A PSPICE macromodel for lithium-ion batteries”. In: 12th Annual Battery
Conference on Applications and Advances. IEEE, pp. 215–222 (cit. on p. 38).
112. Gonçalves, V. M., Pimenta, L. C., Maia, C. A., Dutra, B. C., and Pereira, G. A. (2010). “Vector
fields for robot navigation along time-varying curves in n-dimensions”. In: IEEE Transactions
on Robotics 26.4, pp. 647–659 (cit. on p. 79).
113. Gong, Z., Li, J., and Li, W. (2016). “A low cost indoor mapping robot based on TinySLAM
algorithm”. In: International Geoscience and Remote Sensing Symposium (IGARSS). IEEE,
pp. 4549–4552 (cit. on p. 56).
114. González-Jorge, H., Martínez-Sánchez, J., Bueno, M., et al. (2017). “Unmanned aerial systems
for civil applications: A review”. In: Drones 1.1, p. 2 (cit. on p. 4).
115. Goraczko, M., Liu, J., Lymberopoulos, D., Matic, S., Priyantha, B., and Zhao, F. (2008). “Energyoptimal software partitioning in heterogeneous multiprocessor embedded systems”. In: 45th
ACM/IEEE Design Automation Conference. IEEE, pp. 191–196 (cit. on p. 33).
116. Groen, M., Bruggeman, B., Remes, B., Ruijsink, R., van Oudheusden, B., and Bijl, H. (2010).
“Improving flight performance of the flapping wing MAV DelFly II”. In: International Micro Air
Vehicle Conference and Flight Competition (IMAV). Geman Institue of Navigation, pp. 1–17
(cit. on pp. 6, 9).
117. Grüne, L. and Pannek, J. (2017). “Numerical optimal control of nonlinear systems”. In: Nonlinear model predictive control. Springer, pp. 275–339 (cit. on p. 96).
118. Hajjaj, S. S. H. and Sahari, K. S. M. (2014). “Review of research in the area of agriculture
mobile robots”. In: 8th International Conference on Robotic, Vision, Signal Processing & Power
Applications. Springer, pp. 107–117 (cit. on p. 3).
119. Hamza, A. and Ayanian, N. (2017). “Forecasting battery state of charge for robot missions”. In:
Proceedings of the Symposium on Applied Computing. ACM, pp. 249–255 (cit. on p. 38).
120. Hasan, A., Skriver, M., and Johansen, T. A. (2018). “Exogenous Kalman filter for state-of-charge
estimation in lithium-ion batteries”. In: Conference on Control Technology and Applications
(CCTA). IEEE, pp. 1403–1408 (cit. on pp. 38, 62–64, 131).

References

141

121. Haugen, J. and Imsland, L. (2016). “Monitoring moving objects using aerial mobile sensors”.
In: IEEE Transactions on Control Systems Technology 24.2, pp. 475–486 (cit. on p. 5).
122. Hayat, S., Yanmaz, E., Brown, T. X., and Bettstetter, C. (2017). “Multi-objective UAV path
planning for search and rescue”. In: International Conference on Robotics and Automation
(ICRA). IEEE, pp. 5569–5574 (cit. on pp. 4, 44).
123. He, H., Xiong, R., and Fan, J. (2011). “Evaluation of lithium-ion battery equivalent circuit models
for state of charge estimation by an experimental approach”. In: Energies 4.4, pp. 582–598
(cit. on pp. 39, 63–65, 93).
124. Higa, S., Iwashita, Y., Otsu, K., Ono, M., Lamarre, O., Didier, A., and Hoffmann, M. (2019).
“Vision-based estimation of driving energy for planetary rovers using deep learning and terramechanics”. In: IEEE Robotics and Automation Letters 4.4, pp. 3876–3883 (cit. on p. 130).
125. Hinz, H. (2019). “Comparison of lithium-ion battery models for simulating storage systems in
distributed power generation”. In: Inventions 4 (cit. on pp. 39, 62–65, 93, 131).
126. Ho, D.-K., Ben Chehida, K., Miramond, B., and Auguin, M. (2018). “Towards a multi-mission
QoS and energy manager for autonomous mobile robots”. In: 2nd International Conference on
Robotic Computing (IRC). IEEE, pp. 270–273 (cit. on p. 50).
127. —
(2019a). “Learning-based adaptive management of QoS and energy for mobile robotic
missions”. In: International Journal of Semantic Computing 13.04, pp. 513–539 (cit. on p. 50).
128. —
(2019b). “QoS and energy-aware run-time adaptation for mobile robotic missions: A
learning approach”. In: 3rd International Conference on Robotic Computing (IRC). IEEE,
pp. 212–219 (cit. on p. 50).
129. Hobby, H. (n.d.). Opterra 2m wing BNF basic. https://www.horizonhobby.com/opterra2m-wing-bnf-basic-p-efl11150. Accessed: 2020-02-02 (cit. on p. 3).
130. Hoffer, N. V., Coopmans, C., Jensen, A. M., and Chen, Y. (2014). “A survey and categorization
of small low-cost unmanned aerial vehicle system identification”. In: Journal of Intelligent &
Robotic Systems 74.1, pp. 129–145 (cit. on p. 8).
131. Holper, J. W., Henry, K. V., and Atkins, E. M. (2017). “Cyber-physical thermal modeling for
a small UAS”. In: International Conference on Unmanned Aircraft Systems (ICUAS). IEEE,
pp. 1757–1766 (cit. on pp. 8, 56).
132. Hong, I., Kirovski, D., Qu, G., Potkonjak, M., and B, S. M. (1999). “Power optimization of variablevoltage core-based systems”. In: IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems 18.12, pp. 1702–1714 (cit. on p. 37).
133. Hong, S. and Kim, H. (2010). “An integrated GPU power and performance model”. In: ACM
SIGARCH Computer Architecture News. Vol. 38. 3. ACM, pp. 280–289 (cit. on p. 36).
134. Horowitz, M. (2014). “Computing’s energy problem (and what we can do about it)”. In: International Solid-State Circuits Conference Digest of Technical Papers (ISSCC). IEEE, pp. 10–14
(cit. on pp. 32, 53).
135. Hu, X., Li, S., and Peng, H. (2012). “A comparative study of equivalent circuit models for li-ion
batteries”. In: Journal of Power Sources 198, pp. 359–367 (cit. on p. 38).

142

References

136. Huang, W. (2001). “Optimal line-sweep-based decompositions for coverage algorithms”. In:
International Conference on Robotics and Automation (ICRA). Vol. 1. IEEE, pp. 27–32 (cit. on
pp. 25, 42, 43, 46, 88).
137. Iserles, A. (2009). A first course in the numerical analysis of differential equations. 44. Cambridge University Press (cit. on pp. 65, 94, 96, 97, 99).
138. Ishigami, G., Nagatani, K., and Yoshida, K. (2011). “Path planning and evaluation for planetary
rovers based on dynamic mobility index”. In: International Conference on Intelligent Robots
and Systems (IROS). IEEE, pp. 601–606 (cit. on p. 130).
139. Ivy lightweight software bus (n.d.). https://ivy- python.readthedocs.io/en/latest/
index.html. Accessed: 2021-10-12 (cit. on p. 119).
140. Jaiem, L., Druon, S., Lapierre, L., and Crestani, D. (2016). “A step toward mobile robots autonomy: Energy estimation models”. In: Towards Autonomous Robotic Systems. Springer,
pp. 177–188 (cit. on p. 1).
141. Jaramillo-Avila, U., Aitken, J. M., and Anderson, S. R. (2019). “Visual saliency with foveated
images for fast object detection and recognition in mobile robots using low-power embedded
GPUs”. In: 19th International Conference on Advanced Robotics (ICAR). IEEE, pp. 773–778
(cit. on p. 2).
142. Johansen, T. A. and Fossen, T. I. (2017). “The exogenous kalman filter (XKF)”. In: International
Journal of Control 90.2, pp. 161–167 (cit. on p. 38).
143. Juliá, M., Gil, A., and Reinoso, O. (2012). “A comparison of path planning strategies for autonomous exploration and mapping of unknown environments”. In: Autonomous Robots 33.4,
pp. 427–444 (cit. on p. 41).
144. Jwo, D.-J. and Cho, T.-S. (2007). “A practical note on evaluating Kalman filter performance
optimality and degradation”. In: Applied Mathematics and Computation 193.2, pp. 482–505
(cit. on p. 99).
145. Kalman, R. E. (Mar. 1960). “A new approach to linear filtering and prediction problems”. In:
Journal of Basic Engineering 82.1, pp. 35–45 (cit. on pp. 91, 99).
146. Kang, Y. and Hedrick, J. K. (2009). “Linear tracking for a fixed-wing UAV using nonlinear model
predictive control”. In: IEEE Transactions on Control Systems Technology 17.5, pp. 1202–1210
(cit. on pp. 91, 99).
147. Kapitanyuk, Y. A., Proskurnikov, A. V., and Cao, M. (2017). “A guiding vector-field algorithm
for path-following control of nonholonomic mobile robots”. In: IEEE Transactions on Control
Systems Technology 26.4, pp. 1372–1385 (cit. on p. 79).
148. Karaca, Y., Cicek, M., Tatli, O., Sahin, A., Pasli, S., Beser, M. F., and Turedi, S. (2018). “The
potential use of unmanned aircraft systems (drones) in mountain search and rescue operations”.
In: The American journal of emergency medicine 36.4, pp. 583–588 (cit. on p. 4).
149. Karaman, S. and Frazzoli, E. (2011). “Sampling-based algorithms for optimal motion planning”.
In: The International Journal of Robotics Research 30.7, pp. 846–894 (cit. on p. 47).

References

143

150. Karaman, S., Walter, M. R., Perez, A., Frazzoli, E., and Teller, S. (2011). “Anytime motion
planning using the RRT*”. In: International Conference on Robotics and Automation (ICRA).
IEEE, pp. 1478–1483 (cit. on p. 47).
151. Kasichayanula, K., Terpstra, D., Luszczek, P., Tomov, S., Moore, S., and Peterson, G. D. (2012).
“Power aware computing on GPUs”. In: Symposium on Application Accelerators in High Performance Computing, pp. 64–73 (cit. on p. 35).
152. Keane, J. F. and Carr, S. S. (2013). “A brief history of early unmanned aircraft”. In: Johns
Hopkins APL Technical Digest 32.3, pp. 558–571 (cit. on p. 3).
153. Kellermann, R., Biehle, T., and Fischer, L. (2020). “Drones for parcel and passenger transportation: A literature review”. In: Transportation Research Interdisciplinary Perspectives 4,
p. 100088 (cit. on p. 4).
154. Kim, C. H. and Kim, B. K. (2005). “Energy-saving 3-step velocity control algorithm for batterypowered wheeled mobile robots”. In: International Conference on Robotics and Automation
(ICRA). IEEE, pp. 2375–2380 (cit. on p. 39).
155. Kim, H. and Kim, B.-K. (2008). “Minimum-energy translational trajectory planning for batterypowered three-wheeled omni-directional mobile robots”. In: 10th International Conference on
Control, Automation, Robotics and Vision. IEEE, pp. 1730–1735 (cit. on p. 39).
156. Kim, T. and Qiao, W. (2011). “A hybrid battery model capable of capturing dynamic circuit
characteristics and nonlinear capacity effects”. In: IEEE Transactions on Energy Conversion
26.4, pp. 1172–1180 (cit. on p. 38).
157. Kim, T., Qiao, W., and Qu, L. (2019). “An enhanced hybrid battery model”. In: IEEE Transactions
on Energy Conversion 34.4, pp. 1848–1858 (cit. on p. 38).
158. Kim, Y. G., Kong, J., and Chung, S. W. (2018). “A survey on recent OS-level energy management techniques for mobile processing units”. In: IEEE Transactions on Parallel and Distributed
Systems 29.10, pp. 2388–2401 (cit. on p. 35).
159. Kirk, D. B. and Wen-Mei, W. H. (2016). Programming massively parallel processors: A handson approach. 3rd ed. Morgan Kaufmann (cit. on p. 106).
160. Kostadinov, D. and Scaramuzza, D. (2020). “Online weight-adaptive nonlinear model predictive control”. In: International Conference on Intelligent Robots and Systems (IROS). IEEE,
pp. 1180–1185 (cit. on p. 91).
161. Kreciglowa, N., Karydis, K., and Kumar, V. (2017). “Energy efficiency of trajectory generation
methods for stop-and-go aerial robot navigation”. In: International Conference on Unmanned
Aircraft Systems (ICUAS). IEEE, pp. 656–662 (cit. on p. 44).
162. Krotkov, E. and Simmons, R. G. (1992). “Performance of a six-legged planetary rover: Power,
positioning, and autonomous walking”. In: 1992 IEEE International Conference on Robotics
and Automation (ICRA). IEEE, pp. 169–174 (cit. on p. 130).
163. Kuo, B. (1967). Automatic control systems. Electrical engineering series. Prentice-Hall (cit. on
pp. 68, 69).

144

References

164. Kurzweil, P. and Scheuerpflug, W. (2021). “State-of-charge monitoring and battery diagnosis
of different lithium ion chemistries using impedance spectroscopy”. In: Batteries 7.1 (cit. on
p. 38).
165. Kurzweil, P. and Shamonin, M. (2018). “State-of-charge monitoring by impedance spectroscopy
during long-term self-discharge of supercapacitors and lithium-ion batteries”. In: Batteries 4.3
(cit. on p. 38).
166. Kwon, W. H. and Han, S. H. (2005). Receding horizon control: Model predictive control for
state models. Springer (cit. on p. 91).
167. Lahijanian, M., Svorenova, M., Morye, A. A., Yeomans, B., Rao, D., Posner, I., Newman, P.,
Kress-Gazit, H., and Kwiatkowska, M. (2018). “Resource-performance tradeoff analysis for
mobile robots”. In: IEEE Robotics and Automation Letters 3.3, pp. 1840–1847 (cit. on pp. 1, 8,
12, 23, 47, 49, 50, 77, 91, 129).
168. LaValle, S. M. (2006). Planning algorithms. Cambridge University Press (cit. on pp. 1, 24, 31,
40, 41, 45, 47, 79, 86).
169. Lee, B. C. and Brooks, D. M. (2006a). “Accurate and efficient regression modeling for microarchitectural performance and power prediction”. In: 12th International Conference on Architectural Support for Programming Languages and Operating Systems. ACM, pp. 185–194 (cit. on
pp. 37, 59).
(2006b). “Statistically rigorous regression modeling for the microprocessor design
170. —
space”. In: ISCA-33: Workshop on Modeling, Benchmarking, and Simulation (cit. on pp. 37,
59).
171. Lee, S., Kim, J., Lee, J., and Cho, B. (2008). “State-of-charge and capacity estimation of
lithium-ion battery using a new open-circuit voltage versus state-of-charge”. In: Journal of
Power Sources 185.2, pp. 1367–1373 (cit. on p. 38).
172. Lee, T.-K., Baek, S.-H., Choi, Y.-H., and Oh, S.-Y. (2011). “Smooth coverage path planning and
control of mobile robots based on high-resolution grid map representation”. In: Robotics and
Autonomous Systems 59.10, pp. 801–812 (cit. on p. 42).
173. Lemay, M., Michaud, F., Letourneau, D., and Valin, J.-M. (2004). “Autonomous initialization of
robot formations”. In: International Conference on Robotics and Automation (ICRA). Vol. 3,
pp. 3018–3023 (cit. on p. 47).
174. Leng, J., Hetherington, T., ElTantawy, A., Gilani, S., Kim, N. S., Aamodt, T. M., and Reddi,
V. J. (2013). “GPUWattch: enabling energy optimizations in GPGPUs”. In: SIGARCH Comput.
Archit. News 41.3, pp. 487–498 (cit. on p. 36).
175. Li, Y., Chen, H., Joo Er, M., and Wang, X. (2011). “Coverage path planning for UAVs based
on enhanced exact cellular decomposition method”. In: Mechatronics 21.5. Special Issue on
Development of Autonomous Unmanned Aerial Vehicles, pp. 876–885 (cit. on pp. 24, 42, 46,
88).
176. Li, Z., Liu, J., Li, P., and Li, W. (2008). “Analysis of workspace and kinematics for a tomato
harvesting robot”. In: 2008 International Conference on Intelligent Computation Technology
and Automation (ICICTA). Vol. 1. IEEE, pp. 823–827 (cit. on p. 3).

References

145

177. Lindemann, S. R. and LaValle, S. M. (2005). “Smoothly blending vector fields for global robot
navigation”. In: 44th IEEE Conference on Decision and Control (CDC). IEEE, pp. 3553–3559
(cit. on p. 79).
178. Lotfi, N., Landers, R. G., Li, J., and Park, J. (2017). “Reduced-order electrochemical modelbased SoC observer with output model uncertainty estimation”. In: IEEE Transactions on
Control Systems Technology 25.4, pp. 1217–1230 (cit. on p. 38).
179. Lottes, P., Khanna, R., Pfeifer, J., Siegwart, R., and Stachniss, C. (2017). “UAV-based crop and
weed classification for smart farming”. In: International Conference on Robotics and Automation
(ICRA). IEEE, pp. 3024–3031 (cit. on p. 4).
180. Lu, L., Han, X., Li, J., Hua, J., and Ouyang, M. (2013). “A review on the key issues for lithiumion battery management in electric vehicles”. In: Journal of Power Sources 226, pp. 272–288
(cit. on p. 62).
181. Luo, C. and Suda, R. (2011). “A performance and energy consumption analytical model for
GPU”. In: 9th International Conference on Dependable, Autonomic and Secure Computing.
IEEE, pp. 658–665 (cit. on p. 36).
182. Luo, J. and Jha, N. K. (2001). “Battery-aware static scheduling for distributed real-time embedded systems”. In: 38th annual Design Automation Conference. ACM, pp. 444–449 (cit. on
p. 37).
183. Lv, H., Huang, X., and Liu, Y. (2020). “Analysis on pulse charging–discharging strategies for
improving capacity retention rates of lithium-ion batteries”. In: Ionics 26.4, pp. 1749–1770 (cit.
on p. 92).
184. Ma, K., Li, X., Chen, W., Zhang, C., and Wang, X. (2012). “GreenGPU: A Holistic Approach to
Energy Efficiency in GPU-CPU Heterogeneous Architectures”. In: 41st International Conference on Parallel Processing. IEEE, pp. 48–57 (cit. on p. 35).
185. Madani, S. S., Schaltz, E., and Knudsen Kær, S. (2019). “An electrical equivalent circuit model
of a lithium titanate oxide battery”. In: Batteries 5.1 (cit. on p. 39).
186. Majeed, A. and Lee, S. (2019). “A new coverage flight path planning algorithm based on footprint sweep fitting for unmanned aerial vehicle navigation in urban environments”. In: Applied
Sciences 9.7, pp. 1–17 (cit. on p. 89).
187. Mannadiar, R. and Rekleitis, I. (2010). “Optimal coverage of a known arbitrary environment”.
In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 5525–5530 (cit. on
pp. 24, 46, 84).
188. Marcicki, J., Canova, M., Conlisk, A. T., and Rizzoni, G. (2013). “Design and parametrization
analysis of a reduced-order electrochemical model of graphite/LiFePO4 cells for SoC/SoH
estimation”. In: Journal of Power Sources 237, pp. 310–324 (cit. on p. 38).
189. Marowka, A. (2017). “Energy-aware modeling of scaled heterogeneous systems”. In: International Journal of Parallel Programming 45.5, pp. 1026–1045 (cit. on p. 33).
190. Maza, I. and Ollero, A. (2007). “Multiple UAV cooperative searching operation using polygon
area decomposition and efficient coverage algorithms”. In: Distributed Autonomous Robotic
Systems 6. Springer, pp. 221–230 (cit. on p. 44).

146

References

191. Mei, Y., Lu, Y.-H., Hu, Y. C., and Lee, C. G. (2004). “Energy-efficient motion planning for
mobile robots”. In: International Conference on Robotics and Automation (ICRA). Vol. 5. IEEE,
pp. 4344–4349 (cit. on pp. 2, 39, 40).
192. —
(2005). “A case study of mobile robot’s energy consumption and conservation techniques”. In: 12th International Conference on Advanced Robotics (ICAR). IEEE, pp. 492–497
(cit. on pp. 2, 8, 12, 39, 40, 47, 53, 129).
193. Mei, Y., Lu, Y.-H., Hu, Y., and Lee, C. (2005a). “Deployment strategy for mobile robots with energy and timing constraints”. In: International Conference on Robotics and Automation (ICRA).
IEEE, pp. 2816–2821 (cit. on p. 49).
(2005b). “Reducing the number of mobile sensors for coverage tasks”. In: International
194. —
Conference on Intelligent Robots and Systems (IROS). IEEE, pp. 1426–1431 (cit. on p. 49).
195. Mei, Y., Lu, Y.-H., Hu, Y. C., and Lee, C. G. (2006). “Deployment of mobile robots with energy
and timing constraints”. In: IEEE Transactions on Robotics 22.3, pp. 507–522 (cit. on pp. 1, 12,
47, 49, 129).
196. Mei, Y., Lu, Y.-H., Lee, C., and Hu, Y. (2006). “Energy-efficient mobile robot exploration”. In:
International Conference on Robotics and Automation (ICRA). IEEE, pp. 505–511 (cit. on pp. 8,
49).
197. Milas, A. S., Cracknell, A. P., and Warner, T. A. (2018). “Drones - The third generation source
of remote sensing data”. In: International Journal of Remote Sensing 39.21, pp. 7125–7137
(cit. on p. 4).
198. Mittal, S. (2019). “A survey on optimized implementation of deep learning models on the
NVIDIA Jetson platform”. In: Journal of Systems Architecture 97, pp. 428–442 (cit. on p. 35).
199. Mittal, S. and Vetter, J. S. (2014). “A survey of methods for analyzing and improving GPU
energy efficiency”. In: ACM Comput. Surv. 47.2, pp. 1–23 (cit. on p. 35).
200. Moler, C. and Van Loan, C. (2003). “Nineteen dubious ways to compute the exponential of a
matrix, twenty-five years later”. In: SIAM review 45.1, pp. 3–49 (cit. on p. 69).
201. Morbidi, F., Cano, R., and Lara, D. (2016). “Minimum-energy path generation for a quadrotor
UAV”. In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 1492–1498
(cit. on p. 44).
202. Moura, S. J., Argomedo, F. B., Klein, R., Mirtabatabaei, A., and Krstic, M. (2017). “Battery state
estimation for a single particle model with electrolyte dynamics”. In: IEEE Transactions on
Control Systems Technology 25.2, pp. 453–468 (cit. on p. 38).
203. Mousavi G., S. and Nikdel, M. (2014). “Various battery models for various simulation studies
and applications”. In: Renewable and Sustainable Energy Reviews 32, pp. 477–485 (cit. on
pp. 39, 63–65, 93, 131).
204. Muirhead, B. K. and Karp, A. (2019). “Mars sample return lander mission concepts”. In:
Aerospace Conference. IEEE, pp. 1–9 (cit. on p. 130).
205. Nam, L. H., Huang, L., Li, X. J., and Xu, J. F. (2016). “An approach for coverage path planning
for UAVs”. In: 14th International Workshop on Advanced Motion Control (AMC). IEEE, pp. 411–
416 (cit. on p. 45).

References

147

206. Needham, T. (1998). Visual complex analysis. Oxford University Press (cit. on p. 79).
207. Nikov, K., Nunez-Yanez, J. L., and Horsnell, M. (2015). “Evaluation of hybrid run-time power
models for the ARM big.LITTLE architecture”. In: 13th International Conference on Embedded
and Ubiquitous Computing. IEEE, pp. 205–210 (cit. on pp. 37, 107).
208. Nocedal, J. and Wright, S. (2006). Numerical optimization. Springer (cit. on pp. 95, 96).
209. Noor, N. M., Abdullah, A., and Hashim, M. (2018). “Remote sensing UAV/drones and its applications for urban areas: A review”. In: Conference Series: Earth and Environmental Science.
Vol. 169. 1. IOP Publishing, p. 012003 (cit. on p. 4).
210. Nunez-Yanez, J. and Lore, G. (2013). “Enabling accurate modeling of power and energy consumption in an ARM-based System-on-Chip”. In: Microprocessors and Microsystems 37.3,
pp. 319–332 (cit. on pp. 37, 107).
211. O’Brien, K., Pietri, I., Reddy, R., Lastovetsky, A., and Sakellariou, R. (2017). “A survey of power
and energy predictive models in HPC systems and applications”. In: ACM Comput. Surv. 50.3,
pp. 1–38 (cit. on p. 32).
212. O’Neal, K. and Brisk, P. (2018). “Predictive modeling for CPU, GPU, and FPGA performance
and power consumption: A survey”. In: Computer Society Annual Symposium on VLSI (ISVLSI).
IEEE, pp. 763–768 (cit. on p. 32).
213. Ogata, K. (2002). Modern control engineering. Prentice-Hall (cit. on p. 69).
214. Ondrúška, P., Gurău, C., Marchegiani, L., Tong, C. H., and Posner, I. (2015). “Scheduled
perception for energy-efficient path following”. In: International Conference on Robotics and
Automation (ICRA). IEEE, pp. 4799–4806 (cit. on pp. 1, 8, 11, 12, 23, 31, 39, 47, 49, 50, 53,
91, 127, 129, 130).
215. Ono, M., Rothrock, B., Otsu, K., Higa, S., Iwashita, Y., Didier, A., Islam, T., Laporte, C., Sun,
V., Stack, K., et al. (2020). “MAARS: Machine learning-based analytics for automated rover
systems”. In: Aerospace Conference. IEEE, pp. 1–17 (cit. on p. 130).
216. Panagou, D. (2014). “Motion planning and collision avoidance using navigation vector fields”.
In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 2513–2518 (cit. on
p. 79).
217. Panigrahi, D., Chiasserini, C., Dey, S., Rao, R., Raghunathan, A., and Lahiri, K. (2001). “Battery
life estimation of mobile embedded systems”. In: 14th International Conference on VLSI Design.
IEEE, pp. 57–63 (cit. on p. 39).
218. Papachristos, C., Tzoumanikas, D., and Tzes, A. (2015). “Aerial robotic tracking of a generalized mobile target employing visual and spatio-temporal dynamic subject perception”. In:
International Conference on Intelligent Robots and Systems (IROS). IEEE, pp. 4319–4324
(cit. on pp. 8, 56).
219. Paparazzi (n.d.[a]). NPS new paparazzi simulator. https : / / wiki . paparazziuav . org /
wiki/NPS. Accessed: 2021-10-12 (cit. on p. 119).
220. —
(n.d.[b]). UAV open-source project. http://wiki.paparazziuav.org/. Accessed:
2021-10-12 (cit. on pp. 9, 101, 108, 114, 119).

148

References

221. Paucar, C., Morales, L., Pinto, K., Sánchez, M., Rodríguez, R., Gutierrez, M., and Palacios, L.
(2018). “Use of drones for surveillance and reconnaissance of military areas”. In: International
Conference of Research Applied to Defense and Security. Springer, pp. 119–132 (cit. on p. 4).
222. Pedram, M. and Wu, Q. (1999). “Design considerations for battery-powered electronics”. In:
36th Annual Design Automation Conference. ACM, pp. 861–866 (cit. on p. 38).
223. Peng, T., Zhang, D., Liu, R., Asari, V. K., and Loomis, J. S. (2019). “Evaluating the power
efficiency of visual SLAM on embedded GPU systems”. In: National Aerospace and Electronics
Conference (NAECON). IEEE, pp. 117–121 (cit. on p. 56).
224. Pensieri, M. G., Garau, M., and Barone, P. M. (2020). “Drones as an integral part of remote
sensing technologies to help missing people”. In: Drones 4.2, p. 15 (cit. on p. 4).
225. Percin, M., Eisma, J., Van Oudheusden, B., Remes, B., Ruijsink, R., and De Wagter, C. (2012).
“Flow visualization in the wake of the flapping-wing MAV ‘DelFly II’ in forward flight”. In: 30th
Applied Aerodynamics Conference. AIAA (cit. on p. 6).
226. Popović, M., Hitz, G., Nieto, J., Sa, I., Siegwart, R., and Galceran, E. (2017). “Online informative
path planning for active classification using UAVs”. In: International Conference on Robotics
and Automation (ICRA). IEEE, pp. 5753–5758 (cit. on pp. 4, 44).
227. Puri, V., Nayyar, A., and Raja, L. (2017). “Agriculture drones: A modern breakthrough in precision agriculture”. In: Journal of Statistics and Management Systems 20.4, pp. 507–518 (cit. on
pp. 3, 4).
228. PX4 (n.d.). PX4 open-source autopilot. https://px4.io/. Accessed: 2021-10-13 (cit. on
pp. 10, 46).
229. Qingchun, F., Wengang, Z., Quan, Q., Kai, J., and Rui, G. (2012). “Study on strawberry robotic
harvesting system”. In: International Conference on Computer Science and Automation Engineering (CSAE). Vol. 1. IEEE, pp. 320–324 (cit. on p. 3).
230. Quigley, M., Conley, K., Gerkey, B., Faust, J., Foote, T., Leibs, J., Wheeler, R., and Ng, A. Y.
(2009). “ROS: An open-source robot operating system”. In: ICRA Workshop on Open Source
Software. Vol. 3. 3.2, p. 5 (cit. on pp. 12, 59).
231. Rakhmatov, D. and Vrudhula, S. (2001). “An analytical high-level battery model for use in
energy management of portable electronic systems”. In: International Conference on Computer
Aided Design (ICCAD) Digest of Technical Papers. IEEE, pp. 488–493 (cit. on p. 38).
232. Ramasamy, M. and Ghose, D. (2017). “A heuristic learning algorithm for preferential area
surveillance by unmanned aerial vehicles”. In: Journal of Intelligent & Robotic Systems 88.2,
pp. 655–681 (cit. on p. 4).
233. Rao, R., Vrudhula, S., and Rakhmatov, D. N. (2003). “Battery modeling for energy aware system
design”. In: Computer 36.12, pp. 77–87 (cit. on pp. 38, 62).
234. Rao, V., Singhal, G., Kumar, A., and Navet, N. (2005). “Battery model for embedded systems”.
In: 18th International Conference on VLSI Design held jointly with 4th International Conference
on Embedded Systems Design. IEEE, pp. 105–110 (cit. on pp. 32, 39).
235. Rawlings, J. B., Mayne, D. Q., and Diehl, M. (2017). Model predictive control: Theory, computation, and design. Vol. 2. Nob Hill Publishing (cit. on pp. 11, 91, 95–97).

References

149

236. Reddy, B. K., Walker, M. J., Balsamo, D., Diestelhorst, S., Al-Hashimi, B. M., and Merrett,
G. V. (2017). “Empirical CPU power modelling and estimation in the gem5 simulator”. In:
27th International Symposium on Power and Timing Modeling, Optimization and Simulation
(PATMOS), pp. 1–8 (cit. on p. 37).
237. Redmon, J. (2013–2016). Darknet: Open Source Neural Networks in C. http://pjreddie.
com/darknet/ (cit. on p. 102).
238. Redmon, J., Divvala, S., Girshick, R., and Farhadi, A. (2016). “You only look once: Unified, realtime object detection”. In: Conference on Computer Vision and Pattern Recognition (CVPR).
IEEE, pp. 779–788 (cit. on pp. 102, 108).
239. Redmon, J. and Farhadi, A. (2017). “YOLO9000: Better, Faster, Stronger”. In: Conference on
Computer Vision and Pattern Recognition (CVPR). IEEE, pp. 6517–6525 (cit. on p. 102).
240. Renzaglia, A., Reymann, C., and Lacroix, S. (2016). “Monitoring the evolution of clouds with
UAVs”. In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 278–283
(cit. on p. 4).
241. Rizvi, S. T. H., Cabodi, G., Patti, D., and Gulzar, M. M. (2017). “A general-purpose graphics
processing unit (GPGPU)-accelerated robotic controller using a low power mobile platform”. In:
Journal of Low Power Electronics and Applications 7.2, p. 10 (cit. on p. 2).
242. Rossiter, J. A. (2004). Model-based predictive control: A practical approach. CRC press (cit. on
p. 91).
243. Rouxel, B., Schultz, U. P., Akesson, B., Holst, J., Jorgensen, O., and Grelck, C. (2020). “PReGO:
A generative methodology for satisfying real-time requirements on COTS-based systems: Definition and experience report”. In: SIGPLAN International Conference on Generative Programming: Concepts and Experiences (GPCE). ACM, pp. 70–83 (cit. on p. 11).
244. Ryou, G., Sim, Y., Yeon, S. H., and Seok, S. (2018). “Applying asynchronous deep classification
networks and gaming reinforcement learning-based motion planners to mobile robots”. In:
International Conference on Robotics and Automation (ICRA). IEEE, pp. 6268–6275 (cit. on
p. 56).
245. Sa, I., Chen, Z., Popović, M., Khanna, R., Liebisch, F., Nieto, J., and Siegwart, R. (2018).
“weedNet: Dense semantic weed classification using multispectral images and MAV for smart
farming”. In: IEEE Robotics and Automation Letters 3.1, pp. 588–595 (cit. on p. 4).
246. Sadat, S. A., Wawerla, J., and Vaughan, R. T. (2014). “Recursive non-uniform coverage of
unknown terrains for UAVs”. In: International Conference on Intelligent Robots and Systems
(IROS). IEEE, pp. 1742–1747 (cit. on p. 45).
247. Sadrpour, A., Jin, J., and Ulsoy, A. G. (2013a). “Mission energy prediction for unmanned ground
vehicles using real-time measurements and prior knowledge”. In: Journal of Field Robotics
30.3, pp. 399–414 (cit. on pp. 12, 47, 49, 129).
248. Real-time energy-efficient path planning for unmanned ground vehicles using mission prior
knowledge (2013b). ASME, pp. 1–10 (cit. on p. 49).
249. Sadrpour, A., Jin, J., and Ulsoy, A. G. (2013c). “Experimental validation of mission energy
prediction model for unmanned ground vehicles”. In: American Control Conference. IEEE,
pp. 5960–5965 (cit. on pp. 12, 47, 49, 129).

150

References

250. Salameh, Z., Casacca, M., and Lynch, W. (1992). “A mathematical model for lead-acid batteries”. In: IEEE Transactions on Energy Conversion 7.1, pp. 93–98 (cit. on pp. 64, 131).
251. Sandler, M., Howard, A., Zhu, M., Zhmoginov, A., and Chen, L.-C. (2018). “MobileNetV2:
Inverted residuals and linear bottlenecks”. In: Conference on Computer Vision and Pattern
Recognition (CVPR). IEEE, pp. 4510–4520 (cit. on p. 111).
252. Satria, M. T., Gurumani, S., Zheng, W., Tee, K. P., Koh, A., Yu, P., Rupnow, K., and Chen, D.
(2016). “Real-time system-level implementation of a telepresence robot using an embedded
GPU platform”. In: Design, Automation & Test in Europe Conference & Exhibition (DATE). IEEE,
pp. 1445–1448 (cit. on p. 2).
253. Schneier, B. (1993). “Description of a new variable-length key, 64-bit block cipher (Blowfish)”.
In: International Workshop on Fast Software Encryption. Springer, pp. 191–204 (cit. on p. 109).
254. Schuyler, T. J., Gohari, S., Pundsack, G., Berchoff, D., and Guzman, M. I. (2019). “Using a
balloon-launched unmanned glider to validate real-time WRF modeling”. In: Sensors 19.8,
p. 1914 (cit. on p. 4).
255. Seguin, C., Blaquière, G., Loundou, A., Michelet, P., and Markarian, T. (2018). “Unmanned
aerial vehicles (drones) to prevent drowning”. In: Resuscitation 127, pp. 63–67 (cit. on p. 4).
256. Shi, P. and Zhao, Y. (2006). “Application of unscented Kalman filter in the SoC estimation
of li-ion battery for autonomous mobile robot”. In: International Conference on Information
Acquisition. IEEE, pp. 1279–1283 (cit. on p. 62).
257. Shnaps, I. and Rimon, E. (2016). “Online coverage of planar environments by a battery powered autonomous mobile robot”. In: IEEE Transactions on Automation Science and Engineering
13.2, pp. 425–436 (cit. on pp. 42, 43).
258. Siciliano, B. and Khatib, O. (2016a). Handbook of robotics. Springer. Chap. Chapter 47,
pp. 1177–1201 (cit. on p. 1).
259. —
(2016b). Handbook of robotics. Springer. Chap. Chapter 44, pp. 1012–1014 (cit. on
pp. 3–6).
260. Simon, D. (2006). Optimal state estimation: Kalman, H infinity, and nonlinear approaches. John
Wiley & Sons (cit. on pp. 11, 91, 99, 100).
261. Song, Y. and Scaramuzza, D. (2020). “Learning high-level policies for model predictive control”.
In: International Conference on Intelligent Robots and Systems (IROS). IEEE, pp. 7629–7636
(cit. on p. 91).
262. Stastny, T. and Siegwart, R. (2018). “Nonlinear Model Predictive Guidance for Fixed-wing UAVs
Using Identified Control Augmented Dynamics”. In: International Conference on Unmanned
Aircraft Systems (ICUAS). IEEE, pp. 432–442 (cit. on pp. 91, 99).
263. Stroustrup, B. (1988). “What is object-oriented programming?” In: IEEE Software 5.3, pp. 10–
20 (cit. on p. 59).
264. Sudhakar, S., Karaman, S., and Sze, V. (2020). “Balancing actuation and computing energy
in motion planning”. In: International Conference on Robotics and Automation (ICRA). IEEE,
pp. 4259–4265 (cit. on pp. 1, 2, 8, 12, 31, 47, 50, 101, 127, 129).

References

151

265. Sundén, B. (2019). “Thermal management of batteries”. In: Hydrogen, Batteries and Fuel Cells.
Ed. by B. Sundén. Academic Press, pp. 93–110 (cit. on p. 38).
266. Susman, G. I. and Evered, R. D. (1978). “An assessment of the scientific merits of action
research”. In: Administrative Science Quarterly 23.4, pp. 582–603 (cit. on p. 10).
267. Syracuse, K. and Clark, W. (1997). “A statistical approach to domain performance modeling for
oxyhalide primary lithium batteries”. In: 12th Annual Battery Conference on Applications and
Advances. IEEE, pp. 163–170 (cit. on p. 38).
268. Szeliski, R. (2011). Computer vision algorithms and applications. London: Springer (cit. on
p. 104).
269. Takouna, I., Dawoud, W., and Meinel, C. (2011). “Accurate mutlicore processor power models
for power-aware resource management”. In: 9th International Conference on Dependable,
Autonomic and Secure Computing. IEEE, pp. 419–426 (cit. on p. 37).
270. Tang, L. and Shao, G. (2015). “Drone remote sensing for forestry research and practices”. In:
Journal of Forestry Research 26.4, pp. 791–797 (cit. on p. 4).
271. TeamPlay Consortium (2019a). Deliverable D4.3: Report on energy, timing and security modeling of complex architectures (v2.0). https : / / gitlab . inria . fr / TeamPlay _ Public /
TeamPlay _ Public _ Deliverables/ - /blob / master / D4 . 3 . pdf. Accessed: 2021-10-04
(cit. on pp. 59, 103).
(2019b). Deliverables of the TeamPlay H2020 project. https://teamplay-h2020.eu/
index.php?page=deliverables. Accessed: 2021-10-04 (cit. on pp. 11, 130).

272. —

273. Tian, R., Park, S.-H., King, P. J., Cunningham, G., Coelho, J., Nicolosi, V., and Coleman, J. N.
(2019). “Quantifying the factors limiting rate performance in battery electrodes”. In: Nature
Communications 10.1, pp. 1–11 (cit. on p. 92).
274. Torrente, G., Kaufmann, E., Föhn, P., and Scaramuzza, D. (2021). “Data-driven MPC for quadrotors”. In: IEEE Robotics and Automation Letters 6.2, pp. 3769–3776 (cit. on p. 91).
275. Ullah, M., Mohammed, A., and Alaya Cheikh, F. (2018). “PedNet: A spatio-temporal deep
convolutional neural network for pedestrian segmentation”. In: Journal of Imaging 4.9, p. 107
(cit. on pp. 111, 115, 119).
276. Valavanis, K. P. and Vachtsevanos, G. J. (2015). Handbook of unmanned aerial vehicles. Vol. 1.
Springer (cit. on p. 3).
277. Valente, J., Del Cerro, J., Barrientos, A., and Sanz, D. (2013). “Aerial coverage optimization in
precision agriculture management: A musical harmony inspired approach”. In: Computers and
Electronics in Agriculture 99, pp. 153–159 (cit. on p. 46).
278. Viega, J., Messier, M., and Chandra, P. (2002). Network security with OpenSSL: cryptography
for secure communications. O’Reilly (cit. on p. 109).
279. Voosen, P. (2019). “NASA to fly drone on Titan”. In: AAAS (cit. on p. 5).
280. Wächter, A. and Biegler, L. T. (2006). “On the implementation of an interior-point filter linesearch algorithm for large-scale nonlinear programming”. In: Mathematical programming 106.1,
pp. 25–57 (cit. on p. 99).

152

References

281. Wahab, M., Rios-Gutierrez, F., and El Shahat, A. (2015). “Energy modeling of differential drive
robots”. In: Southeast Conference (SoutheastCon). IEEE (cit. on p. 39).
282. Walker, M. J., Diestelhorst, S., Hansson, A., Das, A. K., Yang, S., Al-Hashimi, B. M., and Merrett,
G. V. (2017). “Accurate and stable run-time power modeling for mobile and embedded CPUs”.
In: IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems 36.1,
pp. 106–119 (cit. on pp. 37, 38).
283. Wang, L., Ye, X., Xing, H., Wang, Z., and Li, P. (2020). “YOLO nano underwater: A fast and
compact object detector for embedded device”. In: Global Oceans Conference. IEEE, pp. 1–4
(cit. on p. 56).
284. Wang, L. (2009). Model predictive control system design and implementation using Matlab.
Springer (cit. on p. 91).
285. Wang, X., Jiang, P., Li, D., and Sun, T. (2017). “Curvature continuous and bounded path planning for fixed-wing UAVs”. In: Sensors 17.9 (cit. on pp. 1, 24, 44, 84).
286. Watts, A. C., Ambrosia, V. G., and Hinkley, E. A. (2012). “Unmanned aircraft systems in remote
sensing and scientific research: Classification and considerations of use”. In: Remote Sensing
4.6, pp. 1671–1692 (cit. on p. 8).
287. Wegner, P. (1990). “Concepts and paradigms of object-oriented programming”. In: SIGPLAN
OOPS Mess. 1.1, pp. 7–87 (cit. on p. 59).
288. Wei, M. and Isler, V. (2018). “Coverage path planning under the energy constraint”. In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 368–373 (cit. on pp. 40, 42,
43).
289. Wright, O. (Dec. 1913). “How we made the first flight”. In: Flying (cit. on p. iii).
290. Wu, G., Greathouse, J. L., Lyashevsky, A., Jayasena, N., and Chiou, D. (2015). “GPGPU
performance and power estimation using machine learning”. In: 21st International Symposium
on High Performance Computer Architecture (HPCA). IEEE, pp. 564–576 (cit. on p. 36).
291. Xia, B., Chen, C., Tian, Y., Wang, M., Sun, W., and Xu, Z. (2015). “State of charge estimation
of lithium-ion batteries based on an improved parameter identification method”. In: Energy 90,
pp. 1426–1434 (cit. on pp. 38, 62).
292. Xing, Y., He, W., Pecht, M., and Tsui, K. L. (2014). “State of charge estimation of lithium-ion
batteries using the open-circuit voltage at various ambient temperatures”. In: Applied Energy
113, pp. 106–115 (cit. on p. 38).
293. Xu, A., Viriyasuthee, C., and Rekleitis, I. (2011). “Optimal complete terrain coverage using an
unmanned aerial vehicle”. In: International Conference on Robotics and Automation (ICRA).
IEEE, pp. 2513–2519 (cit. on pp. 24, 42, 44, 46, 84, 88, 89).
294. —
(2014). “Efficient complete coverage of a known arbitrary environment with applications
to aerial operations”. In: Autonomous Robots 36.4, pp. 365–381 (cit. on pp. 24, 25, 46, 84, 88,
89).
295. Yamauchi, B. M. (2004). “PackBot: A versatile platform for military robotics”. In: Unmanned
Ground Vehicle Technology VI. Ed. by G. R. Gerhart, C. M. Shoemaker, and D. W. Gage.
Vol. 5422. International Society for Optics and Photonics. SPIE, pp. 228–237 (cit. on p. 49).

References

153

296. Yang, T.-J., Chen, Y.-H., Emer, J., and Sze, V. (2017). “A method to estimate the energy consumption of deep neural networks”. In: 51st Asilomar Conference on Signals, Systems, and
Computers. IEEE, pp. 1916–1920 (cit. on pp. 35, 36).
297. Yang, T.-J., Chen, Y.-H., and Sze, V. (2017). “Designing energy-efficient convolutional neural networks using energy-aware pruning”. In: Conference on Computer Vision and Pattern
Recognition (CVPR). IEEE, pp. 5687–5695 (cit. on p. 35).
298. Yeomans, B., Porav, H., Gadd, M., Barnes, D., Dequaire, J., Wilcox, T., Kyberd, S., Venn, S., and
Newman, P. (2017). “MURFI 2016-From cars to Mars: Applying autonomous vehicle navigation
methods to a space rover mission”. In: 14th Symposium on Advanced Space Technologies in
Robotics and Automation (ASTRA), pp. 1–8 (cit. on p. 50).
299. Zelinsky, A., Jarvis, R., Byrne, J. C., and Yuta, S. (1993). “Planning paths of complete coverage of an unstructured environment by a mobile robot”. In: In Proceedings of International
Conference on Advanced Robotics. IEEE, pp. 533–538 (cit. on p. 42).
300. Zhang, C., Allafi, W., Dinh, Q., Ascencio, P., and Marco, J. (2018). “Online estimation of battery equivalent circuit model parameters and state of charge using decoupled least squares
technique”. In: Energy 142, pp. 678–688 (cit. on pp. 39, 62–64, 131).
301. Zhang, C., Li, K., Mcloone, S., and Yang, Z. (2014). “Battery modelling methods for electric
vehicles - A review”. In: European Control Conference (ECC). IEEE, pp. 2673–2678 (cit. on
pp. 38, 62).
302. Zhang, F., Liu, G., and Fang, L. (2009). “Battery state estimation using unscented Kalman
filter”. In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 1863–1868
(cit. on p. 39).
303. Zhang, F., Liu, G., Fang, L., and Wang, H. (2012). “Estimation of battery state of charge
with H infinity observer: Applied to a robot for inspecting power transmission lines”. In: IEEE
Transactions on Industrial Electronics 59.2, pp. 1086–1095 (cit. on p. 39).
304. Zhang, L., Tiwana, B., Qian, Z., Wang, Z., Dick, R. P., Mao, Z. M., and Yang, L. (2010). “Accurate
online power estimation and automatic battery behavior based power model generation for
smartphones”. In: 8th International Conference on Hardware/Software Codesign and System
Synthesis. ACM, pp. 105–114 (cit. on p. 39).
305. Zhang, R., Xia, B., Li, B., Cao, L., Lai, Y., Zheng, W., Wang, H., and Wang, W. (2018). “State
of the art of lithium-ion battery SoC estimation for electrical vehicles”. In: Energies 11.7 (cit. on
p. 62).
306. Zhang, W. and Hu, J. (2007). “Low power management for autonomous mobile robots using
optimal control”. In: 46th Conference on Decision and Control (CDC). IEEE, pp. 5364–5369
(cit. on pp. 12, 23, 47, 49, 91, 129, 131).
307. Zhou, D. and Schwager, M. (2014). “Vector field following for quadrotors using differential
flatness”. In: International Conference on Robotics and Automation (ICRA). IEEE, pp. 6567–
6572 (cit. on p. 79).

Index
ceiling edge, 90
cells, 85
cellular decomposition, 85
charging strategies, 92
Chinese postman problem, 46
circle, 18
class
model_1layer, 60
model_2layer, 60
sampler, 59
sampler_nano, 60
sampler_odroid, 60
sampler_tx2, 60
coax, 5
coaxial aerial robot, 4
collocation method, 96
comma-separated values, 58
command-line, 109
computations, 1, 9, 16
blowfish, 109
darknet-cpu, 106
darknet-gpu, 102
matrix-cpu, 106
matrix-gpu, 104
nvidia-matrix, 106
nvidia-quicks, 106
pednet, 111
ssd-mobilenet, 111
computations energy, 16

active research, 10
Adept MobileRobots, 47
adjacency graph, 84
admissible region, 75
ant colony optimization, 45
anytime planning, 47
approximation method, 59
ARC Q14, 50
artificial intelligence, 44
autonomy, 1
Bézier curves, 46
barometer, 3
battery chemistry, 92
battery model, 61
Bayes estimation, 47
bitwidth, 35
blimps, 6
Blowfish algorithm, 109
boustrophedon decomposition, 41, 86
boustrophedon motion, 24, 40, 41, 88
boustrophedon-like motion, 24
breadth-first algorithm, 45
C++, 59
C-rate, 62
capacitor, 38
capacity fade, 92
CasADi, 99
case study, 10
155

156

Index

computations parameters, 19
constraint set, 19
continuity, 17
control surface, 8
convolutional neural network, 9, 27, 56, 111
coverage motion, 88
coverage path planning, 2, 10, 15, 41, 84, 108,
127

coverage problem, 23
coverage space, 85
covering salesman problem, 41
CPU, 9
critical points, 86
cruise, 109
CUDA, 36
darknet, 102
data mining, 35
data type
pathn, 60
vectorn, 60
deep neural network, 35
depth-first search, 45, 85
difference of motion and computations energy, 16
Dijkstra algorithm, 45
discharging strategies, 92
distributed model predictive control, 91
Dubins path motion, 45
dynamic frequency scaling, 32
dynamic loads, 38
dynamic voltage scaling, 32
electrostatic
field, 79
potential, 79
electrostatics, 79
elemental region, 2
encryption, 27, 109
energy, 79
energy density, 62
equivalent circuit model, 38, 62, 93

equivalent electrical circuit, 93
Euler method, 97
evolutionary optimization, 44
eXogenous Kalman filter, 38
final
point, 20
stage, 20
finite state machine, 21
fixed-wings, 5
flapping-wings, 5
flight controller, 46
flight dynamics model, 119
flight phases, 109
floor edge, 90
flowing heat, 79
force, 79
forecast, 91
frames per second, 16, 57
free space, 85
frequency, 61
fully convolutional network, 111
function
dryrun, 59
get_sample, 59
start, 61
stop, 61
gem5, 37
genetic algorithm, 45
genral-purpose GPU, 36
geologic conformations, 109
gimbal, 46
global navigation satellite system, 3
global positioning system, 4
GoPro camera, 45
GPU, 2, 9
gradient, 79
gradient descent, 10, 80
gradient descent algorithm, 79
gravitational field, 79
grid decomposition, 84

Index

guidance, 78
gyroscope, 3
heavier-than-air aerial robots, 5
helicopters, 5
helium, 6
hertz, 115
heterogeneous computing hardware, 1
Hewitt-Sperry automatic airplane, 3
hexacopters, 5
high performance computing, 33
hovering, 5
hydrodynamics, 79
IEEE 802.11, 27, 111
inertial measurement unit, 3
Ingenuity Mars Helicopter, 4
integer linear programming, 33
integration step, 61
interest zones, 84
IPOPT, 99
IRIS rotary-wing aerial robot, 45
joules, 57
JSBSim, 119
Kalman filter, 67, 91, 99, 116
landing, 109
lawnmower, 45
lift, 6
lighter-than-air aerial robots, 6
line, 17
Linux, 59
lithium ion battery, 39, 62, 92
lithium polymer battery, 46
Lockheed D-21, 4
magnetic field, 79
Markov processes, 39
Mars, 4
measurement layer, 55, 57
memory

157

non-volatile, 57
random access, 57
memory effect, 62
meteorology, 4
micro aerial vehicles, 6
microcontroller, 8, 33
MIT license, 59
model predictive control, 77, 118, 121
modified boustrophedon motion, 45
modified Zamboni motion, 45
Morse functions, 42, 86
motion, 16
motion energy, 16
motion planning, 1
motion primitives, 1
motor, 8
multicore CPU, 9, 37
multiple shooting method, 96, 99
multirotors, 5
NASA, 4
new paparazzi simulator, 119
no-flight zones, 84
no-interest zones, 23, 84, 114, 124
nominal control, 72
nonholonomic constraints, 43, 77
nonlinear program, 96
NP-hard, 84
numerical integration, 65
numerical simulation, 94, 96
NVIDIA Jetson
Developer Kit, 56
Nano, 55, 107, 111, 124
TK1, 55, 60, 107
TX2, 55, 56, 102, 107
object detection, 56
object-oriented programming, 59
obstacles, 23
octocopters, 5
ODROID XU3, 55, 56, 107
omnidirectional wheels, 40

158

OpenSSL, 109
Opterra fixed-wing aerial robot, 3, 24, 66, 77,
84, 109
optimal control, 77
optimal control problem, 91
output constraint, 94
output model predictive control, 91
overall energy, 16
Oxford Robotics Insitute, 50
PackBot UGV, 49
Pareto front, 50
path functions, 17, 77
path parameters, 19
path planning, 56
payload delivery, 2, 4
PedNet, 111, 119
perception algorithms, 1
performance monitoring counters, 38
period, 21
Pioneer 3DX ActivMedia, 47, 50
Pioneer mobile robots, 47
plane, 17
planning, 1
planning algorithms, 39
planning problem, 23
potential functions, 78
power density, 62
powprofiler, 59
precision agriculture, 3
predictive layer, 55, 58
preprocessor, 61
primitive paths, 20, 77
probabilitstic roadmaps, 47
public-key infrastructure, 27
quadcopters, 5
quadrature, 99
quadrotors, 5
qualitative research, 10
quality of service, 35

Index

receding horizon predictive control, 91
reconnaissance, surveillance, and target acquisition, 4
Reeb graph, 46
reinforcement learning, 50
remote sensing, 4
remotely piloted vehicles, 3
resistance, 38
resistor, 38
roadmaps, 86
Robot Operating System, 59, 107
robust model predictive control, 91
ROS
bag, 113
core, 124
node, 27, 115, 119
topic, 113, 119
rotary-wings, 5
Runge-Kutta method, 65, 97
Ryan Firebee, 3
sampling-to-completion, 57
Saturn, 5
scheduling, 1
search and rescue, 2, 4
self-discharge rate, 62
servo, 8
shift, 20
shortcut search, 45
simultaneous localization and mapping, 41,
56

single shooting method, 96
SSD-MobileNet V2, 111
stage, 19, 77
state estimation, 91
state of charge, 57, 92, 93
state of health, 62
stochastic battery model, 39
sub-regions, 84
surveillance, 4
sweep line, 84

Index

symmetric encryption, 109
take-off, 109
TeamPlay, 130
temperature, 79
Thevenin model, 64
thrust, 6
Titan, 5
topology, 87
Toradex Ixora, 60
tracking, 84
tradeoffs, 9
transportation, 2
trapezoidal decomposition, 86
travelling salesman problem, 41
triggering point, 20, 77
turning radius, 77
twice differentiability, 17
unmanned aerial systems, 3
unmanned aerial vehicles, 3

159

unmanned ground vehicle, 49
unscented Kalman filter, 38
urban monitoring, 84
V-1 flying bomb, 3
vector field, 10, 17, 78
velocity potential, 79
verices, 23
vertical take-off and landing, 6
watts, 57
wavefront algorithm, 45
wind gusts, 109
workstation, 27
World War I, 3
Wright brother, 3
YOLO, 102
Zamboni motion, 24, 45
Zamboni-like motion, 24, 89, 109

